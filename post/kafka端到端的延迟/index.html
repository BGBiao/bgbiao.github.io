<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>kafka端到端的延迟 - BGBiao的SRE人生</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="BGBiao" />
  <meta name="description" content=" 前言: 在大规模的使用kafka过程中，我们通常会遇到各种各样的问题，比如说，通常会有一些大数据集群中的Job发现总有几个task会比较慢，导致整体的任务迟迟不能完成运行，这种情况通常问题会比较复杂，想要知道具体延迟在哪里，我们需要知道在Kafka集群中哪些点可能会增加端到端的延迟。
 接下来的内容翻译自confluent官网博客中的一篇文章，希望能够帮助大家理解kafka使用过程中端到端的延迟。99th Percentile Latency at Scale with Apache Kafka
" />

  <meta name="keywords" content="SRE, Ops, DevOps, Kubernetes, Docker, CloudNative" />






<meta name="generator" content="Hugo 0.82.0" />


<link rel="canonical" href="https://bgbiao.top/post/kafka%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%BB%B6%E8%BF%9F/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.01e3d8f03f142b439a96010ab309f91dd8b973cdd2248b73944b9b0db931248a.css" integrity="sha256-AePY8D8UK0OalgEKswn5Hdi5c83SJItzlEubDbkxJIo=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/custom.css">


<meta property="og:title" content="kafka端到端的延迟" />
<meta property="og:description" content="
前言: 在大规模的使用kafka过程中，我们通常会遇到各种各样的问题，比如说，通常会有一些大数据集群中的Job发现总有几个task会比较慢，导致整体的任务迟迟不能完成运行，这种情况通常问题会比较复杂，想要知道具体延迟在哪里，我们需要知道在Kafka集群中哪些点可能会增加端到端的延迟。

接下来的内容翻译自confluent官网博客中的一篇文章，希望能够帮助大家理解kafka使用过程中端到端的延迟。99th Percentile Latency at Scale with Apache Kafka" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bgbiao.top/post/kafka%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E5%BB%B6%E8%BF%9F/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-05-23T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-05-23T00:00:00&#43;00:00" />

<meta itemprop="name" content="kafka端到端的延迟">
<meta itemprop="description" content="
前言: 在大规模的使用kafka过程中，我们通常会遇到各种各样的问题，比如说，通常会有一些大数据集群中的Job发现总有几个task会比较慢，导致整体的任务迟迟不能完成运行，这种情况通常问题会比较复杂，想要知道具体延迟在哪里，我们需要知道在Kafka集群中哪些点可能会增加端到端的延迟。

接下来的内容翻译自confluent官网博客中的一篇文章，希望能够帮助大家理解kafka使用过程中端到端的延迟。99th Percentile Latency at Scale with Apache Kafka"><meta itemprop="datePublished" content="2020-05-23T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-05-23T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="12101">
<meta itemprop="keywords" content="运维,kafka," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="kafka端到端的延迟"/>
<meta name="twitter:description" content="
前言: 在大规模的使用kafka过程中，我们通常会遇到各种各样的问题，比如说，通常会有一些大数据集群中的Job发现总有几个task会比较慢，导致整体的任务迟迟不能完成运行，这种情况通常问题会比较复杂，想要知道具体延迟在哪里，我们需要知道在Kafka集群中哪些点可能会增加端到端的延迟。

接下来的内容翻译自confluent官网博客中的一篇文章，希望能够帮助大家理解kafka使用过程中端到端的延迟。99th Percentile Latency at Scale with Apache Kafka"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151318936-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">BGBiao的SRE人生</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/post/">全部文章</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          <div class="mobile-menu-parent">
            <span class="mobile-submenu-open"></span>
            <a href="https://bgbiao.top/">
              学习文档
            </a>
          </div>
          <ul class="mobile-submenu-list">
            
              <li>
                <a href="https://otexts.com/fppcn/index.html">&lt;预测:方法与实践&gt;</a>
              </li>
            
          </ul>
        
      </li><li class="mobile-menu-item">
        
          
          <div class="mobile-menu-parent">
            <span class="mobile-submenu-open"></span>
            <a href="https://bgbiao.top/">
              Golang相关
            </a>
          </div>
          <ul class="mobile-submenu-list">
            
              <li>
                <a href="https://bgbiao.top/">Golang web开发示例</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang SQL开发教程</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang RPCX框架</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang 开源书籍</a>
              </li>
            
          </ul>
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/about/">关于我</a>
          
        
      </li>
    

    
      <li class="mobile-menu-item">
        <a id="openSearchMobile" class="mobile-menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  
    
<div class="modal-dialog">
    
    <div class="modal-content">
      <div id="closeSearch" title="Close" class="close">X</div>
      <div class="modal-header">
        <div class="modal-title">Search</div>
      </div>
      <div class="modal-body">
          <script>
            (function() {
              var cx = '006410550977056989513:rg9ancg1smm';
              var gcse = document.createElement('script');
              gcse.type = 'text/javascript';
              gcse.async = true;
              gcse.src = (document.location.protocol == 'https:' ? 'https:' :
                  'http:') +
                '//cse.google.com/cse.js?cx=' + cx;
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(gcse, s);
            })();
          </script>
          <gcse:search></gcse:search>
      </div>
    </div>
</div>

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      BGBiao的SRE人生
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/post/">全部文章</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          <a class="menu-item-link menu-parent" href="https://bgbiao.top/">学习文档</a>
          <ul class="submenu">
            
              <li>
                <a href="https://otexts.com/fppcn/index.html">&lt;预测:方法与实践&gt;</a>
              </li>
            
          </ul>

        

      </li>
    
        <li class="menu-item">
        
          
          <a class="menu-item-link menu-parent" href="https://bgbiao.top/">Golang相关</a>
          <ul class="submenu">
            
              <li>
                <a href="https://bgbiao.top/">Golang web开发示例</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang SQL开发教程</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang RPCX框架</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang 开源书籍</a>
              </li>
            
          </ul>

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/about/">关于我</a>
          

        

      </li>
    

    
    

    
      <li class="menu-item">
        <a id="openSearch" class="menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">kafka端到端的延迟</h1>
      
      <div class="post-meta">
        <time datetime="2020-05-23" class="post-time">
          2020-05-23
        </time>
        <div class="post-category">
            <a href="https://bgbiao.top/categories/%E8%BF%90%E7%BB%B4/"> 运维 </a>
            
          </div>
        <span class="more-meta"> 12101 words </span>
          <span class="more-meta"> 25 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <blockquote>
<p>前言: 在大规模的使用kafka过程中，我们通常会遇到各种各样的问题，比如说，通常会有一些大数据集群中的Job发现总有几个task会比较慢，导致整体的任务迟迟不能完成运行，这种情况通常问题会比较复杂，想要知道具体延迟在哪里，我们需要知道在Kafka集群中哪些点可能会增加端到端的延迟。</p>
</blockquote>
<p>接下来的内容翻译自<code>confluent</code>官网博客中的一篇文章，希望能够帮助大家理解kafka使用过程中端到端的延迟。<a href="https://www.confluent.io/blog/configure-kafka-to-minimize-latency/">99th Percentile Latency at Scale with Apache Kafka</a></p>
<p>欺诈检测、支付系统和股票交易平台只是许多Apache Kafka用例中的一小部分，这些用例需要快速且可预测的数据交付。例如，在线银行交易的欺诈检测必须实时发生，以交付业务价值，而不需要为每个交易增加超过50 100毫秒的开销，以保持良好的客户体验。</p>
<p>在Kafka术语中，数据交付时间(data delivery time)是由<code>端到端延迟(end-to-end latency)</code>定义的，即<code>消费者获取一条向Kafka生成的记录所需的时间</code>。延迟目标表示为目标延迟和满足此目标的重要性。例如，您的延迟目标可以表示为:我希望99%的情况下从Kafka获得端到端延迟为50 ms。</p>
<p>这将增加<code>可用性、持久性和吞吐量</code>目标。实现高持久性和高吞吐量两个目标，我们需要进行一定的权衡，挑战在于在保持延迟界限的同时扩展应用程序的吞吐量，并调整Kafka集群的大小以使用可接受的Broker延迟来处理客户端和复制的请求。延迟也取决于您对硬件或云提供商的选择，所以您需要能够监视和调优您的客户端，以在您独特的环境中实现您的特定延迟目标。</p>
<p><code>注意</code>: 通常情况下，Broker所在的网络区域其实也会对延迟造成很大影响，当然这仍然取决于您对可用性和延迟的权衡。</p>
<p>之前，我们有写过白皮书<a href="https://www.confluent.io/white-paper/optimizing-your-apache-kafka-deployment/">optimizing-your-apache-kafka-deployment</a>，其中列出了配置Kafka部署以优化各种目标的指导原则。</p>
<p>这篇文章将帮助您进一步获得更好的直觉和对端到端延迟的理解，并配置和扩展您的应用程序的吞吐量，同时保持延迟的界限。</p>
<h4 id="理解到端的延迟end-to-end-latency">理解到端的延迟(end-to-end latency)</h4>
<p>端到端延时是指应用逻辑调用<code>KafkaProducer.send()</code>生产消息到该消息被应用逻辑通过<code>KafkaConsumer.poll()</code>消费到之间的时间。</p>
<p>下图显示了一条记录在系统中的路径，从Kafkas生产者到Kafka的Broker节点，副本的复制，以及消费者最终在其主体分区日志中获取到具体的消息。</p>
<p>因此，端到端的延迟主要会由以下几个部分组成:</p>
<ul>
<li><code>Produce time</code>: 内部Kafka producer处理消息并将消息打包的时间</li>
<li><code>Publish time</code>: producer发送到broker并写入到leader副本log的时间</li>
<li><code>Commit time</code>: follower副本备份消息的时间</li>
<li><code>Catch-up time</code>: 消费者追赶消费进度，消费到该消息位移值前所花费的时间</li>
<li><code>Fetch time</code>: 从broker读取该消息的时间</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2l82tu4nj30nd0dz40n.jpg" alt="kafka端到端的延迟"></p>
<p>在接下来的内容中，我们将分别解释这五个延迟阶段的具体含义，特定的客户端配置或应用逻辑设计通常会极大地影响端到端延时，因此我们有必要精准定位哪个因素对延时的影响最大。</p>
<h4 id="produce-time">Produce time</h4>
<p>Produce time 指的是从应用程序通过<code>KafkaProducer.send()</code>生产一条记录到包含该消息的生产者请求被发往leader副本所在的broker之间的时间。(因此，生产者所处的网络环境以及对应topic分区leader副本所在的broker的网络可能会影响到produce time的延迟)</p>
<p>Kafka producer会将<code>相同topic分区</code>下的一组消息打包在一起形成一个批次（batch）以提升网络I/O性能。(在必要情况下，我们可以对生产者的batch size进行一定的调整)</p>
<p>默认情况下，producer会立即发送batch，这样一个batch中通常不会包含太多的消息。为了提高batch的效率，生产者通常会对<code>linger.ms</code>来人为设置一个较小的延迟来保证有足够多的消息记录能封装在一个batch中。一旦过了<code>linger.ms</code>设置的事件，或者batch size已经达到最大值(<code>batch.size</code>的参数值)，这个batch将被认为已经完成。</p>
<p>如果生产者也开启了压缩(<code>compression.type</code>)，kafka的生产者会将已完成的batch进行压缩。在batch完成之前，它的大小时根据生产者指定的压缩类型和之前观测到的压缩比率估算出来的。</p>
<p>如果发送给leader副本的未确认的生产者请求数量已经达到最大(<code>max.inflight.requests.per.connection=5</code>)，则在生产者的批处理可能需要等待更长的时间。因此，broker响应生产者请求越快，生产者的等待时间也将会变得更小。</p>
<h4 id="publish-time">Publish time</h4>
<p>Publish time是指内部kafka生产者发送生产者请求到一个broker节点，并且对应的消息到达leader副本日志之间的时间。当请求到达Broker节点时，负责连接的网络线程将获取该请求并将其放入请求队列中。其中一个请求处理程序线程从队列中获取请求并处理它们。(对应broker节点的num.thread 和num.io.thread两个相关参数)</p>
<p>因此，Publish time包含生产者请求的网络时间，broker上的排队时间，以及将消息追加到日志所消耗的时间(通常也是page cache 的访问时间)。当Broker端负载比较低，网络和日志的追加写入时间会影响publish time，随着broker负载变高，队列延迟的增加
将会更多的影响publish time。</p>
<h4 id="commit-time">Commit time</h4>
<p>Commit time是指从leader副本中复制消息到全部的同步副本(all in-sync replicas)中所消耗的时间。kafka只会将已提交(committed)的消息暴露给consumer，也就是该消息必须在全部的ISR中包含。follower副本中的消息会从leader副本中并行的拉取，在一个正常的集群中，我们通常不希望副本处于不同步状态(当然有的业务场景可能会导致短暂的不同步现象)。这意味着消息被提交的时间等于ISR中最慢的follower副本所在broker去从ledaer broker节点获取记录并写入到follower副本日志的时间。</p>
<p>为了复制数据，follower所在的broker会想leader节点发送fetch请求，准确的来讲消费者也是使用fetch请求来获取消息。但是，官方在副本复制的fetch请求中，broker端优化了默认配置: leader副本会尽早的发送请求，只要有一个字节可用，就会发起fetch请求(由<code>replica.fetch.min.bytes</code>参数控制)或者当<code>replica.fetch.wait.max.ms</code>满足条件。Commit time主要受副本因此配置参数的影响以及集群的当前负载情况。</p>
<h4 id="catch-up-time">Catch-up time</h4>
<p>Kafka中消息是按照其生产的顺序被消费的，除非显示的声明了一个新的offset或者有一个新的消费者从最新的offset进行消费。同一个分区下，consumer必须要消费完之前发布的消息后才能读取后面的消息。假设在提交消息时，消费者的偏移量是提交消息后面的N条消息，那么，Catch-up time就是消费者消费者N条消息的总时间.</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2mnjafg2j30rs0723z1.jpg" alt="Catch-up time"></p>
<p>当我们在构建实时处理应用的时候，最好让catch-up时间为0，即一旦消息被提交，消费者可以立马读取到消息。如果消费者总是落后，端到端延迟可能会变得无限大。因此，catch-up 时间通常依赖于消费者的能力是否能够追赶上生产者的吞吐量。</p>
<h4 id="fetch-time">Fetch time</h4>
<p>订阅主题分区的消费者会不断轮询去从leader副本中获取更多的数据，Fetch time是从leader副本所在broker节点获取消息记录的s时间，可能需要等待足够的数据来形成对fetch请求的响应，并从<code>KafkaConsumer.poll()</code>的响应中返回记录。在默认的配置下，已经对于消费者的fetch延迟做了优化(<code>fetch.min.bytes</code>=1)，即及时只有一个字节可用的时候，fetch请求也会响应数据，或者在一个短暂超时之后<code>fetch.max.wait.ms</code></p>
<h4 id="end-to-end-latency-vs-producer-and-consumer-latencies">End-to-end latency VS producer and consumer latencies</h4>
<p>下图显示了Kafka客户端观察到的延迟(通常称为生产者延迟和消费者延迟)与端到端延迟之间的关系。</p>
<p>生产者延迟是指<code>KafkaProducer.send()</code>发送和生产的消息被确认间的事件。消息的确认依赖于<code>acks</code>的配置，该参数可以控制消息的持久性(durability):</p>
<ul>
<li>当<code>acks=0</code>，立即确认，不等待broker的返回</li>
<li>当<code>acks=1</code>，消息被追加到leader副本所在分区后再确认</li>
<li>当<code>acks=all</code>，在所有的ISR(同步副本)都接收到消息时才确认</li>
</ul>
<p>所以，生产者延迟包含<code>produce time</code>,<code>publich time(如果acks &gt;= 1)</code>,<code>commit time(如果acks=all)</code> 以及生产者响应从broker返回到生产者的时间。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2n8dbz3bj30rs08a75c.jpg" alt="end-to-end-latency and producer time"></p>
<p>上图清晰的向我们展示了为何改变<code>acks</code>参数能够减少生产者延迟(其实是通过从生产者延迟中移除几个延迟概念来减少的<code>publish和commit</code>)。不过，无论我们如何配置生产者的<code>acks</code>参数，publish和commit 时间总是端到端延迟的一部分。</p>
<p>消费者延迟(Consumer latency)是指消费者发起一个fetch请求到broker节点，以及broker节点向consumer返回响应的时间。计算方法是<code>KafkaConsumer.poll()</code>返回的时间。Consumer的延迟主要包含了上图中的fetch time</p>
<h4 id="控制end-to-end-latency">控制end-to-end latency</h4>
<p>如果我们思考一条消息的生命周期，控制端到端延时其实就是控制消息在系统中流转的时间总和。很多Kafka clients端和broker端参数的默认值已然对延时做了优化：比如减少人为等待时间来提高批处理的能力(通过<code>linger.ms</code>,<code>fetch.min.bytes</code>,<code>replica.fetch.min.bytes</code>参数来适当调优)。其他的延时可能来自于broker端上的队列等候时间，控制这种延时就要涉及控制broker的负载（CPU或吞吐量），通常情况下我们要时刻关注broker节点的各项基础监控指标。</p>
<p>如果我们将系统视为一个整体，那么整个端到端的延迟还要求系统中的每一个部分(生产者,broker,消费者)都能够可靠的维持应用程序逻辑所需的吞吐量。</p>
<p>例如，如果您的应用程序逻辑以100 MB/s发送数据，但是由于某种原因，您的Kafka消费者吞吐量在几秒钟内下降到10 MB/s，那么在此之前产生的大多数消息都需要在系统中等待更长的时间，直到消费者赶上了。此时，你需要一种高效的方式来扩展你的Kafka clients程序以提升吞吐量——高效地利用broker端资源来减少队列等候时间和偶发的网络拥塞。</p>
<p>理想情况下，限制延迟意味着确保所有延迟都低于目标。但实际生产环境中，由于意外故障和峰值负载，这种严格的保证是不可能的。不过，可以设计应用程序并对系统进行调优，以实现95%的延迟目标，控制所有的消息延迟在95~99%低于目标延迟时间。高百分位延迟也称为尾部延迟，因为它们是延迟频谱的尾部。</p>
<p>目标延时所用的百分位越大，你需要降低或容忍应用最差表现所做的努力就越多。比如，偶尔的大请求可能会阻塞全部的请求，从而增加整体的延迟，这也就是所谓的<code>head-of-line</code>队首阻塞。同时，大量低速率客户端可能偶尔会同时向kafka发送生产或消费请求，或全部刷新集群元数据，也会导致请求队列比平常更长，从而引发比平时更严重的尾延迟。这种行为就是所谓的<code>micro-bursting</code>(微型冲击，可能就是水滴石穿的意思吧)</p>
<h4 id="不同客户端配置的延迟测试">不同客户端配置的延迟测试</h4>
<p>在这接下来的内容中，我们使用实验结果来说明Kafka客户端配置和吞吐量扩展技术对性能的影响。我们使用kafka内置的<a href="https://github.com/apache/kafka/tree/trunk/tools/src/main/java/org/apache/kafka/trogdor">Trogdor</a>测试框架以及生产者和消费者的基准测试，<code>ProduceBench</code>和<code>ConsumeBench</code>来进行我们的生产者和消费者实验测试。</p>
<p>我们所有的测试都在一个包含9个代理的Kafka集群上运行，该集群的复制因子为3，这保证了在出现最多两个同时发生的节点故障时不会丢失消息。</p>
<p>Kafka集群运行在AWS的<code>r5.xlarge</code>实例上，使用有2T的EBS(弹性块存储)。Kafka的broker节点分布在同一区域内的三个可用性区域(AZ)，以获得更强的容错性，其中每个主题分区副本被放置在一个不同的AZ上，并且kafka客户端配置使用SASL认证和SSL加密，Broker之间使用<code>PLAINTEXT</code>进行通信。</p>
<p><code>主题:</code>需要注意的是，分布式集群中节点如果在不同可用区也可能导致延迟的增加，当然这要在延迟和容错性角度进行权衡，也需要考虑到云厂商的可用区之间本身的延迟。</p>
<p>我们的实验使用了以下非默认客户端配置和其他规范:</p>
<table>
<thead>
<tr>
<th>参数项</th>
<th>参数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>副本数</td>
<td>3</td>
</tr>
<tr>
<td>topic的分区数</td>
<td>108</td>
</tr>
<tr>
<td>security.protocol</td>
<td>SASL_SSL</td>
</tr>
<tr>
<td>sasl.mechanism</td>
<td>PLAIN</td>
</tr>
<tr>
<td>acks</td>
<td>all</td>
</tr>
<tr>
<td>linger.ms</td>
<td>5</td>
</tr>
<tr>
<td>compression.type</td>
<td>lz4</td>
</tr>
<tr>
<td>Producer record size</td>
<td>value=521bytes/key=4bytes</td>
</tr>
<tr>
<td>Trogdor record value generator</td>
<td>uniformRandom</td>
</tr>
<tr>
<td>Trogdor record key generator</td>
<td>sequential</td>
</tr>
<tr>
<td>Number of Trogdor agents</td>
<td>9</td>
</tr>
</tbody>
</table>
<p>这个测试场景会产生额外的延迟: 多可用区可能增加commit时间，由于是跨可用区的副本。无论是clients端还是broker端，SSL加密也是有开销的。同时由于SSL无法利用Zero Copy特性进行数据传输，因为consumer获取消息时也会增加额外的开销。</p>
<p>虽然这些因素都会影响延迟，但是通常情况下企业内部可能还是需要这种架构上的考虑，因此采用该部署结构进行测试。</p>
<h4 id="持久性设置对延迟的影响">持久性设置对延迟的影响</h4>
<p>当将延迟目标与其他需求叠加在一起时，首先考虑持久性需求是很有用的。由于数据的重要性，通常需要一定程度的持久性。</p>
<p>优化持久性会增加端到端延迟，因为这会增加延迟的复制开销(提交时间)，并向Broker添加复制负载，从而增加排队延迟。</p>
<p><strong>Replication factor</strong></p>
<p>Replication factor 是Kafka持久化保证的核心，它定义了Kafka集群上保存的topic副本数。Replication factor = N 表示我们最多能够容忍N-1台broker宕机而不必数据丢失。N=1能够令端到端延时最小化，但却是最低的持久化保证。</p>
<p>增加副本数会增加备份开销并给broker额外增加负载。如果clients端带宽在broker端均匀分布，那么每个broker都会使用<code>N * w写带宽</code>和<code>r + (N - 1) * w读带宽</code>，其中w是clients端在broker上的写入带宽占用，r是读带宽占用。</p>
<p>由此，降低N 对端到端延时影响的最佳方法就是确保每个broker上的负载是均匀的。这会降低commit time，因为commit time是由最慢的那个follower副本决定的。</p>
<p>如果你的Kafka broker使用了过多的磁盘带宽或CPU，follower就会开始出现追不上leader的情况从而推高了commit time。(其实还需要注意的是，当最小的ISR默认为副本的数量个数时，在出现follower和leader不同步时恰巧leader节点宕机，会导致topic本身不可用)</p>
<p>我们建议为副本同步消息流量设置成使用不同的listener来减少与正常clients流量的干扰。你也可以在follower broker上增加I/O并行度，并增加副本拉取线程数量<code>number.replica.fetchers</code>来改善备份性能。</p>
<p><strong>Acks</strong></p>
<p>纵然我们配置了多个副本，producer还是必须通过acks参数来配置可靠性水平。设置acks=all能够提供最强的可靠性保证，但同时也会增加broker应答PRODUCE请求的时间，就像我们之前讨论的那样。</p>
<p>Broker端应答的速度变慢通常会降低单个producer的吞吐量，进而增加producer的等待时间。这是因为producer端会限制未应答请求的数量(<code>max.inflight.requests.per.connection</code>)。</p>
<p>举个例子，在我们的环境中acks=1，我们启动了9个producer（同时也跑了9个consumer），吞吐量达到了195MB/秒。当acks切换成all时，吞吐量下降到161MB/秒。设置更高级别的acks通常要求我们扩展producer程序才能维持之前的吞吐量水平以及最小化producer内部的等待时间。</p>
<p><strong>Min.insync.replicas</strong></p>
<p><code>min.insync.replicas</code>是一个重要的持久化参数，因为它定义了broker端ISR副本中最少要有多少个副本写入消息才算PRODUCE请求成功。这个参数会影响可用性，但是不会影响端到端的延时。因此，选择一个小一点的值并不能减少commit time并减少延迟。</p>
<h4 id="在满足延迟目标的前提下扩展吞吐">在满足延迟目标的前提下扩展吞吐</h4>
<p><strong>延迟和吞吐的权衡</strong></p>
<p>优化Kafka clients端吞吐量意味着优化batching的效果。Kafka producer内部会执行一类batching，即收集多条消息到一个batch中。</p>
<p>每个batch被统一压缩然后作为一个整体被写入日志或从日志中读取。这说明消息备份也是以batch为单位进行的。</p>
<p>Batching会减少每条消息的成本，因为它将这些成本摊还到clients端和broker端。通常来说，batch越大这种开销降低的效果就越高，减少的网络和磁盘I/O就越多。</p>
<p>另一类batching就是在单个网络请求/响应中收集多个batch以减少网络数据传输量。这能降低clients端和broker端的请求处理开销。这类batching能够提升吞吐量和降低延时，因为batch越大，网络传输I/O量越小，CPU和磁盘使用率越低，故最终能够优化吞吐量。另外batch越大还能减低端到端延时，因为每条消息的成本降低了，使得系统处理相同数量消息的总时间变少了。</p>
<p>这里的延时-吞吐量权衡是指通过人为增加等待时间来提升打包消息的能力。但过了某个程度，人为等待时间的增加可能会抵消或覆盖你从打包机制获得的延时收益。因此你的延时目标有可能会限制你能实施打包化的水平，进而减少所能达到的吞吐量并增加延时。如果拉低了本能达到的吞吐量或端到端延时水平，你可以通过扩展集群来换取或“购买”更多的吞吐量或处理能力。</p>
<h4 id="配置kafka的生产者和消费者以实现batching">配置kafka的生产者和消费者以实现batching</h4>
<p>对于producer而言，batching由两个参数进行控制: <code>batch.size(16KB)</code>和<code>linger.ms(0)</code>，前者控制batch的大小，后者限制延迟量。如果使用场景中，应用会频繁的像kafka集群发送数据，及时设置了<code>linger.ms=0</code>，整个batch也会被尽快填满。如果应用生产数据的频率较低，可以通过增加<code>linger.ms</code>来增加batch。</p>
<p>对于consumer而言，可以调整<code>fetch.min.bytes(1)</code>来限制每个消费者在每个fetch响应中接收的数据量，该参数指定了broker应该在一个fetch响应中返回的最小数据，以及<code>fetch.max.wait.ms(500)</code>来设置等待数据的超时时间。在fetch响应中的数据越多，就会有更少的fetch请求。</p>
<p>在生产者端的batching也会间接影响produce和fetch的请求数量，因为batch定义了数据能够被获取的最小数据量。</p>
<p>值得注意的是，默认情况下，Kafka producer和consumer设置的是无人为等待时间，这么做的目的是为了降低延时。但是，即使你的目标就是了使延时最小化，我们依然推荐你设置一个不为0的linger.ms值，比如5~10ms。当然，这么做是有前提的：</p>
<ul>
<li>如果你扩展了你的producer程序，平均下来使得每个producer实例的发送速率变得很低，那么你的batch只会包含很少的几条消息。如果你整体的吞吐量已然很高了，那么你可能会直接把你的Kafka集群压挂，导致超高的队列等候时间从而推高延时。此时，设置一个较小的<code>linger.ms</code>值确实能够改善延时。</li>
<li>如果你在意尾延时，那么增加<code>linger.ms</code>可能会降低请求速率以及同时到达broker端的瞬时冲击流量。这种冲击越大，请求在尾部的延时就越高。这些瞬时冲击流量决定了你的尾延时水平。</li>
</ul>
<p>下面这个实验说明了以上两种场景。我们启动了90个producer，向一个有108个分区的topic发送消息。生产端整体的吞吐量峰值在90MB/秒。我们跑了3次测试，每一次对应一种不同的producer配置。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2squjyvij30rs0fzaaz.jpg" alt=""></p>
<p>因为在给定的总吞吐下，我们有相对大量的生产者，因此<code>linger.ms = 0</code>导致在生产者端机会没有batch操作。将<code>linger.ms</code>从0调整到5可以增加batching能力: 向kafka发起的生产者请求从2800降低到了1100。这减少了50%和99%的生产者延迟。</p>
<p>增加<code>batch.size</code>不会直接影响生产者的等待时间，因为生产者在填满batch的时间不会超过<code>linger.ms</code>的限制。在我们的实验中，增加<code>batch.size</code>从16KB到128KB没有增加bacth的效果，因为每个生产者的吞吐量非常低。正如预期的那样，生产者延迟在两种配置之间没有变化。</p>
<p>总之，如果您的目标是最小化延迟，我们建议保留默认的客户端批处理配置，并尽可能增加<code>linger.ms</code>。如果你在意尾延时，最好调优下打包水平来减少请求发送率以及大请求冲击的概率。</p>
<h4 id="不增加人为延迟以提高batching效率">不增加人为延迟以提高batching效率</h4>
<p>batching效果不好的另一个原因是producer发送消息给大量分区。<code>如果消息不是发往同一个分区的，它们就无法聚集在一个batch下</code>。因此，通常最好设计成让每个producer都只向有限的几个分区发送消息。</p>
<p>另外，可以考虑升级到Kafka 2.4 producer。这个版本引入了一个全新的Sticky分区器。该分区器能够改善non-keyed topic的打包效果，同时还无需引入人为等待。</p>
<h4 id="clients的数量对尾延迟tail-latency的影响">clients的数量对尾延迟(tail-latency)的影响</h4>
<p>即使整体的生产和消费的吞吐量保持不变，通常也是Clients数越多，broker上负载越大。这是因为clients数量多会导致更多的METADATA请求发到Kafka，继而要维护更多的连接，故给broker带来更大的开销。</p>
<p>相对于50%或平均延时的影响，Clients数量增加对尾延时的影响更大。</p>
<p>每个producer最多发送<code>max.inflight.requests.per.connection</code>个PRODUCE请求给单个broker，而每个consumer一次最多只会给一个broker发送FETCH请求。Clients越多，同一时刻发送到broker的PRODUCE和FETCH请求也就越多，这就增加了形成请求瞬时冲击的概率，进而推高了尾延时。</p>
<p>Consumer数量通常由topic分区数量以及期望consumer没有较大lag的目标共同决定。但是，我们却很容易为了扩展吞吐量而引入大量的producer。</p>
<p>基于吞吐量的考量增加producer实例数可能有相反的效果，因为producer会导致更少的消息被打包，毕竟每个producer处理了更少的消息，因而发送速率会变慢。同时producer还必须等待更长的时间来积累相同数量的消息进到batch里面。</p>
<p>在我们的实验中，我们将producer的数量从90增加到900，发现吞吐量没有他打变化：90MB/秒。</p>
<p>我们使用<code>batch.size=16KB</code>,<code>linger.ms=5</code>,<code>acks=all</code>的生产者配置，实验结果如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2s85pax9j30rs0f60tm.jpg" alt=""></p>
<p>结果显示增加producer数量(90-&gt;900)增加了60%的中位数延时值，而99%延时值几乎增加了3倍。</p>
<p>延时的增加是因为producer端打包效果变差导致的。</p>
<p>尾延时的增加是因为更大的请求瞬时冲击，这会拉升broker端延时，同时producer端会等待更长的时间来接收应答。</p>
<p>在900个producer的测试中，broker完全被PRODUCE请求压垮了。用于处理请求的时间几乎占到了broker端CPU使用率的100%。另外由于我们使用了SSL，它也会进一步引入请求级的开销。</p>
<p>如果你通过添加producer来提升吞吐量，那么可以考虑增加单个proudcer的吞吐量，即<code>改善batching的效果</code>。不管怎样，你最终可能会有很多producer实例。比如，大公司收集设备上的统计指标，而设备数可能有成千上万。此时，你可以考虑使用一个Broker收集来自多个clieints的请求，然后把它们转换成更高效的PRODUCE请求再发给Kafka。你也可以增加broker数来降低单个broker上的请求负载。</p>
<h4 id="关于增加消费者数量的说明">关于增加消费者数量的说明</h4>
<p>当扩展消费者时需要注意，在同一个消费者组的消费者会提交offset信息和心跳到broker节点上(controller节点)。如果按时间间隔执行偏移提交(<code>auto.commit.interval.ms</code>)，则消费者组中的更多消费者者会增加偏移提交率。偏移量提交本质上是向内部<code>__consumer_offsets</code>产生请求，因此增加consumer数量会导致broker上的请求负载增加，特别是<code>auto.commit.interval.ms</code>值很小的时候。</p>
<h4 id="压缩配置的影响">压缩配置的影响</h4>
<p>默认情况下，Kafka producer不做压缩。<code>compression.type</code>参数可以决定要不要做压缩。</p>
<p>压缩会在producer端引入额外的开销来压缩消息，在broker端做校验时解压缩从而引入额外的开销，另外在consumer端解压缩也是开销。</p>
<p><code>注意</code>:通常情况下broker端的压缩参数需要设置成<code>producer</code>，以避免压缩方式冲突导致数据无法正常消费，这样broker只需要直接将压缩后的日志写入</p>
<p>虽然压缩会增加CPU开销，但它还是可能减少端到端延时的，因为它能显著地降低处理数据所需的带宽占用，进而减少broker端的负载。压缩是在batch级别上完成的，故打包效果越好，压缩效果也就越好。</p>
<h4 id="更多的分区可能增加延迟">更多的分区可能增加延迟</h4>
<p>一个主题的分区是kafka中的并行单元。发送到不同分区的消息可以由生产者并行发送，由不同的Broker并行写入，并可以由不同的消费者并行读取。因此，更多的分区通常会导致更高的吞吐量，不过单从吞吐量的角度来看，我们能够从每个Broker有10个分区的kafka集群，就已经能够达到最大的吞吐量了。您可能需要更多的主题分区来支持您的应用程序逻辑。</p>
<p>但是，太多的分区可能导致更多的端到端的延迟。每个主题的分区越多，对生产者的批处理就越少。每个Broker的主题分区越多，每个follow副本获取请求的开销就越大。每个fetch请求必须去枚举自己感兴趣的分区，并且每个leader副本必须去检查状态，同时从请求的每个分区中去fetch数据，这通常会导致较小的磁盘I/O。因此，越多的分区，可能会导致更长的commit time和更高的cpu使用，最终导致较长的排队延迟。</p>
<p>提交时间的增加和更高的CPU负载会导致所有共享同一个Kafka集群的客户端端到端延迟的增加，即使是那些只生产和使用少量主题分区的客户端来说，也是如此。</p>
<p>我们使用两个topic来做此次测试。一个Topic有9个生产者生产5MB/s的数据，然后有一个对应9个消费者的消费者组。这个实验持续了几天，我们将这个主题中的分区数量从108个逐步增加到7200个(每个Broker8000个)，每个步骤运行一个小时。第二个主题在整个实验运行期间有9个分区和9个生产者，每个生产者向一个分区和一个对应的消费者组(每个分区一个)生产消息，该主题每秒生产一个512bytes的数据。</p>
<p>下图显示了分区数量对客户端访问9分区主题的99%的端到端延迟的影响，随着每个broker上分区数的增加，clients的端到端延时大致呈线性增加趋势。分区数的增加会推高broker上的CPU负载同时拖慢所有clients的备份，即使是对那些只与固定分区数量交互的clients而言，也会抬高端到端延迟。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2rwiufyuj30rs0eh0ty.jpg" alt="mutli-partition-latency"></p>
<p>为了减少延时，最好还是限制每个broker上的分区数，方法是减少总的分区数或扩展集群。你还可以通过增加fetcher线程数量的方式来改善commit time。</p>
<h4 id="broker节点负载对延迟的影响">broker节点负载对延迟的影响</h4>
<p>我们已经讨论了Broker上的负载导致增加排队延迟，从而增加了端到端的延迟，很容易看出为什么请求速率的增加会加剧排队延迟，因为更多的请求会导致更大的队列。</p>
<p>broker节点上高资源利用率(磁盘或cpu)可能导致更高的队列的延迟，并且延迟的增长会随着资源利用率的增长呈指数级增长。这是一个可以有排队理论解释的已知属性: Kingman公式证明等待某种资源的时间正比于资源繁忙程度/资源空闲程度<code>(% of time resource is busy)/(% of time resource is idle)</code>.</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf2r3oe03wj30rs0gb0tp.jpg" alt=""></p>
<p>由于延迟随资源利用率呈指数增长，如果broker中的任何资源的利用率接近100%，您可能会看到很高的延迟。通过减少每个Broker的资源使用(比如减少每个broker的链接数，请求以及分区数)或扩展集群来整体降低每个broker节点的资源使用率，在这种情况可以显著降低延迟。保持负载在broker之间平均通常情况下是非常有用的，同时也可以<code>均匀地或基于负载分布分区副本</code>也能降低尾部延迟。</p>
<p>因此，通常情况下，负责kafka集群的SRE团队需要自动检测Broker节点上的高资源利用率(磁盘和CPU)，然后重新平衡集群上的分区，以便更均匀地在Broker之间重新分配负载，或者在需要时扩展集群。而如果使用云厂商提供的kafka服务，则可以适当避免这类事情的发生，因为云服务会去做相关的事情。</p>
<h4 id="总结">总结</h4>
<p>我们已经演示了，在为吞吐量扩展客户机和分区时的边界延迟要求时可以通过限制每个broker的连接数、分区数和请求速率来限制每个broker的使用。</p>
<p>边界尾延迟需要额外注意减少来自客户机的任何突发(连接和请求)或应用程序行为中的差异。</p>
<p>均匀加载的broker节点对于最小化尾部延迟也很重要，因为它受到最慢broker的影响。</p>
<p>如下是一些相关扩展的文章，可能有助于我们控制整体延迟:</p>
<ul>
<li><a href="https://www.confluent.io/white-paper/optimizing-your-apache-kafka-deployment/">Optimizing Your Apache Kafka Deployment</a>提供配置Kafka部署的指导方针，以优化各种目标:吞吐量、延迟、持久性和可用性(公众号回复:<code>kafka</code>可获取资料)</li>
<li><a href="https://www.confluent.io/blog/how-choose-number-topics-partitions-kafka-cluster">How to Choose the Number of Topics/Partitions in a Kafka Cluster?</a>(2016) 和<a href="https://www.confluent.io/blog/apache-kafka-supports-200k-partitions-per-cluster">follow-updates</a>有一些kafka 2.0版本的优化</li>
<li><a href="https://www.confluent.io/blog/apache-kafka-producer-improvements-sticky-partitioner">Improving batching with the new sticky partitioner</a></li>
<li><a href="https://cwiki.apache.org/confluence/display/KAFKA/KIP-345%3A+Introduce+static+membership+protocol+to+reduce+consumer+rebalances">KIP-345</a>: 引入静态成员协议来减少消费者的再平衡</li>
</ul>
<hr>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg" alt="公众号"></p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">BGBiao</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-05-23
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处<BGBiao>。谢谢！</span>
  </p>
</div>


    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/reward_wechat.png">
        <span>Wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/reward_wechat.png">
        <span>Alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://bgbiao.top/tags/%E8%BF%90%E7%BB%B4/">运维</a>
          <a href="https://bgbiao.top/tags/kafka/">kafka</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/elasticsearch%E6%9E%B6%E6%9E%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">ElasticSearch架构解析与最佳实践</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/kafka%E5%A6%82%E4%BD%95%E5%90%88%E7%90%86%E8%A7%84%E5%88%92%E5%88%86%E5%8C%BA%E6%95%B0%E9%87%8F/">
            <span class="next-text nav-default">kafka如何合理规划分区数量</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "BGBiao/comments-bgbiao.top"
            issue-term="pathname"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:weichuangxxb@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/BGBiao/" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://bgbiao.top/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        BGBiao
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  











  <script>
    $("#openSearch, #openSearchMobile").click(function(){
      $(".modal-dialog").addClass("visible");
    });

    $("#closeSearch").click(function(){
      $(".modal-dialog").removeClass("visible");
    });

    $(document).click(function(event) {
    
      if (!$(event.target).closest(".modal-content, #openSearch, #openSearchMobile").length) {
        $("body").find(".modal-dialog").removeClass("visible");
      }
    });
  </script>





</body>
</html>
