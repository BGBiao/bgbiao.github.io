<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>kafka生产规划和运维 - BGBiao的SRE人生</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="BGBiao" />
  <meta name="description" content=" 前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有Redis集群，ElasticSearch集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。
 笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20&#43;ECS，总数据量大约400T，其中承接的Topic服务主要分为日志收集、数据管道、流式计算、业务事件存储几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的可用性，可靠性，数据一致性要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。
鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识.
" />

  <meta name="keywords" content="SRE, Ops, DevOps, Kubernetes, Docker, CloudNative" />






<meta name="generator" content="Hugo 0.83.1" />


<link rel="canonical" href="https://bgbiao.top/post/kafka%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E7%BB%B4/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.444f741ba7b684e63dff9a3b61ec1fb750c9b563b5a0b64153f1af8025c5fac1.css" integrity="sha256-RE90G6e2hOY9/5o7Yewft1DJtWO1oLZBU/GvgCXF&#43;sE=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/custom.css">


<meta property="og:title" content="kafka生产规划和运维" />
<meta property="og:description" content="
前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有Redis集群，ElasticSearch集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。

笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20&#43;ECS，总数据量大约400T，其中承接的Topic服务主要分为日志收集、数据管道、流式计算、业务事件存储几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的可用性，可靠性，数据一致性要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。
鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bgbiao.top/post/kafka%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E7%BB%B4/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-04-25T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-11-01T17:14:34&#43;08:00" />

<meta itemprop="name" content="kafka生产规划和运维">
<meta itemprop="description" content="
前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有Redis集群，ElasticSearch集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。

笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20&#43;ECS，总数据量大约400T，其中承接的Topic服务主要分为日志收集、数据管道、流式计算、业务事件存储几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的可用性，可靠性，数据一致性要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。
鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识."><meta itemprop="datePublished" content="2020-04-25T00:00:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-11-01T17:14:34&#43;08:00" />
<meta itemprop="wordCount" content="25324">
<meta itemprop="keywords" content="运维,kafka," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="kafka生产规划和运维"/>
<meta name="twitter:description" content="
前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有Redis集群，ElasticSearch集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。

笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20&#43;ECS，总数据量大约400T，其中承接的Topic服务主要分为日志收集、数据管道、流式计算、业务事件存储几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的可用性，可靠性，数据一致性要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。
鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-151318936-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">BGBiao的SRE人生</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/post/">全部文章</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          <div class="mobile-menu-parent">
            <span class="mobile-submenu-open"></span>
            <a href="https://bgbiao.top/">
              学习文档
            </a>
          </div>
          <ul class="mobile-submenu-list">
            
              <li>
                <a href="https://otexts.com/fppcn/index.html">&lt;预测:方法与实践&gt;</a>
              </li>
            
          </ul>
        
      </li><li class="mobile-menu-item">
        
          
          <div class="mobile-menu-parent">
            <span class="mobile-submenu-open"></span>
            <a href="https://bgbiao.top/">
              Golang相关
            </a>
          </div>
          <ul class="mobile-submenu-list">
            
              <li>
                <a href="https://bgbiao.top/">Golang web开发示例</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang SQL开发教程</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang RPCX框架</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang 开源书籍</a>
              </li>
            
          </ul>
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/about/">关于我</a>
          
        
      </li>
    

    
      <li class="mobile-menu-item">
        <a id="openSearchMobile" class="mobile-menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  
    
<div class="modal-dialog">
    
    <div class="modal-content">
      <div id="closeSearch" title="Close" class="close">X</div>
      <div class="modal-header">
        <div class="modal-title">Search</div>
      </div>
      <div class="modal-body">
          <script>
            (function() {
              var cx = '006410550977056989513:rg9ancg1smm';
              var gcse = document.createElement('script');
              gcse.type = 'text/javascript';
              gcse.async = true;
              gcse.src = (document.location.protocol == 'https:' ? 'https:' :
                  'http:') +
                '//cse.google.com/cse.js?cx=' + cx;
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(gcse, s);
            })();
          </script>
          <gcse:search></gcse:search>
      </div>
    </div>
</div>

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      BGBiao的SRE人生
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/post/">全部文章</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          <a class="menu-item-link menu-parent" href="https://bgbiao.top/">学习文档</a>
          <ul class="submenu">
            
              <li>
                <a href="https://otexts.com/fppcn/index.html">&lt;预测:方法与实践&gt;</a>
              </li>
            
          </ul>

        

      </li>
    
        <li class="menu-item">
        
          
          <a class="menu-item-link menu-parent" href="https://bgbiao.top/">Golang相关</a>
          <ul class="submenu">
            
              <li>
                <a href="https://bgbiao.top/">Golang web开发示例</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang SQL开发教程</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang RPCX框架</a>
              </li>
            
              <li>
                <a href="https://bgbiao.top/">Golang 开源书籍</a>
              </li>
            
          </ul>

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://bgbiao.top/about/">关于我</a>
          

        

      </li>
    

    
    

    
      <li class="menu-item">
        <a id="openSearch" class="menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">kafka生产规划和运维</h1>
      
      <div class="post-meta">
        <time datetime="2020-04-25" class="post-time">
          2020-04-25
        </time>
        <div class="post-category">
            <a href="https://bgbiao.top/categories/%E8%BF%90%E7%BB%B4/"> 运维 </a>
            
          </div>
        <span class="more-meta"> 25324 words </span>
          <span class="more-meta"> 51 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一kafka集群运维和规划">一、Kafka集群运维和规划</a></li>
    <li><a href="#二集群规划">二、集群规划</a>
      <ul>
        <li><a href="#1硬件和os">1.硬件和OS</a></li>
        <li><a href="#2节点配置">2.节点配置</a></li>
        <li><a href="#3jvm配置">3.JVM配置</a></li>
        <li><a href="#4kafka核心配置">4.kafka核心配置</a></li>
      </ul>
    </li>
    <li><a href="#三集群管理">三、集群管理</a>
      <ul>
        <li><a href="#1-官方工具">1. 官方工具</a></li>
        <li><a href="#2-kafka-manager">2. kafka-manager</a></li>
      </ul>
    </li>
    <li><a href="#四集群监控">四、集群监控</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <blockquote>
<p>前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有<code>Redis集群</code>，<code>ElasticSearch</code>集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。</p>
</blockquote>
<p>笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20+ECS，总数据量大约400T，其中承接的Topic服务主要分为<code>日志收集</code>、<code>数据管道</code>、<code>流式计算</code>、<code>业务事件存储</code>几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的<code>可用性</code>，<code>可靠性</code>，<code>数据一致性</code>要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。</p>
<p>鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识.</p>
<h2 id="一kafka集群运维和规划">一、Kafka集群运维和规划</h2>
<p>其实任何开源的分布式系统在开始规划时，就需要考虑到业务场景，以及生产环境的周边可观测系统，比如如下几个方面:</p>
<ul>
<li>规划和部署生产级别的集群(包含官方最佳实践以及一些针对不停场景推荐的配置项变更)</li>
<li>执行一些部署后的操作(比如滚动重启集群，集群备份，数据迁移等等)</li>
<li>集群的可观测性(监控重要统计数据，理解kafka内部行为的具体含义以及是否需要报警通知)</li>
</ul>
<h2 id="二集群规划">二、集群规划</h2>
<p>本节主要介绍，kafka集群在生产环境部署前的一些规划，包含硬件配置选择，网络以及文件系统和其他考虑的选型.</p>
<h3 id="1硬件和os">1.硬件和OS</h3>
<p><code>注意:</code>通常对于分布式的开源服务来将对于硬件本身没有太高的要求，但当需要承载一定量级的业务时，我们需要考虑一些硬件是否能够支撑对应的业务场景，并且通常来讲针对不同的业务场景选择不同的硬件(如果可选择)，也许会适当降低资源成本。</p>
<h4 id="10-os">1.0 OS</h4>
<p>一般来说，对于运行Linux中的kafka集群不需要过多的OS以及kernel参数调整，但如下几种情况可以根据具体情况进行参考:</p>
<ul>
<li><code>文件描述符(fd)</code>: broker节点上fd限制可以参考<code>(number_of_partitions)*(partition_size/segment_size)</code>公式</li>
<li><code>套接字缓冲区(socket buffer)</code>: 该参数可以增加多数据中心之间的数据传输(一般异地集群备份建议调整以增加吞吐)</li>
<li><code>最大内存映射区域数(vm.max_map_count)</code>: 当kafka broker节点拥有太多分区时应该密切关注系统级别的该参数，默认为65535。每一个日志段，分配的分区，都需要一对<code>index/timeindex</code>文件，而每个文件都会消耗一个内存区域(一个日志段使用2个内存映射区域)，因此一个分区至少需要2个内存区域，一个broker上拥有50000分区时，将会消耗100000个内存区域，此时默认的参数就会导致broker 以<code>OutOfMemoryError</code>方式crash掉。</li>
</ul>
<p><code>注意:</code>每个分区的日志段的数量取决于段(segment)的大小，负载，以及保留策略</p>
<p>kafka使用大量的文件以及socket和客户端进行通讯，我们都知道，在Linux下，一切皆文件，因此系统需要设置更多的可用文件描述符&gt;。</p>
<p>在大多数的默认系统配置中，单个进程可用使用1024个文件描述符，对于kafka来说太小了，建议调整到至少<code>100000</code>，但是通常和操作
系统以及发行版本有关系，需要根据具体的OS进行调整。</p>
<p>可用通过计算Kafka数据目录中的<code>.index</code>文件来计算当前的mmap编号。<code>.index</code>文件大多数代表了内存映射文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 1.统计.index文件个数
$ find . -name &#39;*index&#39; | wc -l

# 2.为每个session设置vm.max_map_count参数，这将计算当前内存映射文件的数量，mmap限制的最小值就是打开文件的ulimit限制
# 该值要远大于index的数量
$ sysctl -w vm.max_map_count=262144

# 3.持久化mmap参数
$ echo &#39;vm.max_map_count=262144&#39; &gt;&gt; /etc/sysctl.conf
$ sysctl -p
</code></pre></td></tr></table>
</div>
</div><h4 id="11-内存">1.1 内存</h4>
<p>Kafka严重依赖文件系统来存储和缓存消息。</p>
<p>所有数据都会立即写入文件系统上的持久日志中，而不必刷新到磁盘。实际上，这仅意味着将其转移到内核的页面缓存<code>pagecache</code>中。 当回收内存时，操作系统会将可用内存转移到磁盘缓存中，而对性能的影响很小。</p>
<p>同时，Kafka非常小心地使用堆空间<code>heap space</code>，不需要将堆大小设置为超过6 GB，这样将会在32G内存的机器上缓存28-30G的数据到文件系统。</p>
<p>因此，生产集群需要足够的内存来缓存活动的reader和writer。在Confluent的使用建议中，提出了对内存需求的粗略估计方式，比如需要缓冲30s，那么内存需求大概为<code>write_throughput * 30</code>。</p>
<p>通常来讲<code>64G</code>内存配置的机器是一个不错的选择.</p>
<h4 id="12-cpu">1.2 CPU</h4>
<p>大多数的kafka集群对于cpu的要求不是那么高，因此对于CPU的配置没有像其他资源那么重要(但是通常同等资源都是由一定比例配比的)。</p>
<p><code>注意:</code> 如果开启了SSL，那么可能对集群的整体性能有一定影响，且对cpu有一定要求，具体需要考虑到cpu的类型以及具体的JVM实现细节(通常来讲内部服务均不会开启SSL，因为管理成本很高，且性能上略有损失，安全上可以通过整体的IT安全进行要求和管控)</p>
<p>通常情况下建议使用较新的多核处理器，通用集群可以设置为<code>24</code>核心。</p>
<p>如果需要在更快的CPU或更多的内核之间进行选择，请选择更多的内核，因为多核提供的额外并发性将远远超过稍快的时钟速度。</p>
<h4 id="13-disk">1.3 Disk</h4>
<p>生产集群建议使用多块磁盘来最大化整体的吞吐，不要与应用程序日志或其他OS文件系统活动共享用于Kafka数据的相同驱动器，以确保良好的延迟。</p>
<p>在官方的最佳实践中建议，可以将<code>多块磁盘构建成RAID</code>，或者直接将独立的<code>多块磁盘</code>作为kafka的数据存储，也就是JBOD方案(Just Bunch Of Disks)。</p>
<p><code>备注:</code>如果软RAID的话其实会在存储方面增加一层数据均衡，增加了集群的复杂度，因此一般可用选择后者，而且RAID主要用于提供冗余，对于开源分布式服务来讲，在软件层面上基本都会保证数据的冗余。</p>
<p>不过在实际的场景中，具体选择使用多块盘做RAID还是直接使用多块盘挂载，以下有几种场景可以考虑:</p>
<p>如果配置多个数据目录，则Broker将在路径中放置一个新分区，该分区中当前存储的分区数最少。每个分区将完全位于数据目录之一中，如果<code>分区之间的数据不平衡，就会导致磁盘之间的负载不平衡</code>。</p>
<p>RAID在平衡磁盘之间的负载方面做得更好，它能在较低的水平上平衡负载。RAID的主要缺点是减少了可用的磁盘空间(RAID0除外)，好处是可以容忍磁盘故障(RAID1，RAID5等)。</p>
<p>在生产中强烈不建议使用RAID 5 or RAID 6 ,会严重影响到写吞吐的性能，并且在磁盘故障时会有重建阵列的I/O成本(<code>RAID0下也存在重建I/O的成本</code>)</p>
<p>如果额外的成本可以接受，建议使用RAID10(容量减半，多一份冗余)，否则，建议Kafka服务器配置多个日志目录，每个目录都安装在单独的驱动器上。</p>
<p>linked使用8x7200转的sata磁盘，一般来说，磁盘吞吐量是性能瓶颈，磁盘越多越好。</p>
<p>kafka官方文档中其实建议使用多个驱动器以获得良好的吞吐量，因为每个路径都独立挂载在不同的磁盘上，这使得多块物理磁盘磁头同时执行物理I/O写操作，可以极大地加速Kafka消息生产的速度。</p>
<p><code>注意:</code> 通常在使用本地盘时，容量可能会比较大，当磁盘容量超过2T时，Linux下默认的MBR分区就不能满足容量的要求了，此时需要在分区时进行GPT分区，否则等线上业务真正上线后会发现超过2T的空间就被浪费了。</p>
<p>另外一个问题就是，磁盘容量规划的问题，虽然kafka默认为全部的日志数据设置了7天保留时间，但是往往在海量的数据消费场景中，单天的数据量也可能达到好几个T，这就导致了需要提前对业务的场景和使用方式进行提前规划，并提前计算最少的存储量。</p>
<p>但一般对于磁盘空间的规划可以根据消息量大概估算，比如一天7亿条消息，单条1kb，消息副本为3(可保证2节点同时挂)，那么大概的存储空间为<code>7亿*3*1KB/1000/1000=2100G</code>，也就是这种规模下的数据，一天产生2T的数据，实际使用数据为700G，1400G数据为冗余数据，此时我们在规划磁盘容量时就需要考虑到单天数据量的大小，以及数据的保留时间。</p>
<p><code>注意:</code> 如果客户端开启了消息压缩，整体的数据能再相对小一些，可以根据具体情况来考虑</p>
<h4 id="14-network">1.4 Network</h4>
<p>在分布式系统中，快速可靠的网络是性能的一个重要组成部分(<code>因此通常分布式系统中建议在同机房</code>)。</p>
<p>低延迟确保节点可以轻松通信，而高带宽有助于集群节点之前的副本移动和恢复(<code>往往在kafka集群中优先瓶颈点都是带宽</code>)。</p>
<p>目前大多数的数据中心基本都是千兆(1 GbE)或万兆网络(10 GbE)，对于大多数集群通常都是足够的。</p>
<p>应该尽量避免集群跨越多个数据中心，即使数据中心在很近的距离同地区，也要避免跨越巨大地理距离的集群。</p>
<p><code>备注:</code>实际上在分布式系统中分区是肯定会发生的，通过避免跨机房部署能够降低分区的概率</p>
<p>Kafka集群假设所有节点都是相等的，较大的延迟可能会加剧分布式系统中的问题，并使调试和解决变得更加困难。</p>
<p><code>注意:</code> 如果业务上需要异地进行数据读写，推荐的方法是在每个数据中心中部署一个本地Kafka集群，每个数据中心中的应用程序实例只与它们的本地集群交互，并在集群之间进行镜像(kafka提供了mirror-maker工具)。</p>
<h4 id="15-filesystem">1.5 Filesystem</h4>
<p>现在操作系统中，大部分的系统应该都使用了<code>Ext4</code>或<code>XFS</code>系统，官方也推荐使用这两种文件系统，但是对于具体的文件系统的选择，官方提供了如下几种场景和需要注意的点。</p>
<p>使用各种文件系统创建和挂载选项，在具有大量消息负载的集群上执行了比较测试，XFS带来了更好的本地时间(最好的EXT4配置是160ms vs. 250ms+)，以及更低的平均等待时间。XFS性能在磁盘性能方面的可变性也较小。</p>
<p>不论是使用哪种文件系统，推荐修改默认的挂载参数:</p>
<ul>
<li><code>noatime</code>: 此选项禁止在读取文件时更新文件的atime(最后访问时间)属性,这可以消除大量的文件系统写操作，特别是在引导消费者的情况下,Kafka完全不依赖于atime属性，所以禁用它是安全的</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ cat /etc/fstab
UUID=&#34;4231b126-7e67-45c4-b8bf-554006291d35&#34;  /export1    xfs    defaults,noatime         0 2

</code></pre></td></tr></table>
</div>
</div><p>XFS文件系统挂载参数优化:</p>
<ul>
<li><code>largeio</code>: 这会影响stat调用报告的首选I/O大小，尽管这可以在较大的磁盘写入上实现更高的性能，但实际上对性能的影响很小或没有影响</li>
<li><code>nobarrier</code>: 于具有电池后备缓存的基础设备，此选项可以通过禁用定期写刷新来提供更高的性能。 但是，如果基础设备的行为良&gt;好，它将向文件系统报告它不需要刷新，并且此选项将无效。</li>
</ul>
<p>EXT文件系统挂载参数优化:</p>
<p><code>注意:</code> 在ext4文件系统下，要获得最佳性能，则需要调整几个参数。这些选项在故障情况下通常是不安全的，并且将导致更多的数据丢失和损坏，对于单个broker故障，可以擦除磁盘并从群集重建副本，在多数情况下，多broker异常意味着潜在的文件系统损坏，无法轻易恢复。</p>
<ul>
<li><code>data=writeback</code>: Ext4默认为data = ordered，这使某些写入操作具有很强的顺序，在Kafka场景下其实不需要该参数，此设置消除了排序约束，并且似乎大大减少了延迟</li>
<li><code>Disabling journaling</code>: 日志记录是一个折衷:它使服务器崩溃后重新引导更快，但它引入了大量额外的锁定，增加了写入性能的差异</li>
<li><code>commit=num_secs</code>: 这调整了ext4提交到其元数据日志的频率。 将此值设置为较低的值可以减少崩溃期间未刷新数据的丢失。 将此值设置为较高的值将提高吞吐量。</li>
<li><code>nobh</code>: 此设置控制在使用data=writeback模式时附加的排序保证，可以提高吞吐量和延迟</li>
<li><code>delalloc</code>: 延迟分配意味着文件系统避免在物理写入发生之前分配任何块，此功能非常适合吞吐量</li>
</ul>
<h4 id="16-application-vs-os-flush-management">1.6 Application vs. OS Flush Management</h4>
<p>Kafka始终会立即将所有数据写入文件系统，并支持配置刷新策略的功能，该策略控制何时使用刷新将数据从OS缓存中强制出到磁盘上。</p>
<p>可以控制此刷新策略，以在一段时间后或在写入一定数量的消息之后将数据强制到磁盘。 在此配置中有几种选择。</p>
<p>Kafka必须最终调用fsync才能知道数据已刷新。</p>
<p><code>当从崩溃中恢复任何未知的日志段时，Kafka将通过检查其消息的CRC来检查每条消息的完整性，并在启动时执行的恢复过程中重建附带的偏移索引文件</code>。</p>
<p>请注意，Kafka中的持久性不需要将数据同步到磁盘，因为发生故障的节点将始终从其副本中恢复。</p>
<p>我们建议使用默认刷新设置，该设置将完全禁用应用程序的fsync。</p>
<p>这意味着依靠操作系统和Kafka自己的后台刷新来完成后台刷新。</p>
<p>这为所有用途提供了最佳的解决方案：无需调节配置，提高吞吐量和延迟，并提供完全恢复保证。</p>
<p>通常，我们认为<code>复制</code>提供的保证要强于<code>同步到本地磁盘</code>，但是偏执狂仍然更愿意同时拥有两者，并且仍然支持应用程序级fsync策略。</p>
<p>使用应用程序级刷新设置的缺点是，其磁盘使用模式效率较低（它给操作系统减少了重新排序写操作的余地），并且由于大多数Linux文件系统中的fsync阻止了文件写入，因此它会引入延迟。 后台刷新进行更精细的页面级锁定。</p>
<h4 id="17-理解linux操作系统的flush行为">1.7 理解Linux操作系统的Flush行为</h4>
<p>在Linux中，写入文件系统的数据将保留在页面缓存中，直到必须将其写出到磁盘为止（由于应用程序级fsync或操作系统自身的刷新策略）。</p>
<p>数据刷新是通过一组称为pdflush的后台线程完成的（或在2.6.32版的内核“冲洗线程”中）。</p>
<p>Pdflush具有可配置的策略，该策略控制可以在缓存中维护多少脏数据以及必须将多脏数据写回到磁盘的时间.</p>
<p><a href="http://web.archive.org/web/20160518040713/http://www.westnet.com/~gsmith/content/linux-pdflush.htm">pdflush刷新策略</a></p>
<p>当Pdflush无法跟上写入数据的速度时，它将最终导致写入过程阻塞写入中的延迟，从而减慢数据的累积。</p>
<p>与进程内缓存相比，使用pagecache存储将写入磁盘的数据有几个优点：</p>
<ul>
<li>I/O调度将连续的小写批量写到更大的物理写中，从而提高吞吐量</li>
<li>I/O调度尝试重新排序写操作，以最小化磁盘头的移动，从而提高吞吐量</li>
<li>它会自动使用机器上所有的空闲内存</li>
</ul>
<h3 id="2节点配置">2.节点配置</h3>
<ul>
<li>1.避免使用太小的节点配置，因为这样整个集群的节点数可能会特别多，在这种机器上运行kafka将会有更多的开销</li>
<li>2.避免使用太高配计算机，因为它们经常导致资源使用不平衡，比如内存优先不够了，但cpu还剩余很多。如果在每个高配机器上运行多个broker节点，将会增加整体的复杂度</li>
</ul>
<h3 id="3jvm配置">3.JVM配置</h3>
<p>在当前大多数Java类应用下，基本都在使用JDK8(建议使用最新的jdk8)，在此环境下默认使用的是<code>G1</code>的垃圾回收器，因此一般情况下仅需要修改如下参数即可:</p>
<ul>
<li><code>MaxGCPauseMillis</code>: 指定每次垃圾回收默认的停顿时间，默认值200ms</li>
<li><code>InitiatingHeapOccupancyPercent</code>: G1 启动新一轮垃圾回收之前可以使用的堆内存百分比，默认值是45</li>
</ul>
<p>官方推荐的GC参数如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">-Xms6g -Xmx6g -XX:MetaspaceSize=96m -XX:+UseG1GC -XX:MaxGCPauseMillis=20
       -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M
       -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80
</code></pre></td></tr></table>
</div>
</div><p>作为参考，LinkedIn最繁忙的集群当前是如下情况:</p>
<ul>
<li>60 brokers</li>
<li>50k partitions (replication factor 2)</li>
<li>800k messages/sec in</li>
<li>300 MBps inbound, 1 GBps + outbound</li>
</ul>
<p>上面的GC调优看起来比较激进，但集群中的所有broker都会有90%的gc中止时间，大概21ms，它们做不到每秒一个young GC</p>
<p>作为同样是图片社交的<code>Pinterest</code>来讲，他们采用如下的JVM参数:</p>
<p><a href="https://medium.com/pinterest-engineering/how-pinterest-runs-kafka-at-scale-ff9c6f735be">Pinterest的大规模kafka实践</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 61G的内存
-Xms8g -Xmx8g -XX:NewSize=512m -XX:MaxNewSize=512m -XX:MetaspaceSize=128m -XX:+UseG1GC -XX:MaxGCPauseMillis=25
       -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M -XX:MinMetaspaceFreeRatio=25 
       -XX:MaxMetaspaceFreeRatio=75
       -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:PrintTenuringDistribution 
       -Xloggc:/var/log/kafka/gc.log -XX:UseGCLogFileRotation -XX:NumberOfGCLogFiles=40
       -XX:GCLogFileSize=50M

</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">-Xmx10G -Xms10G -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -XX:MaxInlineLevel=15 -Djava.awt.headless=true -Xloggc:/opt/app/kafka/bin/../logs/kafkaServer-gc.log -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.port=9999

</code></pre></td></tr></table>
</div>
</div><h3 id="4kafka核心配置">4.kafka核心配置</h3>
<p>Kafka默认设置在大多数情况下都能工作，特别是与性能相关的设置和选项，但是考虑到集群的规划以及场景用途，有一些补充的配置参数可以对生产环境进行调优。</p>
<p>通常配置上来讲会分为<code>broker端配置</code>、<code>produser端配置</code>、<code>consumer端配置</code>，由于各个业务方当前均使用开源客户端，因此对于客户端的配置无法做到严格管控(如果有内部的sdk封装可能会比较好)。</p>
<h4 id="41-重要的客户端配置">4.1 重要的客户端配置</h4>
<ul>
<li><code>acks</code>: 消息一致性保证(0:投递即成功,1:副本同步即成功,all/-1:全部ISR同步即成功)</li>
<li><code>compression</code>: 压缩类型</li>
<li><code>batch size</code>: 批处理大小</li>
</ul>
<p><code>注意:</code> 对于消费者来说，最重要的参数为<code>fetch size</code></p>
<p>鉴于集群的整体可用性可靠性其实很大一部分和客户端的使用方式有关，后面会列举一些常见的生产者和消费者端的核心参数</p>
<p><a href="http://kafka.apache.org/24/documentation.html#configuration">kafka详细参数列表</a></p>
<h4 id="42-broker核心配置">4.2 broker核心配置</h4>
<p><strong>zookeeper.connect</strong></p>
<p>zk连接串，建议写全部的zk节点地址。</p>
<p>brokers链接的zk集群地址，该值默认采用<code>host:ip/path</code>来指定一个zk中的znode节点，通常情况下用来隔离环境. kafka的zk路径中使
用了<code>chroot</code>环境，如果不指定使用默认的<code>/</code>来作为存储路径。</p>
<p><strong>broker.id</strong></p>
<p>broker唯一标识，该值可以任意设定(int类型)。默认<code>reserved.broker.max</code>开始，每次+1</p>
<p>在分布式集群中，可以手动指定每个broker的节点信息，同时也可以使用如下方式来自动生成每个broker的id</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#broker.id
broker.id.generation.enable=true
</code></pre></td></tr></table>
</div>
</div><p><strong>log.dirs</strong></p>
<p>kafka存储的日志消息都是保存在该参数指定的日志路径下，该值可以指定多个磁盘路径，通常我们会绑定到多个磁盘上。比如<code>log.dirs=/exoprt/kafka1,/export/kafka2,/export/kafka3</code></p>
<p>对应的另外一个默认参数为<code>log.dir</code>，默认值为<code>/tmp/kafka-logs</code></p>
<p><strong>listeners</strong></p>
<p>broker监听列表，默认将为<code>PLAINTEXT://myhost:9092</code></p>
<p><strong>advertised.listeners</strong></p>
<p>监听器发布到zk集群中的地址，供客户端使用，默认采用<code>listeners</code>参数值</p>
<p><strong>num.recovery.threads.per.data.dir</strong></p>
<p>每个数据目录用于在启动时进行日志恢复和在关闭时进行刷新的线程数，默认值为: <code>1</code></p>
<p>生产环境下，该值可以适当的调整大一些，用来增加正常关闭时数据flush的速度，以及启动时日志恢复的速度，可以提高broker节点的整体可用性。</p>
<p>对于如下几种情况，kafka会使用<code>可配置的线程池</code>来处理日志片段.</p>
<ul>
<li>服务器正常启动: 用于打开每个分区的日志片段</li>
<li>服务器崩溃后重启: 用于检查和截断每个分区的日志片段</li>
<li>服务器正常关闭: 用于关闭日志片段</li>
</ul>
<p>默认情况下，每个日志目录采用一个线程，因为这些线程仅有在启动和关闭时才用到，所以可以适当设置大一点，并不会影响到整体服务的性能，特别是对于包含大量分区的服务器来说，一旦发生崩愤，在进行恢复时使用井行操作可能会省下数小时的时间。</p>
<p>需要注意的是，该值是每个日志目录的线程数，因此总线程数需要考虑到<code>log.dirs</code>的配置</p>
<p><code>备注</code>: 这也是在使用RAID和JBOD两种磁盘方案的另外一个考虑点</p>
<p><strong>delete.topic.enable</strong></p>
<p>是否允许删除topic，默认为: <code>true</code></p>
<p>如果为false，通过管理工具删除topic仅为标记删除，此时使用<code>describe</code>命令可以查看到topic的详情信息，但是无法写入，可以通过删除<code>zk</code>中的节点来删除</p>
<p><code>备注</code>: 生产环境建议设置为<code>false</code>，由集群管理员定期统一的进行删除和管理</p>
<p><strong>auto.create.topics.enable</strong></p>
<p>默认情况下，kafka会使用如下三种方式创建topic:</p>
<ul>
<li>当一个生产者开始往主题写入消息时</li>
<li>当一个消费者开始从主题读取消息时</li>
<li>当任意一个客户端向主题发送元数据请求时</li>
</ul>
<p>推荐是设置成<code>false</code>，不允许客户端直接创建topic，否则topic会无法管理。默认值为<code>true</code></p>
<p><strong>auto.leader.rebalance.enable</strong></p>
<p>是否开启<code>leader</code>自动平衡，默认值为<code>true</code>。后台会有线程进行定期检查leader的分布情况</p>
<p>kafka中有一个被称为优先副本（preferred replicas）的概念(通常分区会有主分区和副本分区的概念，主分区先写入，然后push到其他副本分区)。</p>
<p>如果一个分区有3个副本，且这3个副本的优先级别分别为0,1,2，根据优先副本的概念，0会作为leader 。</p>
<p>当0节点的broker挂掉时，会启动1这个节点broker当做leader。</p>
<p>当0节点的broker再次启动后，会自动恢复为此partition的leader。不会导致负载不均衡和资源浪费，这就是leader的均衡机制(前提是第一次partition在分配的时候，它本身就是一个相对平均的分配)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">auto.leader.rebalance.enable=true
# 对应影响的其他两个参数
# leader.imbalance.per.broker.percentage : 每个broker允许leader不平衡比例(如果每个broker上超过了这个值，controller将会&gt;执行分区再平衡)，默认值10.
# leader.imbalance.check.interval.seconds: 主分区再平衡的频率，默认值为300s
</code></pre></td></tr></table>
</div>
</div><p>其实，在重要业务的场景中，需要将<code>leader.imbalance.per.broker.percentage</code>参数适当调整小一些，以避免broker中leader不平衡率导致节点的吞吐不均匀</p>
<p><strong>num.partitions</strong></p>
<p>自动创建topic的默认分区数，默认为1，通常生产集群不建议打开topic自动创建，一方面是不便于管理和追溯，另外一方面因为自动创建默认分区时1，且无法动态变更，造成的风险可能会比较大。</p>
<p>多分区的topic有这更好的数据平衡能力，并且可以帮助消费者进行并行化消费。</p>
<p><code>注意:</code> 对于有key的数据，避免改变分区的数量</p>
<p><strong>default.replication.factor</strong></p>
<p>适用于自动创建的主题的默认复制因子，推荐至少设置为2，默认为1</p>
<p><strong>min.insync.replicas</strong></p>
<p>当使用<code>required.acks=-1(all)</code>提交到生产请求所需的ISR中的最小副本数，默认为1，建议在数据一致性要求较高的topic中设置至少为2</p>
<p>指定<code>ISR</code>的最小数量。当producer设置<code>ack=all(-1)</code>时，该值指定的副本必须全部写成功，才认为消息写入成功，否则生产者将抛异常(<code>either NotEnoughReplicas or NotEnoughReplicasAfterAppend</code>)</p>
<p><code>注意</code>: <code>min.insync.replicas</code>参数和生产者<code>ack</code>参数一起使用，可以加强整个消息的持久性</p>
<p>示例:(3副本的topic,可以设置该值为2,同时生产者ack设置为all，这将确保大多数副本没有收到写操作时，生产者直接异常)</p>
<p>默认值为:<code>1</code></p>
<p><strong>unclean.leader.election.enable</strong></p>
<p>是否启用不在ISR集中的副本以选作领导者，即使这样做可能会导致数据丢失。该参数可以提高整体Topic的可用性，但是可能会造成数据的整体不一致性(部分数据的丢失)。</p>
<p><a href="http://kafka.apache.org/24/documentation.html#topicconfigs">kafka可用性和可靠性保证</a></p>
<p>默认值为:<code>false</code></p>
<p>为false，就只从ISR中获取leader保证了数据的可靠性，但是partition就失效了，<code>true</code>则从replica中获取，则可用性增强，但是数&gt;据可能存在丢失情况</p>
<p><code>注意:</code>  该参数实际上在设置的时候也有一定的争议性，比如，我们知道副本是有<code>ISR</code>的，即正在同步的副本，如果当前的broker宕&gt;机导致需要选举leader partition，此时如果ISR内除了leader之外还有其他副本(但谁又能保证一定有呢)，那直接从ISR中选举leader&gt;即可，如果没有的话，当<code>auto.leader.rebalance.enable=true</code>时，就会去其他存活的副本中选举leader，此时可以增强整体的可用性，但是如果存活的副本不在ISR中，即意味着数据可能有一定的丢失了。但是如果该参数为false的话，ISR中没有，就直接异常了，为了保证数据的一致性。</p>
<p>该参数的存在其实是在可用性和可靠性之间做了一个权衡，为true时保证了可用性AP，为false时保证了一致性CP</p>
<p><code>数据一致性保证</code>: ISR就保存了kafka认为可靠的副本，它们具备这样的条件：</p>
<ul>
<li>落后leader的消息条数在一定阈值内</li>
<li>或者落后在一定时间内；</li>
</ul>
<p><strong>num.replica.fetchers</strong></p>
<p>该参数指定了fetch线程的数量(从源broker中复制消息的fetch线程)，默认值: <code>1</code></p>
<p>其实可以适当的调整大一些，可以增强副本之前的同步效率，设置为2可以满足大多数的场景</p>
<p><strong>num.io.threads</strong></p>
<p>broker处理请求的 IO 线程数，需要考虑到磁盘的IO状况。默认值为:<code>8</code></p>
<p>该值通常情况下在生产环境也可以适当的调整大一些，但是通常情况下需要考虑到所使用的的磁盘的整体情况，可以尝试设置为<code>num.network.threads</code>的两倍，比如<code>d1ne.4xlarge</code>的规格其实可以设置为20</p>
<p><strong>num.network.threads</strong></p>
<p>指定broker用来接收来自网络的请求和发送网络的响应的线程数，默认值为: <code>3</code></p>
<p>在生产环境中，可以根据网络的情况以及cpu和内存的使用情况将该值默认调大一些，基本上可以为逻辑cpu核心的2/3都是可以的，比如我们生产环境采用<code>d1ne.4xlarge</code>规格的实例，可以设置该值为10</p>
<p><strong>background.threads</strong></p>
<p>后台任务处理线程数(例如过期消息删除等)。默认值为:<code>10</code></p>
<p><strong>socket相关</strong></p>
<ul>
<li>socket.send.buffer.bytes: (socket发送缓冲区:SO_SNDBUFF) 默认值:<code>102400</code></li>
<li>socket.receive.buffer.bytes: (socket接收缓冲区:SO_RCVBUFF) 默认值:<code>102400</code></li>
<li>socket.request.max.bytes: (请求最大值，message.max.bytes要小于该值较好) 默认值:<code>104857600</code></li>
</ul>
<p>在生产环境中如果涉及到多可用区，或多机房环境时，socket缓冲区的默认值也是有点小的，因此尝试可以尝试将该值设置为<code>1M</code>或者<code>2M</code>，即<code>socket.send.buffer.bytes=2097152/1048576</code>，生产环境推荐优化该参数</p>
<p><strong>message.max.bytes</strong></p>
<p>该值表示kafka允许的最大的batch大小(不是单个message的大小)，默认值为<code>1000012</code>，即1MB.</p>
<p>在最新的消息格式版本中，为了提高效率，一般消息的提交都是采用batch的方式。</p>
<p><code>注意:</code> 在以前的消息格式版本中，未压缩的记录不会分组成批，在这种情况下，此限制仅适用于单个记录。</p>
<p>在每个topic级别可以使用<code>max.message.bytes</code>设置</p>
<p>通常情况下，如果是一个集群承担多种业务场景，通常需要将该值设置为可以满足大多数场景的配置，比如<code>4194304</code>即<code>4MB</code>，</p>
<p><strong>log相关(具体到topic级别)</strong></p>
<ul>
<li>log.segment.bytes: 单个日志段(segment)的大小，默认为<code>1073741824</code>,即1GB</li>
<li>log.segment.delete.delay.ms: 日志段从文件系统中删除前等待的时间，默认为<code>60000</code>，即1min</li>
<li>log.cleanup.policy: 保留窗口之外的日志清理策略可同时指定多个策略如: [<code>delete</code>,compact]</li>
<li>log.cleaner.enable: 启用日志清除器进程，和<code>cleanup.policy = compact</code>参数结合使用，默认为<code>true</code></li>
<li>log.cleaner.threads: 日志清理的后台线程数量，默认为<code>1</code></li>
<li>log.cleaner.delete.retention.ms: 删除的日志保留的时间，默认为<code>86400000</code></li>
<li>log.retention.bytes: 删除日志前，日志最大的大小，超过该值即删除，默认<code>-1</code>，作用在每个partition，会影响整个topic的容量</li>
<li>log.retention.minutes(hours|ms): 日志保留时间，如果没指定，默认使用hours参数</li>
<li>log.retention.check.interval.ms: 日志清理器检查日志是否符合删除条件的频率，默认为<code>300000</code></li>
<li>log.flush.interval.messages: 将消息刷新到磁盘之前在日志分区上累积的消息数，默认为<code>9223372036854775807</code></li>
<li>log.flush.interval.ms: 主题中的消息在刷新到磁盘之前保存在内存中的最大时间，默认为<code>null</code>(log.flush.scheduler.interval.ms参数的值)</li>
<li>log.flush.scheduler.interval.ms: 日志刷新器检查是否需要将日志刷新到磁盘的频率，默认<code>9223372036854775807</code></li>
<li>log.flush.offset.checkpoint.interval.ms: 更新最后一次刷新的持久记录(被作为恢复点)的频率，默认为<code>60000</code></li>
<li>log.flush.start.offset.checkpoint.interval.ms: 更新日志起始偏移量的持久记录的频率，默认<code>60000</code></li>
<li>log.roll.hours: 新日志段(segment)被创建前的最大时间，默认<code>168</code>，如果没设置优先使用<code>log.roll.ms</code></li>
</ul>
<p><strong>offsets相关</strong></p>
<ul>
<li>offsets.commit.required.acks: offset提交之前是否需要ack确认,默认值:<code>-1</code></li>
<li>offsets.commit.timeout.ms: 当偏移量注意<code>_offset</code>的所有副本接收到提交或超时达到该时间时，offset提交将延迟. 默认值:<code>5000</code></li>
<li>offsets.load.buffer.size: 偏移量加载到缓存中时从偏移量段读取的批处理大小. 默认值:<code>5242880</code></li>
<li>offsets.retention.check.interval.ms: 历史offset检查的频率，默认值:<code>600000</code></li>
<li>offsets.retention.minutes: 在消费者组的消费者全部异常之后，offset保留的时间，默认值:<code>10080</code></li>
<li>offsets.topic.compression.codec: 偏移量主题的压缩解码器，默认:<code>0</code></li>
<li>offsets.topic.num.partitions: offset提交主题的分区数量，默认:<code>50</code>(<code>注意:</code>集群部署后不要改变)</li>
<li><code>offsets.topic.replication.factor</code>: offset提交主题的副本数，默认:<code>3</code> (在集群大小满足此复制因子要求之前，内部主题创建将&gt;失败,该主题非常重要，需要要求强一致性)</li>
<li>offsets.topic.segment.bytes: offset提交主题的段大小，设置相对较小，以便更快地实现日志压缩和缓存负载，默认值:<code>104857600</code>，即1Mb</li>
</ul>
<p><strong>queue相关</strong></p>
<ul>
<li>queued.max.requests: 在网络阻塞线程前，数据平面允许的排队请求数，默认值:<code>500</code></li>
</ul>
<p><strong>replica相关</strong></p>
<ul>
<li>replica.fetch.min.bytes:每个fetch响应所需的最小字节数，默认值:<code>1</code></li>
<li>replica.fetch.wait.max.ms: 由follow副本发起的每个fetch请求的最大等待时间，该值应小于<code>replica.lag.time.max.ms</code>，以避免
为低吞吐量的主题频繁地收缩ISR，默认值:<code>500</code></li>
<li>replica.lag.time.max.ms: follow副本在该时间内没有和leader副本同步，或没有发送任何同步请求，将会被leader副本从ISR中删&gt;除. 默认值:<code>10000</code>，即10s</li>
<li>replica.socket.receive.buffer.bytes: 副本接收请求的网络缓冲区，默认值:<code>65535</code></li>
<li>replica.socket.timeout.ms: 网络请求的超时时间，默认值:<code>30000</code></li>
<li>replica.fetch.backoff.ms: 发生获取分区错误时要休眠的时间，参数不是很重要，默认值:<code>1000</code></li>
<li>replica.fetch.max.bytes: 尝试为每个分区获取的消息字节数，参数不是很重要，默认值:<code>1048576</code>,即1M</li>
</ul>
<p><strong>broker.rack</strong></p>
<p>broker所在的机架，用来感知机架的变化，通常多个分区不会放在同一个机架上</p>
<p>示例: <code>RACK1</code>, <code>us-east-1d</code></p>
<p><strong>controller控制器相关</strong></p>
<ul>
<li><code>controlled.shutdown.enable</code>: 启用控制器关闭，默认:<code>true</code></li>
<li>controlled.shutdown.max.retries: 控制器会因为各种原因而宕机，该值表示控制器的重试次数，默认:<code>3</code></li>
<li>controlled.shutdown.retry.backoff.ms: 在每次重试之前，系统从前一次故障(控制器fail over或副本延迟)的状态中恢复过来的时
间，默认:<code>5000</code></li>
<li><code>controller.socket.timeout.ms</code>: 控制器到broker角色转换的socket超时时间，默认:<code>30000</code></li>
</ul>
<p><strong>group相关(消费组)</strong></p>
<ul>
<li>group.max.size: 消费组中最大消费者数量</li>
<li>group.initial.rebalance.delay.ms:注册消费者允许的最小会话超时，默认:<code>6000</code></li>
</ul>
<p><code>注意:</code> 很多参数是有不同级别的生效范围的，比如:</p>
<ul>
<li><code>read-only</code>: 仅在broker重启后才能生效</li>
<li><code>per-broker</code>: 可以为每个broker动态更新</li>
<li><code>cluster-wide</code>: 可作为集群范围内的值动态更新，也可以在每个broker上更新进行测试</li>
</ul>
<p><a href="http://kafka.apache.org/24/documentation.html#brokerconfigs">broker配置作用范围</a></p>
<p><strong>示例配置</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># ZooKeeper地址
zookeeper.connect=[list of ZooKeeper servers]

# kafka log相关配置
num.partitions=8
default.replication.factor=3
log.dirs=[List of directories. Kafka should have its own dedicated disk(s) or SSD(s).]

# 其他配置核心配置
broker.id=[An integer. Start with 0 and increment by 1 for each new broker.]
listeners=[list of listeners]
auto.create.topics.enable=false
# 最小的isr数量，可以在topic级别设置
min.insync.replicas=2
queued.max.requests=[number of concurrent requests]

</code></pre></td></tr></table>
</div>
</div><p><code>注意:</code> 在kafka集群中，当broker集群参数确定后，还有一些针对topic的参数是可以进行动态调整的，以提高kafka服务的灵活性。</p>
<h4 id="43-topic级别的动态参数调整">4.3 Topic级别的动态参数调整</h4>
<p><a href="http://kafka.apache.org/24/documentation.html#topicconfigs">Topic级别的配置</a></p>
<p><code>注意</code>: 如下topic的参数可以在使用过程中进行动态调整，使用<code>kafka-topic.sh</code>工具中的<code>alter</code>参数来直接修改topic相关的参数。</p>
<p><strong>cleanup.policy</strong></p>
<p>一个字符串是“删除”或“压缩”或两者兼而有之. 默认值: <code>[compact, delete]</code></p>
<p><strong>compression.type</strong></p>
<p>日志压缩类型，默认值为<code>producer</code></p>
<p><strong>delete.retention.ms</strong></p>
<p>用于日志压缩主题的删除保留时间。默认值:<code>86400000</code></p>
<p><strong>max.message.bytes</strong></p>
<p>指定每个topic可发送的最大消息(batch size)字节数.(区别于全局的<code>message.max.bytes</code>参数)</p>
<p><strong>num.partitions</strong></p>
<p>指定创建topic的默认分区数量，该值默认为1，建议根据具体的情况进行设定，越多的分区对于海量数据来说可以提高吞吐，但是对于少量数据来说，也可能增加网络消耗.</p>
<p>一般情况下，我们会对默认的topic的分区进行过度分配，以防止后期带key的message扩容分区导致的问题，一般建议初始值设置为5-10</p>
<p><code>注意:</code>分区数一旦指定，只能增加，不能减少</p>
<p><strong>default.replication.factor</strong></p>
<p>指定kafka副本数，默认每个主题分区均有一个副本，当该副本所在主机异常，可能造成数据的丢失，建议在适当场景将副本至少设置成
2个，以尽快保证数据的一致性。默认值:<code>1</code></p>
<p><code>注意:</code>自动创建主题的副本因子</p>
<p><strong>retention.ms</strong></p>
<p>kafka的log保留时间，也可以使用<code>log.retention.hours</code>参数来配置保留时间，默认168小时，即一周。</p>
<p><strong>retention.bytes</strong></p>
<p>指定log保留的大小，作用在每一个partition上，加入一个topic有3个partition，设置了<code>log.retention.bytes</code>为1GB，则表示整个topic仅可以存储3GB的数据，超过该容量的数据会被进行自动删除。</p>
<p>此时，临时增加该topic的容量的方法就是调整该参数，或调整topic的partition个数。</p>
<p>-1表示不限制</p>
<p><strong>segment.bytes</strong></p>
<p>指定每个日志段的大小，通常在消息到达broker时，会被追加到分区的当前日志段上(segment)，当日志段大小超过该参数指定的值(默认1GB)，当前日志段就会被关闭，一个新的日志段被打开。</p>
<p>如果一个日志片段被关闭，就开始等待过期，该值不建议设置太小。</p>
<p><strong>segment.ms</strong></p>
<p>上面会指定日志段的分割，该参数会指定历史的日志段的过期时间。该参数会和<code>log.retention.bytes</code>一起校验，谁先满足就生效。</p>
<p><strong>message.max.bytes</strong></p>
<p>该值用来限制单个消息的大小，默认值为<code>1000 000</code>即<code>1MB</code>，如果超过该大小，broker不会接受，而且会抛出相关异常</p>
<p><code>注意:</code>该参数指的是消息被压缩后的大小，通常生产中的消息生产会使用gzip或snappy来进行压缩</p>
<p><code>注意:</code>消息的大小对于性能有比较显著的影响，越大负责处理网络连接和请求的线程就需要花越多的时间来处理这些请求，还会增加磁
盘写入块的大小，从而影响 IO 吞吐量。</p>
<p><strong>file.delete.delay.ms</strong></p>
<p>在从文件系统中删除一个文件前的等待时间</p>
<p><strong>flush.messages</strong></p>
<p>该参数允许我们指定一个间隔来强制同步数据到本地磁盘，比如设置为1，表示每条消息后都会执行同步磁盘，如果设置为5表示，每5个消息同步一次。</p>
<p>一般情况下，管法定不建议修改该参数，可以使用副本机制来保证持久性和开启操作系统的后台flush功能，会更加有效率。</p>
<p><strong>flush.ms</strong></p>
<p>同上，但是指定的是时间间隔。比如设置1000，表示1000ms后执行一次同步操作.</p>
<p><strong>follower.replication.throttled.replicas</strong></p>
<p>对日志复制的副本列表应该被在follow侧进行限流。</p>
<p>副本列表应该为<code>[PartitionId]:[BrokerId],[PartitionId]:[BrokerId]</code>格式，或者使用通配符<code>*</code>来表示给topic的所有副本进行限流。</p>
<p><strong>leader.replication.throttled.replicas</strong></p>
<p>同上，在leader侧进行限流</p>
<p><strong>index.interval.bytes</strong></p>
<p>该参数用来控制多久kafka会增加一个index实体数据到它的offset的index上。默认设置确保我们大约每4096字节索引一条消息。索引越多，读取越接近日志中的确切位置，但索引越大。通常不需要修改该参数。</p>
<p><strong>max.message.bytes</strong></p>
<p>被kafka允许的最大记录的batch size。</p>
<p>如果增加了该值，并且有消费者版本老于<code>0.10.2</code>，消费者的<code>fetch size</code>也必须增加，这样就能获取到该批次大小的数据。</p>
<p>在高版本的消息格式(message format)中，为了效率，记录总是会被分组成batch；而在之前的消息格式版本中，未被压缩的消息不会被分组成batch，在这种情况下，该参数仅在单条记录上生效。</p>
<p><strong>message.downconversion.enable</strong></p>
<p>此配置用于控制是否启用消息格式的向下兼容以满足消费者请求。</p>
<p>当设置成<code>false</code>，对于希望使用较旧消息格式的消费者来说，broker将不会执行向下转换。来自旧客户端的消费者请求，broker将会返回<code>UNSUPPORTED_VERSION</code>错误码。</p>
<p>此配置不适用于可能需要复制到follower的消息格式转换。</p>
<p><strong>message.format.version</strong></p>
<p>指定消息格式版本，broker将使用<code>append</code>方式追加message到log里。该值必须是一个可用的ApiVersion，比如<code>0.8.2, 0.9.0.0, 0.10.0</code>。</p>
<p>通过设置特定的消息格式版本，用户可以验证已存在磁盘上的消息是否小于或者等于指定的版本。</p>
<p>错误地设置此值将导致使用较旧版本的使用者中断，因为他们将收到他们不理解的格式的消息。</p>
<p><strong>message.timestamp.difference.max.ms</strong></p>
<p>broker接收到消息的时间戳和在消息体内部的时间戳的最大时间差距。如果<code>message.timestamp.type=CreateTime</code>，当时间戳的差值大于该值，一个message将被拒绝。如果<code>message.timestamp.type=LogAppendTime</code>，该参数将被忽略。</p>
<p><strong>message.timestamp.type</strong></p>
<p>指定message中时间戳的类型。<code>CreateTime</code>或<code>LogAppendTime</code></p>
<p><strong>min.cleanable.dirty.ratio</strong></p>
<p>该参数用于控制，日志压缩器(log compactor)将尝试清除日志的频率。默认情况下，我们将避免清除已压缩超过50％的日志的日志。这个比率限制了最大空间浪费(日志中的重复,50%或50%以上的日志重复)。</p>
<p>比率越高，意味着越少，更有效的清理，但是也意味着更多的日志空间浪费。</p>
<p><strong>min.compaction.lag.ms</strong></p>
<p>一条消息保持未压缩的最小时间。仅适用于正在压缩的日志。</p>
<hr>
<h4 id="43-producer核心参数">4.3 Producer核心参数</h4>
<p><strong>bootstrap.servers</strong></p>
<p>指定broker地址</p>
<p><strong>key.serializer</strong></p>
<p>broker 需要接收到序列化之后的<code>k/v</code>值，所以生产者需要将序列化后的值发送过来。</p>
<p><code>org.apache.kafka.common.serialization.Serializer</code>该类表示把键对象序列化为字节数组</p>
<ul>
<li>ByteArraySerializer: 默认的序列化方式</li>
<li>StringSerializer:</li>
<li>IntegerSerializer:</li>
</ul>
<p><strong>value.serializer</strong></p>
<p>指定序列化后的value，需要实现<code>org.apache.kafka.common.serialization.Serializer</code>接口</p>
<p><code>org.apache.kafka.common.serialization.StringSerializer</code></p>
<p><strong>compression.type</strong>
指定消息压缩类型:gzip,snappy等，</p>
<p>broker端也有该参数，默认值为:<code>producer</code>，表示遵循生产者的压缩方式</p>
<p><code>注意:</code>生产者使用何种压缩方式，消费者将必须使用该方式进行解压缩</p>
<p><strong>acks</strong></p>
<p>该参数用来声明要有多少个分区副本接收消息后，生产者才认为消息写入成功，也就是数据一致性衡量，该参数对消息的丢失的影响较&gt;大. 默认值为:<code>1</code></p>
<ul>
<li><code>acks=0</code>: 表示生产者不知道消息是否被broker成功接收被处理，反正自己发出去了就认为是成功了，该种清理增加了吞吐，但是也&gt;增加的数据丢失的风险，因为程序的稳定性，网络的稳定性都可能会影响到消息的生产</li>
<li><code>acks=1</code>: 只要集群中leader接收到消息并成功处理，就返回给生产者写入成功的消息。该种情况，如果发送过程中网络出现问题或&gt;者kafka集群异常导致leader没工作而导致消息写入失败，生产者会受到写入失败相关的异常，此时生产者可进行重试</li>
<li><code>acks=all/-1</code>: 表示所有参与复制的节点都收到消息时，生产者才会接收到来自服务器端写入成功的消息，该种情况下，整体的消息
确认延迟会更高一些，但是数据的一致性也更强一些</li>
</ul>
<p><code>注意:</code> 消息的发送其实也分<code>sync</code>和<code>async</code>，即同步和异步，kafka为了保证消息高效传输会决定是同步发送还是异步发送。如果让&gt;客户端等待服务器的响应(通过调用get()方法)也会增加延迟，如果采用客户端回调方式，延迟问题可能会有好转。</p>
<p><strong>buffer.memory</strong></p>
<p>该参数用来设置生产者内存缓冲区的大小，生产者会用它来缓冲要发送到服务器的消息，以此来提供消息传递的效率。默认值:<code>33554432</code></p>
<p><code>注意:</code>如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，此时<code>send()</code>方法就会阻塞或者直接异常，取
决于<code>block.on.buffer.null</code>参数</p>
<p><strong>retries</strong></p>
<p>生产者从服务器收到的错误有可能是临时性的错误，比如暂时找不到<code>leader</code>或者当前partition正在迁移无法找到相关的partition，&gt;这种情况下，该参数可以决定生产者的行为，如果重试次数超过之后，生产者就会放弃重试，并返回错误。</p>
<p>默认情况下，生产者在每次重试之间等待100ms，这个等待参数可以通过<code>retry.backoff.ms</code>来修改</p>
<p><strong>batch.size</strong></p>
<p>指定每次提交的batch大小，默认值:<code>16384</code></p>
<p>当有多个消息需要被发送<code>同一个分区</code>(如何决定是发送到同一个分区?)时，生产者会把他们发送到同一个批次里.</p>
<p>该参数用来指定一个批次提交的大小，当达到该batch的大小，所有的消息会被统一发送至broker</p>
<p><strong>client.id</strong></p>
<p>该参数用来指定客户端的id，不过可以不用指定，注册后为每个客户端生成64为的id</p>
<p><strong>max.in.flight.requests.per.connection</strong></p>
<p>此参数指定了生产者在收到服务器响应之前可以发送多少消息，它的值越高，就会占用越多的内存，不过也会提高吞吐量</p>
<p>把它设为1 可以保证消息是<code>按照发送的顺序</code>写入服务器。</p>
<p><strong>timeout相关参数</strong></p>
<ul>
<li><code>request.timeout.ms</code>: 生产者在发送数据时等待服务器返回的响应时间，默认值:<code>30000</code></li>
<li><code>metadata.fetch.timeout.ms</code>: 指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间</li>
<li><code>timeout.ms</code>: 指定了 broker 等待同步副本返回消息确认的时间，与 asks 的配置相匹配</li>
</ul>
<p><strong>max.block.ms</strong></p>
<p>此参数指定了在调用 send() 方法或使用 partitionFor() 方法获取元数据时生产者的阻塞时间.</p>
<p>当生产者的发送缓冲区已捕，或者没有可用的元数据时，这些方法就会阻塞，阻塞时间超过该参数值时，生产者抛出异常</p>
<p><strong>max.request.size</strong></p>
<p>该参数用于控制生产者发送的<code>请求大小</code>.</p>
<p>它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息的总大小</p>
<p><strong>receive.buffer.bytes和send.buffer.bytes</strong></p>
<p>为了保证可靠的消息传输，这两个参数分别指定了 TCP Socket <code>接收和发送数据包的缓冲区</code>的大小，默认为-1，表示使用操作系统的&gt;默认值。</p>
<p><code>注意:</code> 如果生产者或消费者与broker所处的数据中心不同，该值可以适当调大</p>
<h4 id="44-consumer核心参数">4.4 Consumer核心参数</h4>
<p>在消费者组中的消费者重平衡期间，消费者无法读取消息，造成整个消费者组在重平衡的期间都不可用</p>
<p>消费者通过向组织协调者（Kafka Broker）发送心跳来维护自己是消费者组的一员并确认其拥有的分区。</p>
<p>对于不同步的消费群体来说，其组织协调者可以是不同的。</p>
<p>只要消费者定期发送心跳，就会认为消费者是存活的并处理其分区中的消息。当消费者检索记录或者提交它所消费的记录时就会发送心&gt;跳。</p>
<p>如果一段时间，消费者不发送心跳了，会话（Session）就会过期，组织协调者就会认为这个 Consumer 已经死亡，就会触发一次重平衡
。</p>
<p>如果消费者宕机并且停止发送消息，组织协调者会等待几秒钟，确认它死亡了才会触发重平衡.</p>
<p><code>注意:</code> 在这段时间里，组里的消费者将不处理消息(STW)</p>
<p><code>_consumer_offset</code>主题就主要是用来记录相关消费者的偏移量以及消费者分区分配的</p>
<p><strong>fetch.min.bytes</strong></p>
<p>指定了消费者从服务器获取记录的最小字节数，默认:<code>1</code></p>
<p>broker 在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes 指定的大小，那么它会等到有足够的可用数据时才把它&gt;返回给消费者。</p>
<p>这样可以降低消费者和 broker 的工作负载，因为它们在主题使用频率不是很高的时候就不用来回处理消息。</p>
<p>如果没有很多可用数据，但消费者的 CPU 使用率很高，那么就需要把该属性的值设得比默认值大。</p>
<p>如果消费者的数量比较多，把该属性的值调大可以降低 broker 的工作负载。</p>
<p><strong>fetch.max.wait.ms</strong></p>
<p>上面参数用来控制每次fetch时的最小数据量，但也不能一直等待数据的容量满足要求，因此还有另外一个参数，即<code>fetch.max.wait.ms</code>，指定多长时间还没满足数据容量就进行fetch数据，默认是<code>500ms</code></p>
<p><strong>max.partition.fetch.bytes</strong></p>
<p>指定了服务器从每个分区里返回给消费者的<code>最大字节数</code>，默认值为<code>1MB</code>.</p>
<p>即<code>KafkaConsumer.poll()</code>方法从每个分区返回的记录最多不超过该值指定的大小。</p>
<p>加入一个20分区的主题，拥有5个消费者，那么每个消费者必须至少<code>4MB</code>的内存来接收消息(每个消费者消费4个分区，每个分区返回消&gt;费者的最大字节数1MB)。</p>
<p><code>注意:</code> 该参数的设置要适当的设置大一些，防止单个消费者异常后，整体内存受限。</p>
<p>至少，该参数的值要大于<code>max.message.size</code>(broker接收消息的最大字节数)，否则消费者无法读取这些消息，导致消费者一直重试并&gt;挂起。</p>
<p><strong>session.timeout.ms</strong></p>
<p>指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s，在这个时间内没有发送心跳就会直接认为消费者死亡，此时
协调器就会进行触发consumer rebalance.</p>
<p>此参数与<code>heartbeat.interval.ms</code>(poll() 方法向群组协调器发送心跳的频率)强相关。</p>
<p><strong>auto.offset.reset</strong></p>
<p>指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下的该如何处理，默认值为<code>latest</code>，意思是在偏移量无效的情况下&gt;，默认从最新的记录下开始读取数据。可选值为<code>earliest</code>，表示从最开始位置进行读取.</p>
<p><strong>enable.auto.commit</strong></p>
<p>指定了消费者是否自动提交偏移量，默认值是 true，对应<code>auto.commit.interval.ms</code>参数来保证每次提交偏移量的频率</p>
<p>为了避免数据重复和丢失，消费者可以设置为false，由自己决定自己的消费位置(客户端保证数据消费的一致性)</p>
<p><strong>partition.assignment.strategy</strong></p>
<p><code>PartitionAssignor</code>(分区分配器)会根据给定的消费者和主题，决定哪些分区应该被分配到哪个消费者，默认有两个策略:<code>Range</code>和<code>RoundRobin</code></p>
<p><strong>max.poll.records</strong></p>
<p>用于控制<code>单次调用call()</code> 方法能够返回的记录数量，可以帮你控制在轮询中需要处理的数据量.</p>
<p><strong>heartbeat.interval.ms</strong></p>
<p>在消费组中，消费者心跳到消费者协调器的频率，默认值:<code>3000ms</code></p>
<h2 id="三集群管理">三、集群管理</h2>
<p>任何一款优秀的开源软件，都会提供比较丰富的集群管理工具来帮助使用者(管理员和实际使用者)来对集群进行操作，记下来从三个角度来大概讲解集群管理相关的操作。</p>
<ul>
<li>官方提供的操作脚本</li>
<li>kafka-manager</li>
<li>kafkacat</li>
</ul>
<h3 id="1-官方工具">1. 官方工具</h3>
<p>在kafka的发行包中，默认包含了如下管理工具脚本:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ ls
connect-distributed.sh        kafka-delete-records.sh              kafka-server-stop.sh
connect-mirror-maker.sh       kafka-dump-log.sh                    kafka-streams-application-reset.sh
connect-standalone.sh         kafka-leader-election.sh             kafka-topics.sh
kafka-acls.sh                 kafka-log-dirs.sh                    kafka-verifiable-consumer.sh
kafka-broker-api-versions.sh  kafka-mirror-maker.sh                kafka-verifiable-producer.sh
kafka-configs.sh              kafka-preferred-replica-election.sh  trogdor.sh
kafka-console-consumer.sh     kafka-producer-perf-test.sh          windows
kafka-console-producer.sh     kafka-reassign-partitions.sh         zookeeper-security-migration.sh
kafka-consumer-groups.sh      kafka-replica-verification.sh        zookeeper-server-start.sh
kafka-consumer-perf-test.sh   kafka-run-class.sh                   zookeeper-server-stop.sh
kafka-delegation-tokens.sh    kafka-server-start.sh                zookeeper-shell.sh

</code></pre></td></tr></table>
</div>
</div><p>这里主要介绍几个常用的工具脚本:</p>
<p><strong>运维管理类</strong></p>
<ul>
<li><code>kafka-topics.sh</code>: 用来创建，删除，查看，改变一个topic参数的工具</li>
<li><code>kafka-reassign-partitions.sh</code>: 用来对partition进行重新分配(管理员会较多使用)</li>
<li><code>kafka-log-dirs.sh</code>: 用来查看指定broker下日志目录的使用空间</li>
<li><code>kafka-leader-election.sh</code>: 用于一组Topic分区的leader重新分配，可以支持优先副本和非同步副本(不在ISR中)，老版本中的kafka-preferred-replica-election.sh脚本</li>
<li><code>kafka-replica-verification.sh</code>: 该工具可以用来检查topic的一组副本的数据是否一致</li>
<li><code>kafka-broker-api-versions.sh</code>: 用来查看指定broker当前支持的各个接口的版本(kafka高版本已经保证了向下兼容)</li>
<li><code>kafka-configs.sh</code>: 用来操作和查看topic, client, user or broker的实体配置</li>
</ul>
<p><strong>kafka操作类</strong></p>
<ul>
<li><code>kafka-console-consumer.sh</code>: 通过终端来启动消费者</li>
<li><code>kafka-console-producer.sh</code>: 通过终端来启动生产者</li>
<li><code>kafka-consumer-groups.sh</code>: 用来查看，删除或者重置消费者组offset</li>
<li><code>kafka-consumer-perf-test.sh</code>: 用来进行消费者压力测试</li>
<li><code>kafka-producer-perf-test.sh</code>: 用来进行生产者压力测试</li>
<li><code>kafka-delete-records.sh</code>: 删除指定分区的记录，直到指定的offset</li>
<li><code>kafka-mirror-maker.sh</code>: 用于多集群之间同步topic数据</li>
<li><code>kafka-server-start.sh</code>: broker启动脚本</li>
<li><code>kafka-server-stop.sh</code>: broker关闭脚本</li>
<li><code>kafka-streams-application-reset.sh</code>: 流式应用工具</li>
<li><code>zookeeper-shell.sh</code>: kafka工具中也默认提供了zookeeper管理工具(不太好用)</li>
</ul>
<h4 id="11-kafka-topicssh">1.1 kafka-topics.sh</h4>
<p><strong>topic创建</strong></p>
<ul>
<li><code>--create</code>: 创建topic</li>
<li>
<ul>
<li><code>--topic</code>: 指定topic名称</li>
</ul>
</li>
<li>
<ul>
<li><code>--partitions</code>: 指定分区数量</li>
</ul>
</li>
<li>
<ul>
<li><code>--replication-factor</code>: 指定副本数量(仅在创建时可用)</li>
</ul>
</li>
<li>
<ul>
<li><code>--config</code>: 指定topic级别的参数(动态参数，可修改)</li>
</ul>
</li>
<li>
<ul>
<li><code>--replica-assignment</code>: 手动指定partition到broker的分配&lt;part1_replica1:part1_replica2,part2_replica1:part2_replica2&gt;</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 创建topic
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --create --topic bgbiao.top
Created topic bgbiao.top.

# 查看默认创建topic的参数详情(由broker配置决定)
# 默认3个分区，1个副本
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 1	Leader: 2	Replicas: 2	Isr: 2
	Topic: bgbiao.top	Partition: 2	Leader: 3	Replicas: 3	Isr: 3

# 指定参数创建topic
# 指定分区为5，副本为3，topic数据保留2分钟
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --create --topic bgbiao.top-1 --partitions 5 --replication-factor 3 --config retention.ms=120000

# 分区，副本和指定参数都改变了
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top-1
Topic: bgbiao.top-1	PartitionCount: 5	ReplicationFactor: 3	Configs: min.insync.replicas=1,segment.bytes=1073741824,retention.ms=120000
	Topic: bgbiao.top-1	Partition: 0	Leader: 2	Replicas: 2,3,1	Isr: 2,3,1
	Topic: bgbiao.top-1	Partition: 1	Leader: 3	Replicas: 3,1,2	Isr: 3,1,2
	Topic: bgbiao.top-1	Partition: 2	Leader: 1	Replicas: 1,2,3	Isr: 1,2,3
	Topic: bgbiao.top-1	Partition: 3	Leader: 2	Replicas: 2,1,3	Isr: 2,1,3
	Topic: bgbiao.top-1	Partition: 4	Leader: 3	Replicas: 3,2,1	Isr: 3,2,1

</code></pre></td></tr></table>
</div>
</div><p><strong>topic更改</strong></p>
<p><code>注意:</code> topic的分区(partitions)可以根据需要进行调整(只能调整大，不能调整小)，而且在调整分区的过程中，对于一个有<code>key</code>的主题来说，一条消息的分区逻辑和顺序性可能会受到影响。</p>
<p><code>注意:</code> 副本数一旦topic创建之后，就不能再修改了，除非进行重分配(副本数不能超过broker数量哦)</p>
<ul>
<li><code>--alter</code>: 修改分区数量，replica分配，或者topic的动态配置项(结合&ndash;topic参数)</li>
<li>
<ul>
<li><code>--partitions</code>: 修改指定Topic的分区数量</li>
</ul>
</li>
<li>
<ul>
<li><code>--replica-assignment</code>: 手动指定part到broker的分配<a href="p1-r1:p1-r2,p2-r1:p2-r2">p1-r1:p1-r2,p2-r1:p2-r2</a></li>
</ul>
</li>
<li>
<ul>
<li><code>--config</code>: 修改topic的指定参数(动态参数调整:key=value)</li>
</ul>
</li>
<li>
<ul>
<li><code>--delete-config</code>: 删除topipc的指定参数()</li>
</ul>
</li>
</ul>
<p><code>注意:</code> 通常情况下<code>--replica-assignment</code>参数需要和<code>--partitions</code>一同使用才可以指定分区下的副本到broker节点上的分配，相当于手动扩容迁移</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 上面我们刚开始创建的bgbiao.top的topic是1个分区1个副本，这里采用alter参数进行修改基本配置
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --alter  --topic bgbiao.top --replica-assignment 1,2,3,1,2 --partitions 5

# 因为bgbiao.top 这个topic再创建时只有一个replication，因此--replica-assignment参数只能指定副本分配在那个broker上，无法指定多个副本的关系
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 5	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 1	Leader: 2	Replicas: 2	Isr: 2
	Topic: bgbiao.top	Partition: 2	Leader: 3	Replicas: 3	Isr: 3
	Topic: bgbiao.top	Partition: 3	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 4	Leader: 2	Replicas: 2	Isr: 2

 
</code></pre></td></tr></table>
</div>
</div><p><strong>topic相关信息查看</strong></p>
<ul>
<li><code>--list</code>: 列出topic</li>
<li><code>--describe</code>: 查看topic详情信息</li>
<li>
<ul>
<li><code>--topic</code>: 指定topic查看详情信息</li>
</ul>
</li>
<li>
<ul>
<li><code>--exclude-internal</code>: 排除内部topic(consumer_offset_topic)</li>
</ul>
</li>
<li>
<ul>
<li><code>--unavailable-partitions</code>: 仅显示leader不可用的分区(在集群异常时快速排查受影响的分区)</li>
</ul>
</li>
<li>
<ul>
<li><code>--under-min-isr-partitions</code>: 仅显示isr小于配置的min-isr-partitions的分区</li>
</ul>
</li>
<li>
<ul>
<li><code>--under-replicated-partitions</code>: 仅显示不同步的分区</li>
</ul>
</li>
</ul>
<p><code>注意:</code> 在低版本的kafka中使用&ndash;zookeeper来链接集群，高版本中基本都通过&ndash;bootstrap-server指定broker来连接集群</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 列出集群topic
# --list参数列出可用的topic
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --list
__consumer_offsets
....
....

# 也可以使用--topic指定topic
# 如果指定topic不存在，将返回空
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --list --topic __consumer_offsets
__consumer_offsets

# 列出topic详情信息
# --describe参数(同时可以使用--topic指定topic查看)
# --exclude-internal参数可以排除内部的topic(__consumer_offsets)
# --unavailable-partitions参数可以列出leader不可用的topic，在集群故障时快速查看受影响的topic
# 
# 可以查看某个topic的分区和副本分布，以及topic级别的相关配置
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic __consumer_offsets
Topic: __consumer_offsets	PartitionCount: 50	ReplicationFactor: 1	Configs: compression.type=producer,min.insync.replicas=1,cleanup.policy=compact,segment.bytes=104857600
	Topic: __consumer_offsets	Partition: 0	Leader: 3	Replicas: 3	Isr: 3
	Topic: __consumer_offsets	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
....
....

# 查看集群leader不可用的分区
# 可以发现leader都为-1，是因为副本和isr的id是4，而broker4其实已经光荣阵亡了
$ /opt/app/kafka_2.11-1.0.1/bin/kafka-topics.sh --zookeeper 172.16.217.38:2181/log-kafka --describe --unavailable-partitions
...
	Topic: realtime_kafka.post_alg_real	Partition: 2	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 11	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 20	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 29	Leader: -1	Replicas: 4	Isr: 4
	Topic: rm-bp1d3u2p9v3l4da7c632	Partition: 1	Leader: -1	Replicas: 4	Isr: 4
	Topic: rm-bp1udb05091x11q5x	Partition: 1	Leader: -1	Replicas: 4	Isr: 4

# 查看副本不同步的分区详情
# 可以发现副本中有不同步的情况，是因为有副本所在的节点已经挂了，通常有一部分是因为资源或者网络原因未同步，还有就是如上述broker阵亡的情况
# 如果说--unavailable-partitions可以直接查看到受影响的topic，那么--under-replicated-partitions就可以查看可用性受影响的topic，因为当副本为2时，此时broker4阵亡的前提下，topic下的分区是无法保证高可用的
$ /opt/app/kafka_2.11-1.0.1/bin/kafka-topics.sh --zookeeper 172.16.217.38:2181/log-kafka --describe --under-replicated-partitions
...
...
	Topic: androidregister	Partition: 1	Leader: 2	Replicas: 4,2	Isr: 2
	Topic: eventjsonlog	Partition: 11	Leader: 2	Replicas: 4,2	Isr: 2
	Topic: eventjsonlog	Partition: 27	Leader: 2	Replicas: 2,4	Isr: 2
	Topic: eventjsonlog	Partition: 38	Leader: 13	Replicas: 13,4	Isr: 13
	Topic: eventjsonlog	Partition: 44	Leader: 10	Replicas: 4,10	Isr: 10
	Topic: eventjsonlog	Partition: 52	Leader: 12	Replicas: 12,4	Isr: 12
	Topic: eventjsonlog	Partition: 59	Leader: 11	Replicas: 4,11	Isr: 11
	Topic: eventlog	Partition: 8	Leader: 16	Replicas: 16,4	Isr: 16
	Topic: eventlog	Partition: 23	Leader: 3	Replicas: 4,3	Isr: 3
	Topic: eventlog	Partition: 38	Leader: 13	Replicas: 13,4	Isr: 13
	Topic: eventlog	Partition: 44	Leader: 10	Replicas: 4,10	Isr: 10
	Topic: eventlog	Partition: 52	Leader: 12	Replicas: 12,4	Isr: 12
	Topic: eventlog	Partition: 59	Leader: 11	Replicas: 4,11	Isr: 11
	Topic: pusheventlog	Partition: 9	Leader: 1	Replicas: 1,4	Isr: 1
	Topic: pusheventlog	Partition: 12	Leader: 7	Replicas: 4,7	Isr: 7


</code></pre></td></tr></table>
</div>
</div><p><strong>删除</strong></p>
<ul>
<li><code>--delete</code>: 指定topic删除</li>
</ul>
<p><code>注意:</code> 在删除Topic时会受<code>delete.topic.enable</code>参数的影响，如果为true，则topic直接删除，如果为false，删除仅是标记删除，即在topic的config中增加一个删除标记<code>MarkedForDeletion:true</code>，待broker重启后完全删除(也可通过zk中的数据删除)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 如果delete.topic.enable=true，则直接删除掉
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --delete   --topic bgbiao.top

</code></pre></td></tr></table>
</div>
</div><p><code>注意:</code></p>
<ul>
<li>topic真正的元数据结构: <code>/brokers/topics/topic-name</code>,删除这个即删除</li>
<li>标记删除的topic元数据: <code>/admin/delete_topics/topic-name</code>,删除这个才算数据清理完成</li>
</ul>
<h4 id="12-kafka-reassign-partitionssh">1.2 kafka-reassign-partitions.sh</h4>
<p>该脚本用于在副本之间移动topic的分区，也就是对副本进行重新分配，也是SRE在日常操作中会比较常用的脚本，需要注意的是，在做迁移时需要注意到当前集群的整体情况，毕竟在移动副本时，需要设计到新副本的数据同步，也会占用一定资源。</p>
<p>通常，将服务器添加到Kafka集群很容易，只需为它们分配一个惟一的brokerid，并在新服务器上启动Kafka。然而，这些新服务器不会自动分配任何数据分区，因此，除非将分区移动到它们，否则在创建新主题之前，它们不会做任何工作。因此，向集群中添加机器时，您会希望将一些现有数据迁移到这些机器上。</p>
<ul>
<li><code>--broker-list</code>: 指定分区需要重新分配到的broker节点，如果<code>--topics-to-move-json-file</code>参数被指定用来生成重分配配置时，必须制定该参数</li>
<li><code>--topics-to-move-json-file</code>: 生成一个移动指定topic的分区到指定broker(<code>--broker-list</code>)的配置</li>
<li><code>--generate</code>: 生成候选分区分配的配置，该参数仅会生成候选的分配方案，不会进行执行</li>
<li><code>--reassignment-json-file</code>: 分区手动分配的配置参数，该参数可由<code>generate</code>参数生成，通常一般会进行微调</li>
<li><code>--replica-alter-log-dirs-throttle</code>: 在相同的broker上日志目录之间的副本移动将被限流为该值bytes/sec，限流应该至少设置为1 KB/s，默认是-1表示不限制</li>
<li><code>--throttle</code>: broker之间的分区移动可以使用该值进行限流(bytes/sec)，同上</li>
<li><code>--execute</code>: 通过指定<code>--reassignment-json-file</code>参数来执行重新分配</li>
<li><code>--verify</code>: 如果一个重分配完成了，可以指定<code>--reassignment-json-file</code>参数来查看重分配的进度</li>
</ul>
<p><code>topics-to-move-json-file文件示例</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">{&#34;topics&#34;:
[{&#34;topic&#34;: &#34;foo&#34;},{&#34;topic&#34;: &#34;foo1&#34;}],
&#34;version&#34;:1
}
</code></pre></td></tr></table>
</div>
</div><p><code>reassignment-json-file文件示例</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 注意:log_dirs是可选参数，需要指定绝对路径，也可以指定为any，当指定后需要和replicas的长度相等
  {&#34;partitions&#34;:
  	[{&#34;topic&#34;: &#34;foo&#34;,
  	  &#34;partition&#34;: 1,
  	  &#34;replicas&#34;: [1,2,3],
  	  &#34;log_dirs&#34;: [&#34;dir1&#34;,&#34;dir2&#34;,&#34;dir3&#34;]
    }],
  &#34;version&#34;:1
  }
</code></pre></td></tr></table>
</div>
</div><p>分区重分配示例:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 查看当前topic详情
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 3	Replicas: 3	Isr: 3
	Topic: bgbiao.top	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 2	Leader: 2	Replicas: 2	Isr: 2

# 1.编辑move.json配置
$ cat move.json
{&#34;topics&#34;: [{&#34;topic&#34;: &#34;bgbiao.top&#34;}],
&#34;version&#34;:1
}

# 2.生成迁移配置
# 指定正确的zookeeper地址来获取分区的分布状态以及待迁移的状态
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --topics-to-move-json-file move.json --broker-list &#34;1,2,3&#34; --generate
Current partition replica assignment
{&#34;version&#34;:1,&#34;partitions&#34;:[{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:2,&#34;replicas&#34;:[2],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:1,&#34;replicas&#34;:[1],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:0,&#34;replicas&#34;:[3],&#34;log_dirs&#34;:[&#34;any&#34;]}]}

Proposed partition reassignment configuration
{&#34;version&#34;:1,&#34;partitions&#34;:[{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:0,&#34;replicas&#34;:[1],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:2,&#34;replicas&#34;:[3],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:1,&#34;replicas&#34;:[2],&#34;log_dirs&#34;:[&#34;any&#34;]}]}

# 编辑迁移配置
# 当前分区状态为:bgbiao.top-2的副本在broker2,bgbiao.top-1的副本在broker1,bgbiao.top-0的副本在broker3
# 迁移后的分区状态:bgbiao.top-2的副本在broker3,bgbiao.top-1的副本在broker2,bgbiao.top-0的副本在broker1
# 然后将期望的迁移配置保存下来做相关修改即可.
# 我们是想给某个分区增加副本，因此可以修改成如下配置
$ cat assignment.json
{
    &#34;partitions&#34;: [
        {
            &#34;partition&#34;: 0,
            &#34;replicas&#34;: [
                3,1,2
            ],
            &#34;topic&#34;: &#34;bgbiao.top&#34;
        }
    ],
    &#34;version&#34;: 1
}

# 3.根据上述的迁移配置执行迁移
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --reassignment-json-file ./assignment.json --execute
Current partition replica assignment

{&#34;version&#34;:1,&#34;partitions&#34;:[{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:2,&#34;replicas&#34;:[2],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:1,&#34;replicas&#34;:[1],&#34;log_dirs&#34;:[&#34;any&#34;]},{&#34;topic&#34;:&#34;bgbiao.top&#34;,&#34;partition&#34;:0,&#34;replicas&#34;:[3],&#34;log_dirs&#34;:[&#34;any&#34;]}]}

Save this to use as the --reassignment-json-file option during rollback
Successfully started reassignment of partitions.

# 4.查看上述迁移的进度(将--execute参数改为--verify参数)
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --reassignment-json-file ./assignment.json --verify
Status of partition reassignment:
Reassignment of partition bgbiao.top-0 completed successfully

# 再次查看topix详情
# 如期望，partition-1增加了两个副本,该副本的整体可用性提高了3倍
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 3	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 3	Replicas: 3,1,2	Isr: 3,1,2
	Topic: bgbiao.top	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 2	Leader: 2	Replicas: 2	Isr: 2

</code></pre></td></tr></table>
</div>
</div><p><code>注意:</code> 该工具可以让集群部分节点故障后，及时将新部分的partition进行调整，以恢复partition的高可用性。同时能够让集群在扩展后，快速将已有topic的数据均衡的分布在新节点上，以实现整体负载的均衡。</p>
<h4 id="13-kafka-log-dirssh">1.3 kafka-log-dirs.sh</h4>
<p>该脚本参数用于查看kafka各个broker节点以及topic的磁盘使用率情况</p>
<ul>
<li><code>--describe</code>: 查看topic和broker的磁盘使用情况</li>
<li>
<ul>
<li><code>--broker-list</code>: 指定查看的broker列表</li>
</ul>
</li>
<li>
<ul>
<li><code>--topic-list</code>: 指定需要查看的topic列表</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 当指定topic后会从全部的broker中进行查找
$ sh /opt/app/kafka/bin/kafka-log-dirs.sh --bootstrap-server 172.29.203.62:9092 --describe --topic-list myapp-yum-log,myapp
Querying brokers for log directories information
Received log directory information from brokers 1,2,3
{&#34;version&#34;:1,&#34;brokers&#34;:[{&#34;broker&#34;:1,&#34;logDirs&#34;:[{&#34;logDir&#34;:&#34;/opt/data/kafka/kafka-logs&#34;,&#34;error&#34;:null,&#34;partitions&#34;:[{&#34;partition&#34;:&#34;myapp-yum-log-2&#34;,&#34;size&#34;:13291235,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false},{&#34;partition&#34;:&#34;myapp-0&#34;,&#34;size&#34;:0,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false}]}]},{&#34;broker&#34;:2,&#34;logDirs&#34;:[{&#34;logDir&#34;:&#34;/opt/data/kafka/kafka-logs&#34;,&#34;error&#34;:null,&#34;partitions&#34;:[{&#34;partition&#34;:&#34;myapp-1&#34;,&#34;size&#34;:0,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false},{&#34;partition&#34;:&#34;myapp-yum-log-0&#34;,&#34;size&#34;:13258726,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false}]}]},{&#34;broker&#34;:3,&#34;logDirs&#34;:[{&#34;logDir&#34;:&#34;/opt/data/kafka/kafka-logs&#34;,&#34;error&#34;:null,&#34;partitions&#34;:[{&#34;partition&#34;:&#34;myapp-2&#34;,&#34;size&#34;:0,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false},{&#34;partition&#34;:&#34;myapp-yum-log-1&#34;,&#34;size&#34;:13264869,&#34;offsetLag&#34;:0,&#34;isFuture&#34;:false}]}]}]}

</code></pre></td></tr></table>
</div>
</div><p>结果是json串，可以看到<code>myapp-yum-log-2</code>在broker-1上占用了<code>13291235</code>字节，也就是<code>12M</code>.</p>
<h4 id="14-kafka-leader-electionsh">1.4 kafka-leader-election.sh</h4>
<p>用于一组 Topic 分区的 leader 重新分配，可以支持优先副本和非同步副本。一般用于指定topic的分区存在非预选副本或非同步副本的情况，对整个leader进行适当调整</p>
<ul>
<li><code>--admin.config</code>: 传给admin客户端的配置文件</li>
<li><code>--all-topic-partitions</code>: 基于选举类型<code>--election-type</code>来对符合条件的topic进行选举</li>
<li><code>--bootstrap-server</code>: 指定broker地址</li>
<li><code>--election-type</code>: 指定选举类型<code>[preferred,unclean]</code>，对优先副本进行选举或非同步副本进行选举</li>
<li><code>--partition</code>: 指定需要选举的指定topic分区的id(和&ndash;topic一起使用)</li>
<li><code>--path-to-json-file</code>: 使用json配置文件来保存重分配信息</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 比如我们发现topic的partition-1当前的leader不是优先副本(broker相对倾斜),可以使用如下配置进行leader重新选举
$ sh kafka-leader-election.sh --bootstrap-server 172.29.203.62:9092 --topic test-bgbiao-1 --partition 0 --election-type preferred
Valid replica already elected for partitions


{&#34;partitions&#34;:
    [{&#34;topic&#34;: &#34;foo&#34;, &#34;partition&#34;: 1},
    {&#34;topic&#34;: &#34;foobar&#34;, &#34;partition&#34;: 2}]
}

</code></pre></td></tr></table>
</div>
</div><h4 id="15-kafka-configssh">1.5 kafka-configs.sh</h4>
<p>用来查看和修改kafka相关的配置信息，包含集群的动态配置，topic级别的动态配置等等</p>
<ul>
<li><code>--all</code>: 列出给定实体的全部配置文件(默认已经生效的全部参数，如果没有all仅对动态参数生效)</li>
<li><code>--entity-type</code>: 实体类型[topics/clients/users/brokers/broker-loggers]</li>
<li><code>--entity-name</code>: 实体名称[topic名称/client-id/user-name/broker-id]</li>
<li><code>--describe</code>: 列出给定实体的配置文件</li>
<li><code>--force</code>: 强制生效</li>
<li><code>--topic</code>: 指定topic名称</li>
<li><code>--alter</code>: 修改指定实体的配置文件 <code>注意:当使用delete-config和add-config时必须使用--alter</code></li>
<li><code>--delete-config</code>: 删除指定的配置&quot;k1,k2&quot;</li>
<li><code>--add-config</code>: 给指定的实体增加配置(k=v,k2=[v1,v2,v3],k3=v3)</li>
</ul>
<p><strong>topic级别的动态参数</strong></p>
<ul>
<li><code>cleanup.policy</code>: 清理策略</li>
<li><code>compression.type</code>: 压缩类型(通常建议在produce端控制)</li>
<li><code>delete.retention.ms</code>: 压缩日志的保留时间</li>
<li><code>flush.messages</code>: 持久化message限制</li>
<li><code>flush.ms</code>: 持久化频率</li>
<li><code>follower.replication.throttled.replicas</code>: follower副本限流</li>
<li><code>leader.replication.throttled.replicas</code>: leader副本限流</li>
<li><code>max.message.bytes</code>: 最大的batch的message大小</li>
<li><code>message.downconversion.enable</code>: message向下兼容</li>
<li><code>message.format.version</code>: message格式版本</li>
<li><code>min.insync.replicas</code>: 最小的ISR</li>
<li><code>retention.ms</code>: 日志保留时间</li>
<li><code>retention.bytes</code>: 日志保留大小(通常按照时间限制)</li>
<li><code>segment.bytes</code>: segment的大小限制</li>
<li><code>segment.ms</code>: segment的切割时间</li>
<li><code>unclean.leader.election.enable</code>: 是否允许非同步副本选主(针对可用性设置的一个参数)</li>
</ul>
<p><strong>broker级别的动态参数</strong></p>
<p>broker级别的动态参数比较多，这里只列举常用的几个</p>
<ul>
<li><code>log.retention.ms</code>: 日志保留时间</li>
<li><code>max.connections</code>: 最大连接数</li>
<li><code>max.connections.per.ip</code>: 每个ip的最大连接数</li>
<li><code>message.max.bytes</code>: batch的message的最大限制</li>
<li><code>min.insync.replicas</code>: 最小的ISR</li>
<li><code>num.io.threads</code>: IO线程数(网络线程数的两倍)</li>
<li><code>num.network.threads</code>: 网络线程数(cpu的2/3较好)</li>
<li><code>num.recovery.threads.per.data.dir</code>: 每个数据目录的恢复线程</li>
<li><code>num.replica.fetchers</code>: 副本的fetchers数量(默认为1,可适当调大)</li>
</ul>
<p><strong>user级别的参数</strong></p>
<ul>
<li><code>SCRAM-SHA-256</code>:</li>
<li><code>SCRAM-SHA-512</code>:</li>
<li><code>consumer_byte_rate</code>: 针对消费者user进行限流</li>
<li><code>producer_byte_rate</code>: 针对生产者进行限流</li>
<li><code>request_percentage</code>: 请求百分比</li>
</ul>
<p><strong>clients级别参数</strong></p>
<ul>
<li><code>consumer_byte_rate</code>: 针对消费者user进行限流</li>
<li><code>producer_byte_rate</code>: 针对生产者进行限流</li>
<li><code>request_percentage</code>: 请求百分比</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 修改topic的数据保留时间
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092 --topic push-test --add-config retention.ms=10000000 --alter

# 查看topic的动态参数配置
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092 --topic push-test --describe
Dynamic configs for topic push-test are:
  retention.ms=10000000 sensitive=false synonyms={DYNAMIC_TOPIC_CONFIG:retention.ms=10000000}

# 删除topic动态参数
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092 --topic push-test --alter --delete-config retention.ms
Completed updating config for topic push-test.

# 查看broker全部的参数(--all会获取全部的参数)
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092 --all --broker-defaults  --describe
Default configs for brokers in the cluster are:

# 也可以使用如下参数查看broker的全部参数(动态的和默认的参数)
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092  --all --entity-type brokers --entity-name  1  --describe
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092  --all --broker 1  --describe

# broker的动态参数(去除了--all之后，会发现列出的是动态的配置，默认broker是没有动态参数调整的)
$ sh kafka-configs.sh --bootstrap-server 172.29.203.62:9092  --broker 1  --describe
Dynamic configs for broker 1 are:

# user和client也是类似的
</code></pre></td></tr></table>
</div>
</div><h4 id="16-kafka-broker-api-versionssh">1.6 kafka-broker-api-versions.sh</h4>
<p>查看kafka对外的各个api版本.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 查看当前kafka版本
$ sh kafka-broker-api-versions.sh --bootstrap-server 172.29.203.62:9092 --version
2.5.0 (Commit:66563e712b0b9f84)

# 查看集群所有节点的api版本
$ sh kafka-broker-api-versions.sh --bootstrap-server 172.29.203.62:9092
172.29.203.106:9092 (id: 2 rack: null) -&gt; (
	Produce(0): 0 to 8 [usable: 8],
	Fetch(1): 0 to 11 [usable: 11],
	ListOffsets(2): 0 to 5 [usable: 5],
	Metadata(3): 0 to 9 [usable: 9],
	LeaderAndIsr(4): 0 to 4 [usable: 4],
	StopReplica(5): 0 to 2 [usable: 2],
	UpdateMetadata(6): 0 to 6 [usable: 6],
	ControlledShutdown(7): 0 to 3 [usable: 3],
	OffsetCommit(8): 0 to 8 [usable: 8],
	OffsetFetch(9): 0 to 7 [usable: 7],
	FindCoordinator(10): 0 to 3 [usable: 3],
	JoinGroup(11): 0 to 7 [usable: 7],
	Heartbeat(12): 0 to 4 [usable: 4],
	LeaveGroup(13): 0 to 4 [usable: 4],
	SyncGroup(14): 0 to 5 [usable: 5],
	DescribeGroups(15): 0 to 5 [usable: 5],
	ListGroups(16): 0 to 3 [usable: 3],
	SaslHandshake(17): 0 to 1 [usable: 1],
	ApiVersions(18): 0 to 3 [usable: 3],
	CreateTopics(19): 0 to 5 [usable: 5],
	DeleteTopics(20): 0 to 4 [usable: 4],
	DeleteRecords(21): 0 to 1 [usable: 1],
	InitProducerId(22): 0 to 3 [usable: 3],
	OffsetForLeaderEpoch(23): 0 to 3 [usable: 3],
	AddPartitionsToTxn(24): 0 to 1 [usable: 1],
	AddOffsetsToTxn(25): 0 to 1 [usable: 1],
	EndTxn(26): 0 to 1 [usable: 1],
	WriteTxnMarkers(27): 0 [usable: 0],
	TxnOffsetCommit(28): 0 to 3 [usable: 3],
	DescribeAcls(29): 0 to 2 [usable: 2],
	CreateAcls(30): 0 to 2 [usable: 2],
	DeleteAcls(31): 0 to 2 [usable: 2],
	DescribeConfigs(32): 0 to 2 [usable: 2],
	AlterConfigs(33): 0 to 1 [usable: 1],
	AlterReplicaLogDirs(34): 0 to 1 [usable: 1],
	DescribeLogDirs(35): 0 to 1 [usable: 1],
	SaslAuthenticate(36): 0 to 2 [usable: 2],
	CreatePartitions(37): 0 to 2 [usable: 2],
	CreateDelegationToken(38): 0 to 2 [usable: 2],
	RenewDelegationToken(39): 0 to 2 [usable: 2],
	ExpireDelegationToken(40): 0 to 2 [usable: 2],
	DescribeDelegationToken(41): 0 to 2 [usable: 2],
	DeleteGroups(42): 0 to 2 [usable: 2],
	ElectLeaders(43): 0 to 2 [usable: 2],
	IncrementalAlterConfigs(44): 0 to 1 [usable: 1],
	AlterPartitionReassignments(45): 0 [usable: 0],
	ListPartitionReassignments(46): 0 [usable: 0],
	OffsetDelete(47): 0 [usable: 0]
)

</code></pre></td></tr></table>
</div>
</div><h4 id="17-生产者和消费者工具">1.7 生产者和消费者工具</h4>
<ul>
<li><code>kafka-console-consumer.sh</code>: 终端消费者工具</li>
<li><code>kafka-console-producer.sh</code>: 终端生产者工具</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 指定topic从终端写入数据
$ sh /opt/app/kafka/bin/kafka-console-producer.sh --bootstrap-server 172.29.203.62:9092 --topic test-push
&gt;hello xxb
&gt;BGBiao
&gt;My website is https://bgbiao.top.
&gt;And
&gt;公众号: BGBiao


# 指定消费者组对topic进行消费
# --from-beginning表示从头开始消费
# 因为开始生产者刚开始生产并生产topic，导致topic无leader会有警告信息
# 可以看到client-id就是consumer-test-bgbiao-1,即consumer的前缀加消费组加数字后缀
$ sh kafka-console-consumer.sh --bootstrap-server 172.29.203.62:9092 --topic push-test --group test-bgbiao
[2020-05-31 19:52:13,472] WARN [Consumer clientId=consumer-test-bgbiao-1, groupId=test-bgbiao] Error while fetching metadata with correlation id 2 : {test-push=LEADER_NOT_AVAILABLE} (org.apache.kafka.clients.NetworkClient)
hello xxb
BGBiao
My website is https://bgbiao.top.

公众号: BGBiao



</code></pre></td></tr></table>
</div>
</div><h4 id="18-kafka-consumer-groupssh">1.8 kafka-consumer-groups.sh</h4>
<p>消费组管理工具，可以列出所有的消费组，查看消费组详情，删除消费组信息以及重置消费组的offset</p>
<ul>
<li><code>--all-groups</code>: 应用到所有的消费组</li>
<li><code>--all-topics</code>:</li>
<li><code>--delete</code>: 删除topic分区的offset,以及拥有者和消费组信息(&ndash;group g1 &ndash;group g2)</li>
<li><code>--delete-offsets</code>: 删除消费组的offset</li>
<li><code>--describe</code>: 查看消费组信息以及消费者的offset lag</li>
<li><code>--execute</code>: 指定操作，支持<code>reset-offsets</code>操作</li>
<li><code>--export</code>: 导出操作执行到csv，支持<code>reset-offsets</code></li>
<li><code>--from-file</code>: 指定文件中指定的值重置offset (csv文件)</li>
<li><code>--group</code>: 指定消费组</li>
<li><code>--list</code>: 列出所有的消费组</li>
<li><code>--members</code>: 查看消费组中的成员</li>
<li><code>--state</code>: 查看消费组的状态</li>
<li><code>--offsets</code>: 查看消费组并且列出每个消费组所有topic的分区以及消息的offset lag</li>
<li><code>--reset-offsets</code>: 重置消费组的offset (需要指定如下一个参数)</li>
<li>
<ul>
<li><code>--to-datetime</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--by-period</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--to-earliest</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--to-latest</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--shift-by</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--from-file</code>:</li>
</ul>
</li>
<li>
<ul>
<li><code>--to-current</code>:</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 查看全部的消费者组
$ sh /opt/app/kafka/bin/kafka-consumer-groups.sh --bootstrap-server 172.29.203.62:9092 --all-grou  --list
KMOffsetCache-daf27df49ede
test-bgbiao

# 查看消费者详情
$ sh /opt/app/kafka/bin/kafka-consumer-groups.sh --bootstrap-server 172.29.203.62:9092 --group test-bgbiao --describe

GROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                                 HOST            CLIENT-ID
test-bgbiao     test-push       0          1               1               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1
test-bgbiao     test-push       1          2               2               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1
test-bgbiao     test-push       2          2               2               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1

# 查看消费组的成员
$ sh /opt/app/kafka/bin/kafka-consumer-groups.sh --bootstrap-server 172.29.203.62:9092 --group test-bgbiao --members --describe

GROUP           CONSUMER-ID                                                 HOST            CLIENT-ID              #PARTITIONS
test-bgbiao     consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1 3

# 查看消费组状态
$ sh /opt/app/kafka/bin/kafka-consumer-groups.sh --bootstrap-server 172.29.203.62:9092 --group test-bgbiao --state --describe

GROUP                     COORDINATOR (ID)          ASSIGNMENT-STRATEGY  STATE           #MEMBERS
test-bgbiao               172.29.203.62:9092 (1)    range                Stable          1


# 查看消费组的offset信息
$ sh /opt/app/kafka/bin/kafka-consumer-groups.sh --bootstrap-server 172.29.203.62:9092 --group test-bgbiao --offsets --describe
GROUP           TOPIC           PARTITION  CURRENT-OFFSET  LOG-END-OFFSET  LAG             CONSUMER-ID                                                 HOST            CLIENT-ID
test-bgbiao     test-push       0          1               1               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1
test-bgbiao     test-push       1          2               2               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1
test-bgbiao     test-push       2          2               2               0               consumer-test-bgbiao-1-a915f28c-3ee0-46ee-a8d8-6c93bddb7686 /172.29.203.62  consumer-test-bgbiao-1
test-bgbiao     test-full-push    2          61392           61430           38              -                                                           -               -
test-bgbiao     test-full-push    1          61056           61088           32              -                                                           -               -
test-bgbiao     test-full-push    0          61299           61337           38              -
</code></pre></td></tr></table>
</div>
</div><h3 id="2-kafka-manager">2. kafka-manager</h3>
<h2 id="四集群监控">四、集群监控</h2>
<p><a href="http://kafka.apache.org/24/documentation.html#monitoring">kafka-doc-monitor</a></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg" alt="知识星球"></p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg" alt="公众号"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gdra6n69uhj30f00kkgot.jpg" alt=""></p>
    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">BGBiao</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-11-01
      
        
        
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处<BGBiao>。谢谢！</span>
  </p>
</div>


    
    
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">Reward</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/reward_wechat.png">
        <span>Wechat</span>
      </label>
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/reward_wechat.png">
        <span>Alipay</span>
      </label>
  </div>
</div>

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://bgbiao.top/tags/%E8%BF%90%E7%BB%B4/">运维</a>
          <a href="https://bgbiao.top/tags/kafka/">kafka</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/kafka%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">kafka常用运维操作</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/jvm%E7%9A%84%E5%88%9D%E5%A7%8B%E5%A0%86/">
            <span class="next-text nav-default">你还记得你JVM的的初始堆大小吗</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "BGBiao/comments-bgbiao.top"
            issue-term="pathname"
            theme="github-dark"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:weichuangxxb@qq.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/BGBiao/" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://bgbiao.top/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        BGBiao
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  











  <script>
    $("#openSearch, #openSearchMobile").click(function(){
      $(".modal-dialog").addClass("visible");
    });

    $("#closeSearch").click(function(){
      $(".modal-dialog").removeClass("visible");
    });

    $(document).click(function(event) {
    
      if (!$(event.target).closest(".modal-content, #openSearch, #openSearchMobile").length) {
        $("body").find(".modal-dialog").removeClass("visible");
      }
    });
  </script>





</body>
</html>
