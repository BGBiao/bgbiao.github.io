<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BGBiao的Ops人生</title>
    <link>https://bgbiao.top/</link>
    <description>Recent content on BGBiao的Ops人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 12 Jan 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://bgbiao.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深入Gin框架内幕2</title>
      <link>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%952/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%952/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;在上一篇文章&lt;a href=&#34;https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95/&#34;&gt;深入gin框架内幕(一)&lt;/a&gt;中，主要介绍了Gin框架中是如何创建一个HTTP服务以及内部的核心结构和常用的一些结构体方法，并在最后以一个简单的示例来详细讲解Gin框架内部具体是如何运行的，但是在最后我们会发现使用了一个&lt;code&gt;Context&lt;/code&gt;引用对象的一些方法来返回具体的HTTP响应数据，在本篇文章中，我们将继续学习和分析Gin框架内幕。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在开始分析之前，我们先简单回顾一下上一个章节中讲到的Gin框架中的几个核心的结构.&lt;/p&gt;

&lt;h3 id=&#34;gin框架中的几个核心结构&#34;&gt;Gin框架中的几个核心结构&lt;/h3&gt;

&lt;p&gt;Gin框架中的几个重要的模型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Engine&lt;/code&gt;: 用来初始化一个&lt;code&gt;gin&lt;/code&gt;对象实例，在该对象实例中主要包含了一些框架的基础功能，比如日志，中间件设置，路由控制(组)，以及handlercontext等相关方法.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L54&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Router&lt;/code&gt;: 用来定义各种路由规则和条件，并通过HTTP服务将具体的路由注册到一个由context实现的handler中&lt;/li&gt;
&lt;li&gt;Context: &lt;code&gt;Context&lt;/code&gt;是框架中非常重要的一点，它允许我们在中间件间共享变量，管理整个流程，验证请求的json以及提供一个json的响应体. 通常情况下我们的业务逻辑处理也是在整个Context引用对象中进行实现的.&lt;/li&gt;
&lt;li&gt;Bind: 在Context中我们已经可以获取到请求的详细信息，比如HTTP请求头和请求体，但是我们需要根据不同的HTTP协议参数来获取相应的格式化
数据来处理底层的业务逻辑，就需要使用&lt;code&gt;Bind&lt;/code&gt;相关的结构方法来解析context中的HTTP数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-gin框架对http响应数据的处理&#34;&gt;1.Gin框架对HTTP响应数据的处理&lt;/h4&gt;

&lt;p&gt;我们在&lt;a href=&#34;https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95/&#34;&gt;深入Gin框架内幕(一)&lt;/a&gt;中，以一个简单的Gin实例来具体讲解它内部是如何创建一个Http服务，并且注册一个路由来接收用户的请求，在示例程序中我们使用了&lt;code&gt;Context&lt;/code&gt;引用对象的&lt;code&gt;String&lt;/code&gt;方法来处理HTTP服务的数据响应，所以在整个Gin框架中紧跟&lt;code&gt;Router&lt;/code&gt;模型结构的就要属&lt;code&gt;Context&lt;/code&gt;结构了，该结构体主要用来处理整个HTTP请求的上下文数据，也是我们在开发HTTP服务中相对比较重要的一个结构体了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 深入Gin框架内幕(一)中的示例
$ cat case1.go
package main
import (
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/gin-gonic/gin&amp;quot;
)
func main() {
    ginObj := gin.Default()
    ginObj.Any(&amp;quot;/hello&amp;quot;,func(c *gin.Context){
        c.String(http.StatusOK,&amp;quot;Hello BGBiao.&amp;quot;)
    })
    ginObj.Run(&amp;quot;localhost:8080&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以看到，在使用Gin框架后，我们只需要很简单的代码，即可以快速运行一个返回&lt;code&gt;Hello BGBiao.&lt;/code&gt;的HTTP服务，而在&lt;code&gt;ginObj.Any&lt;/code&gt;方法中，我们传入了一个参数为&lt;code&gt;Context&lt;/code&gt;引用类型的匿名函数，并在该函数内部采用&lt;code&gt;String(code,data)&lt;/code&gt;方法来处理HTTP服务的响应数据(返回Hello BGBiao字符串)，这个时候，你可能会想，我们在企业内部都是前后端分离，通常情况下后端仅会提供&lt;code&gt;RESTful API&lt;/code&gt;，并通过&lt;code&gt;JSON&lt;/code&gt;格式的数据和前端进行交互，那么Gin是如何处理其他非字符串类型的数据响应呢，这也是我们接下来要主要讲的&lt;code&gt;Context&lt;/code&gt;结构模型。&lt;/p&gt;

&lt;h4 id=&#34;2-gin框架中的context结构体&#34;&gt;2.Gin框架中的Context结构体&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在Gin框架中由&lt;code&gt;Router&lt;/code&gt;结构体来负责路由和方法(URL和HTTP方法)的绑定，内的Handler采用&lt;code&gt;Context&lt;/code&gt;结构体来处理具体的HTTP数据传输方式，比如HTTP头部，请求体参数，状态码以及响应体和其他的一些常见HTTP行为。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Context结构体&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Context struct {
    // 一个包含size,status和ResponseWriter的结构体
    writermem responseWriter
    // http的请求体(指向原生的http.Request指针)
    Request   *http.Request
    // ResonseWriter接口
    Writer    ResponseWriter

    // 请求参数[]{&amp;quot;Key&amp;quot;:&amp;quot;Value&amp;quot;}
    Params   Params
    handlers HandlersChain
    index int8
    // http请求的全路径地址
    fullPath string
    // gin框架的Engine结构体指针
    engine   *Engine
    // 每个请求的context中的唯一键值对
    Keys map[string]interface{}
    // 绑定到所有使用该context的handler/middlewares的错误列表
    Errors errorMsgs
    // 定义了允许的格式被用于内容协商(content)
    Accepted []string
    // queryCache 使用url.ParseQuery来缓存参数查询结果(c.Request.URL.Query())
    queryCache url.Values
    // formCache 使用url.ParseQuery来缓存PostForm包含的表单数据(来自POST,PATCH,PUT请求体参数)
    formCache url.Values
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Context结构体常用的一些方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;基本方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Copy(): 返回当前正在使用的context的拷贝(context指针)，当这个context必须在goroutine中用时，该方法比较有用&lt;/li&gt;
&lt;li&gt;HandlerName(): 返回当前主handler的名称(比如:handler为handleGetUsers(),该方法将返回&amp;rdquo;main.handleGetUsers&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;HandlerNames(): 返回所有注册的handler的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handler()&lt;/code&gt;: 返回当前的主handler(&lt;code&gt;func (c *Context) Handler() HandlerFunc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;FullPath(): 返回一个匹配路由的全路径(uri: &amp;ldquo;/user/:id&amp;rdquo;,c.FullPath() == &amp;ldquo;/user/:id&amp;rdquo; )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;http常用方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ClientIP() string: 返回客户端ip(该方法会解析&lt;code&gt;X-Real-IP&lt;/code&gt;,&lt;code&gt;X-Forwarded-For&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ContentType() string: 返回HTTP的Content-Type头&lt;/li&gt;
&lt;li&gt;IsWebsocket() bool: 返回是否为ws链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;流控相关的方法:&lt;/code&gt;
- Next(): 该方法仅被使用在middleware中，它会在被调用的handler链内部执行pending handler
- IsAborted(): 如果当前的context被终止了，该方法返回true
- Abort(): 该函数可以从正在被调用中保护pending handler. 该方法停止后不会停止当前正在执行的handler. 比如我们有一个鉴权的中间件来验证请求是否有权限，如果认证失败了(用户信息异常等)，此时调用Abort()来确保后面的handler不再被调用
- AbortWithStatus(code int): 同上，在会写入状态码。context.AbortWithStatus(401)即可表示上述的鉴权失败
- AbortWithStatusJSON(code int, jsonObj interface{}): 同上，会再加响应数据.该方法会停止整个handler链，再写入状态码和json的响应体，同时也会设置Content-Type=&amp;ldquo;application/json&amp;rdquo;
- AbortWithError(code int, err error) *Error: 同上返回错误信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;错误管理&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error(err error) *Error: 返回一些错误对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;元数据管理&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set(key string, value interface{}): 给当前这个context设置一个新的键值对&lt;/li&gt;
&lt;li&gt;Get(key string) (value interface{}, exists bool): 返回指定的key的值,以及是否存在&lt;/li&gt;
&lt;li&gt;MustGet(key string) interface{}: 返回指定key的值，不存在则panic&lt;/li&gt;
&lt;li&gt;GetString(key string) (s string): 以string类型返回指定的key&lt;/li&gt;
&lt;li&gt;GetBool(key string) (b bool): 返回分配给该key的值(bool类型)&lt;/li&gt;
&lt;li&gt;GetInt(key string) (i int):&lt;/li&gt;
&lt;li&gt;GetStringSlice(key string) (ss []string): 返回key的slice类型&lt;/li&gt;
&lt;li&gt;GetStringMap(key string) (sm map[string]interface{}): 返回interface{}类型的map结构&lt;/li&gt;
&lt;li&gt;GetStringMapString(key string) (sms map[string]string): 返回string类型的map结构&lt;/li&gt;
&lt;li&gt;GetStringMapStringSlice(key string) (smss map[string][]string): 同理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;输入数据&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Param(key string) string: 返回URL的参数值(uri_patten: &amp;ldquo;/user/:id&amp;rdquo;,url: &amp;ldquo;/user/john&amp;rdquo;,c.Param(&amp;ldquo;id&amp;rdquo;) = &amp;ldquo;john&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Query(key string) string: 返回url中的查询参数值(url: &amp;ldquo;/path?id=1234&amp;amp;name=Manu&amp;amp;value=&amp;ldquo;,c.Query(&amp;ldquo;id&amp;rdquo;)为1234,c.Query(&amp;ldquo;name&amp;rdquo;)为Manu,c.Query(&amp;ldquo;value&amp;rdquo;)为空)&lt;/li&gt;
&lt;li&gt;DefaultQuery(key, defaultValue string) string: 返回url中的查询参数的默认值(同上，但是c.Query(&amp;ldquo;value&amp;rdquo;)就没有值，该方法可以设置默认值)&lt;/li&gt;
&lt;li&gt;GetQuery(key string) (string, bool): 同Query()方法，并且会返回状态，如果对应的key不存在，返回(&amp;ldquo;&amp;rdquo;,false)&lt;/li&gt;
&lt;li&gt;QueryArray(key string) []string: 返回指定key的对应的array(slice的长度取决于给定key的参数的数量)&lt;/li&gt;
&lt;li&gt;GetQueryArray(key string) ([]string, bool): 同上，会返回状态&lt;/li&gt;
&lt;li&gt;QueryMap(key string) map[string]string: 返回指定key对应map类型&lt;/li&gt;
&lt;li&gt;GetQueryMap(key string) (map[string]string, bool): 同上，并且会返回状态&lt;/li&gt;
&lt;li&gt;PostForm(key string) string: 该方法返回一个从POST 请求的urlencode表单或者multipart表单数据，不存在时返回空字符串&lt;/li&gt;
&lt;li&gt;DefaultPostForm(key, defaultValue string) string: 同上，key不存在时返回默认值&lt;/li&gt;
&lt;li&gt;GetPostForm(key string) (string, bool): 同PostForm()方法，并且会返回状态&lt;/li&gt;
&lt;li&gt;PostFormArray(key string) []string: 该方法返回指定key的字符串类型的slice&lt;/li&gt;
&lt;li&gt;GetPostFormArray(key string) ([]string, bool): 同上，并返回状态&lt;/li&gt;
&lt;li&gt;PostFormMap(key string) map[string]string: 返回指定key的map类型&lt;/li&gt;
&lt;li&gt;GetPostFormMap(key string) (map[string]string, bool): 同上，并返回状态&lt;/li&gt;
&lt;li&gt;FormFile(name string) (*multipart.FileHeader, error): 返回指定key的第一个文件(用作文件上传)&lt;/li&gt;
&lt;li&gt;MultipartForm() (*multipart.Form, error): 该方法解析multipart表单，包含file文件上传&lt;/li&gt;
&lt;li&gt;SaveUploadedFile(file *multipart.FileHeader, dst string) error: 该方法用来上传指定的文件头到目标路径(dst)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Bind家族相关方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind(obj interface{}) error: 自动解析&lt;code&gt;Content-Type&lt;/code&gt;并绑定到指定的binding引擎&lt;/li&gt;
&lt;li&gt;BindJSON(obj interface{}) error: 同上，binding引擎为&lt;code&gt;binding.JSON&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BindXML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindQuery(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindYAML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindHeader(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindUri(obj interface{}) error: 使用&lt;code&gt;binding.Uri&lt;/code&gt;来绑定传递的结构体指针&lt;/li&gt;
&lt;li&gt;MustBindWith(obj interface{}, b binding.Binding) error: 使用指定的binding引擎来绑定传递的结构体指针(当有任何错误时，终止请求并返回400)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ShouldBind家族相关方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ShouldBind(obj interface{}) error: 同上述的Bind()方法，但是该方法在json结构无效时不会返回400&lt;/li&gt;
&lt;li&gt;ShouldBindJSON(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindXML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindQuery(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindYAML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindHeader(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindUri(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindWith(obj interface{}, b binding.Binding) error: 等同于MustBindWith()方法&lt;/li&gt;
&lt;li&gt;ShouldBindBodyWith(obj interface{}, bb binding.BindingBody) (err error): 和ShouldBindWith()方法相似，但是他会存储请求体到context中，当下次调用时可以重用(因为该方法是在binding之前读取body，因此在你只使用一次时，为了更好的性能还是使用ShouldBindWith会比较好)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;HTTP响应相关的方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Status(code int): 设置http的响应码&lt;/li&gt;
&lt;li&gt;Header(key, value string): 是&lt;code&gt;c.Writer.Header().Set(key, value)&lt;/code&gt;的简单实现，在响应体重写入一个header，如果value为空，则相当于调用了&lt;code&gt;c.Writer.Header().Del(key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GetHeader(key string) string: 返回请求体重的header&lt;/li&gt;
&lt;li&gt;GetRawData() ([]byte, error): 返回流式数据&lt;/li&gt;
&lt;li&gt;SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool): 该方法将设置一个Set-Cookie到ResponseWriter的头中(注意:name必须是一个合法可用的名称,无效的coookie可能会被丢弃)&lt;/li&gt;
&lt;li&gt;Cookie(name string) (string, error): 返回名称为name的cookie&lt;/li&gt;
&lt;li&gt;Render(code int, r render.Render): 该方法写入响应头并调用render.Render去渲染数据&lt;/li&gt;
&lt;li&gt;HTML(code int, name string, obj interface{}): 该方法使用指定文件模板名称去渲染http模板(同时会更新状态码并设置Content-Type as &amp;ldquo;text/html&amp;rdquo;.)&lt;/li&gt;
&lt;li&gt;IndentedJSON(code int, obj interface{}): 该方法会序列化对象obj为一个pretty JSON 数据到响应体中，同时设置Content-Type as &amp;ldquo;application/json&amp;rdquo;(pretty JSON需要消耗cpu和带宽，强烈建议生产使用&lt;code&gt;Context.JSON()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;SecureJSON(code int, obj interface{}): 同上，会序列化成&lt;code&gt;Secure Json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JSONP(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;JSON(code int, obj interface{}): 序列化为JSON,并写Content-Type:&amp;ldquo;application/json&amp;rdquo;头&lt;/li&gt;
&lt;li&gt;AsciiJSON(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;PureJSON(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;XML(code int, obj interface{}): 序列化成&lt;code&gt;xml&lt;/code&gt;格式,并写Content-Type:&amp;ldquo;application/xml&amp;rdquo;&lt;/li&gt;
&lt;li&gt;YAML(code int, obj interface{}): 序列化成&lt;code&gt;yaml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ProtoBuf(code int, obj interface{}): 序列化成&lt;code&gt;probuf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;String(code int, format string, values &amp;hellip;interface{}): 将制定的string写入响应体&lt;/li&gt;
&lt;li&gt;Redirect(code int, location string): 重定向&lt;/li&gt;
&lt;li&gt;Data(code int, contentType string, data []byte): 写一些数据到响应体重，并更新响应码&lt;/li&gt;
&lt;li&gt;DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string): 写一些制定模板的数据到响应体中，并更新状态码&lt;/li&gt;
&lt;li&gt;File(filepath string): 以一种高效方式将制定文件写入响应体数据中&lt;/li&gt;
&lt;li&gt;FileAttachment(filepath, filename string): 同上，但是在客户端文件会被直接下载下来&lt;/li&gt;
&lt;li&gt;SSEvent(name string, message interface{}): 写Server-Sent Event到响应数据中&lt;/li&gt;
&lt;li&gt;Stream(step func(w io.Writer) bool) bool: 发送一个流式的响应数据并返回状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-gin实例示例&#34;&gt;3.Gin实例示例&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;3.1返回json格式的数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了解决我们在开头提到的问题，我们将使用context引用对象的JSON家族方法来处理该需求&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 使用context来返回json格式的数据
$ cat case2.go
package main

import (
    &amp;quot;github.com/gin-gonic/gin&amp;quot;
)

// 我们定义一个通用的格式化的响应数据
// 在Data字段中采用空接口类型来实际存放我们的业务数据
type restData struct {
    Data        interface{}   `json:&amp;quot;data&amp;quot;`
    Message     string        `json:&amp;quot;message&amp;quot;`
    Status      bool          `json:&amp;quot;status&amp;quot;`
}

func main() {
    // mock一个http响应数据
    restdata := &amp;amp;restData{&amp;quot;Hello,BGBiao&amp;quot;,&amp;quot;&amp;quot;,true}
    restdata1 := &amp;amp;restData{map[string]string{&amp;quot;name&amp;quot;:&amp;quot;BGBiao&amp;quot;,&amp;quot;website&amp;quot;:&amp;quot;https://bgbiao.top&amp;quot;},&amp;quot;&amp;quot;,true}

    // 使用Gin框架启动一个http接口服务
    ginObj := gin.Default()
    ginObj.GET(&amp;quot;/api/test&amp;quot;,func(c *gin.Context){
       // 我们的handlerFunc中入参是一个Context结构的引用对象c
       // 因此我们可以使用Context中的JSON方法来返回一个json结构的数据
       // 可用的方法有如下几种，我们可以根据实际需求进行选择
       /*
          IndentedJSON(code int, obj interface{}): 带缩进的json(消耗cpu和mem)
          SecureJSON(code int, obj interface{}): 安全化json
          JSONP(code int, obj interface{})
          JSON(code int, obj interface{}): 序列化为JSON,并写Content-Type:&amp;quot;application/json&amp;quot;头
       */
       c.JSON(200,restdata)
    })
    ginObj.GET(&amp;quot;/api/test1&amp;quot;,func(c *gin.Context){
        c.IndentedJSON(200,restdata1)
    })

    ginObj.Run(&amp;quot;localhost:8080&amp;quot;)
}


# 实例运行(这里成功将我们写的两个api接口进行对外暴露)
$ go run case2.go
....
....
[GIN-debug] GET    /api/test                 --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] GET    /api/test1                --&amp;gt; main.main.func2 (3 handlers)

# 接口测试访问
$ curl localhost:8080/api/test
{&amp;quot;data&amp;quot;:&amp;quot;Hello,BGBiao&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;status&amp;quot;:true}
$ curl localhost:8080/api/test1
{
    &amp;quot;data&amp;quot;: {
        &amp;quot;name&amp;quot;: &amp;quot;BGBiao&amp;quot;,
        &amp;quot;website&amp;quot;: &amp;quot;https://bgbiao.top&amp;quot;
    },
    &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;status&amp;quot;: true
}% 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然上面我们仅以JSON格式来示例，类似的方式我们可以使用&lt;code&gt;XML&lt;/code&gt;,&lt;code&gt;YAML&lt;/code&gt;,&lt;code&gt;ProtoBuf&lt;/code&gt;等方法来输出指定格式化后的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2其他常用的基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在其他基本方法中我们仍然使用上述示例代码中的主逻辑，主要用来测试基本的方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 我们在/api/test这个路由中增加如下两行代码
// 设置响应体中的自定义header(通常我们可以通过自定义头来实现一个内部标识)
c.Header(&amp;quot;Api-Author&amp;quot;,&amp;quot;BGBiao&amp;quot;)
// GetHeader方法用来获取指定的请求头，比如我们经常会使用请求中的token来进行接口的认证和鉴权
// 这里由于我们使用的restdata的指针，通过GetHeader方法获取到token赋值给Message
// ClientIP()方法用于获取客户端的ip地址
restdata.Message = fmt.Sprintf(&amp;quot;token:%s 当前有效，客户端ip:%s&amp;quot;,c.GetHeader(&amp;quot;token&amp;quot;),c.ClientIP())

# 访问接口示例(我们可以看到在响应体中多了一个我们自定义的Api-Author头，并且我们将请求头token的值)
$ curl -H &#39;token:xxxxxxxx&#39; localhost:8080/api/test -i
HTTP/1.1 200 OK
Api-Author: BGBiao
Content-Type: application/json; charset=utf-8
Date: Sun, 12 Jan 2020 14:41:01 GMT
Content-Length: 66

{&amp;quot;data&amp;quot;:&amp;quot;Hello,BGBiao&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;token:xxxxxxxx 当前有效，客户端ip:127.0.0.1&amp;quot;,&amp;quot;status&amp;quot;:true}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.3用户数据输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然到这里后，你可能还会有新的疑问，就是通常情况下，我们开发后端接口会提供一些具体的参数，通过一些具体数据提交来实现具体的业务逻辑处理，这些参数通常会分为如下三类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用HTTP GET方法获取到的url中的一些查询参数来执行更具体的业务逻辑(比如我们查询数据的指定条数之类的)&lt;/li&gt;
&lt;li&gt;使用HTTP POST GET等其他方式以form表单方式提交的数据来验证和处理用户数据&lt;/li&gt;
&lt;li&gt;在URL中获取一些可变参数(比如通常我们的url会定义为&amp;rdquo;/api/uid/:id&amp;rdquo;来表示用户id相关的接口，这个时候通常需要获取到url中的id字段)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上的基本需求，几乎都可以在Context结构体的&lt;code&gt;输入数据&lt;/code&gt;中找到响应的方法.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 接下来，我们依然在上述的代码中进行修改，增加如下路由
$ cat case2.go
....
....
    // 比如我们该接口时用来获取全部数据，但是我们希望在url中增加参数来限制数据条数
    datas := []string{&amp;quot;Golang&amp;quot;,&amp;quot;Python&amp;quot;,&amp;quot;Docker&amp;quot;,&amp;quot;Kubernetes&amp;quot;,&amp;quot;CloudNative&amp;quot;,&amp;quot;DevOps&amp;quot;}
    ginObj.GET(&amp;quot;/api/testdata&amp;quot;,func(c *gin.Context){
        limit := c.Query(&amp;quot;limit&amp;quot;)
        // 其实既然这里我们已经确定需求了，当用户没有输入limit参数时我们就可以设置默认值
        // DefaultQuery(&amp;quot;limit&amp;quot;,&amp;quot;1&amp;quot;)
        // 同时我们其实也可以使用GetQuery方法来获取参数解析状态，即是否有对应的参数
        // 还有QueryArray和GetQueryArray类似的方法
        if limit != &amp;quot;&amp;quot; {
            num,_ := strconv.Atoi(limit)
            restdata1.Data = datas[:num]
        }else {
            restdata1.Data = datas
        }
        c.IndentedJSON(200,restdata1)

    })

    // 使用form表单方式提交数据
    ginObj.POST(&amp;quot;/api/testdata&amp;quot;,func(c *gin.Context){
        // 使用c.PostForm方法来提交一个data数据
        // 同时我们可以使用DefaultPostForm方法来给提交数据一个默认值，比如我们有些参数是希望有默认值的
        // 当然也可以使用GetPostForm，PostFormArray，PostFormArray方法来获取多个数据和状态
        // data := c.PostForm(&amp;quot;data&amp;quot;)
        // datas = append(datas,data)
        /* 这里可能会有个问题就是同时提交多个数据时，使用PostForm方法就会不那么好使了
        通常情况下回使用PostFormArray方法
        */
        data := c.PostFormArray(&amp;quot;data&amp;quot;)
        datas = append(datas,data...)
        restdata1.Data = datas
        c.IndentedJSON(200,restdata1)
    })

    // 获取url中的路径参数
    ginObj.GET(&amp;quot;/api/testdata/:data&amp;quot;,func(c *gin.Context){
        data := c.Param(&amp;quot;data&amp;quot;)
        for _,rawData := range datas {
            if data == rawData {
                restdata1.Data = data
                break
            }
        }
        if restdata1.Data != data {
            restdata1.Data = &amp;quot;&amp;quot;
            restdata1.Message = fmt.Sprintf(&amp;quot;%v 不存在&amp;quot;,data)
            restdata1.Status = false
        }
        c.IndentedJSON(200,restdata1)
    })
....
....



# 请求示例接口
# 我们可以看到使用GET方法默认会获取到全部数据，但是如果有了limit参数后，我们就可以限制数据的条数
$ curl -H &#39;token:xxxxxxxx&#39; localhost:8080/api/testdata
{
    &amp;quot;data&amp;quot;: [
        &amp;quot;Golang&amp;quot;,
        &amp;quot;Python&amp;quot;,
        &amp;quot;Docker&amp;quot;,
        &amp;quot;Kubernetes&amp;quot;,
        &amp;quot;CloudNative&amp;quot;,
        &amp;quot;DevOps&amp;quot;
    ],
    &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;status&amp;quot;: true
}%
$ curl -H &#39;token:xxxxxxxx&#39; &amp;quot;localhost:8080/api/testdata?limit=2&amp;quot;
{
    &amp;quot;data&amp;quot;: [
        &amp;quot;Golang&amp;quot;,
        &amp;quot;Python&amp;quot;
    ],
    &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;status&amp;quot;: true
}%

# 当我们使用post接口往服务提交数据时，就可以让服务端按照需求进行数据处理
curl -X POST  -d data=&amp;quot;vue&amp;quot; &amp;quot;localhost:8080/api/testdata&amp;quot;
{
    &amp;quot;data&amp;quot;: [
        &amp;quot;Golang&amp;quot;,
        &amp;quot;Python&amp;quot;,
        &amp;quot;Docker&amp;quot;,
        &amp;quot;Kubernetes&amp;quot;,
        &amp;quot;CloudNative&amp;quot;,
        &amp;quot;DevOps&amp;quot;,
        &amp;quot;vue&amp;quot;
    ],
    &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;status&amp;quot;: true
}%

# 当我们同时需要提交多份数据时，可以使用PostFormArray方法，同时提交多份数据(可以理解为批量提交)
$ curl -X POST -d data=&amp;quot;vue&amp;quot; -d data=&amp;quot;Rust&amp;quot; &amp;quot;localhost:8080/api/testdata&amp;quot;

# 获取URL中的参数值
$ curl &amp;quot;localhost:8080/api/testdata/Golang&amp;quot;
{
    &amp;quot;data&amp;quot;: &amp;quot;Golang&amp;quot;,
    &amp;quot;message&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;status&amp;quot;: true
}%

$ curl &amp;quot;localhost:8080/api/testdata/Java&amp;quot;
{
    &amp;quot;data&amp;quot;: &amp;quot;&amp;quot;,
    &amp;quot;message&amp;quot;: &amp;quot;Java 不存在&amp;quot;,
    &amp;quot;status&amp;quot;: false
}%

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>深入Gin框架内幕1</title>
      <link>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%951/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%951/</guid>
      
        <description>&lt;h3 id=&#34;gin框架介绍&#34;&gt;Gin框架介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;是一个用 Go (Golang) 编写的 web 框架。它是一个类似于&lt;a href=&#34;https://github.com/go-martini/martini&#34;&gt;martini&lt;/a&gt;但性能更好的API框架，不同于谢大主导的&lt;a href=&#34;https://beego.me/&#34;&gt;Beego&lt;/a&gt;web框架，后者更像是Python语言中的&lt;code&gt;Django&lt;/code&gt;框架，内部包含了开发一个web程序所需的各种组件。&lt;/p&gt;

&lt;p&gt;如果你是性能和高效的追求者，我相信你会像我一样爱上Gin。&lt;/p&gt;

&lt;p&gt;同时，不同于其他Golang语言的API框架，该框架社区十分活跃，并且主程仍然在不断更新和改进，我们知道通常情况下在选择一个开源的软件或者相关库时，社区的活跃度以及项目的更新情况会非常重要(考虑到后期的维护和性能和特性问题)。&lt;/p&gt;

&lt;p&gt;另外一方面，该框架官方提供了很多简单的示例来供我们快速运行一个期望的http服务，这对于一个刚转入Golang进行业务开发的同学来说是一个非常好的开始。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin#api-examples&#34;&gt;Gin官方提供的各种HTTP服务示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然我在很长一段时间也仅是去看官方示例来快速熟悉并实现自己的业务需求，但当有一些特殊的需求时通常去查看官方的具体实现来满足需求，长期如此，不仅耗时且效率极低，因此我产生了将核心源码探究一番的兴趣，希望能通过源码方式来对Gin框架有个深入的学习。&lt;/p&gt;

&lt;h3 id=&#34;gin框架中的几个核心结构&#34;&gt;Gin框架中的几个核心结构&lt;/h3&gt;

&lt;p&gt;我们都知道开发一个HTTP服务，首先需要启动一个TCP监听，然后需要有一些列的handler来处理具体的业务逻辑，最后在再将具体的业务逻辑通过HTTP协议约定和相关的Method和URL进行绑定，以此来对外提供具体功能的HTTP服务。那么在Gin框架对应的就是如下几个模型，我们将一起学习Gin的实现。&lt;/p&gt;

&lt;p&gt;Gin框架中的几个重要的模型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Engine: 用来初始化一个&lt;code&gt;gin&lt;/code&gt;对象实例，在该对象实例中主要包含了一些框架的基础功能，比如日志，中间件设置，路由控制(组)，以及handlercontext等相关方法.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L54&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Router: 用来定义各种路由规则和条件，并通过HTTP服务将具体的路由注册到一个由context实现的handler中&lt;/li&gt;
&lt;li&gt;Context: &lt;code&gt;Context&lt;/code&gt;是框架中非常重要的一点，它允许我们在中间件间共享变量，管理整个流程，验证请求的json以及提供一个json的响应体. 通常情况下我们的业务逻辑处理也是在整个Context引用对象中进行实现的.&lt;/li&gt;
&lt;li&gt;Bind: 在Context中我们已经可以获取到请求的详细信息，比如HTTP请求头和请求体，但是我们需要根据不同的HTTP协议参数来获取相应的格式化数据来处理底层的业务逻辑，就需要使用&lt;code&gt;Bind&lt;/code&gt;相关的结构方法来解析context中的HTTP数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-gin框架中的engine结构体&#34;&gt;1.Gin框架中的Engine结构体&lt;/h4&gt;

&lt;p&gt;当我们在使用框架&lt;code&gt;[Gin](https://github.com/gin-gonic/gin)&lt;/code&gt;来创建一个HTTP服务时，首先我们需要初始化一个实例，在&lt;code&gt;Engine&lt;/code&gt;结构体中就包含了实例的一些基本属性和实例化的一些方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Engine结构体&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Engine struct {
    // 路由组，在实际开发过程中我们通常会使用路由组来组织和管理一些列的路由. 比如: /apis/,/v1/等分组路由
    RouterGroup
    // 开启自动重定向。如果当前路由没有匹配到，但是存在不带/开头的handler就会重定向. 比如: 用户输入/foo/但是存在一个/foo 就会自动重定向到该handler，并且会向客户端返回301或者307状态码(区别在于GET方法和其他方法)
    RedirectTrailingSlash bool
    // 如果开启该参数，没有handler注册时，路由会尝试自己去修复当前的请求地址. 
    // 修复流程:
    // 1.首位多余元素会被删除(../ or //); 2.然后路由会对新的路径进行不区分大小写的查找;3.如果能正常找到对应的handler，路由就会重定向到正确的handler上并返回301或者307.(比如: 用户访问/FOO 和 /..//Foo可能会被重定向到/foo这个路由上)
    RedirectFixedPath bool
    // 如果开启该参数，当当前请求不能被路由时，路由会自己去检查其他方法是否被允许.在这种情况下会响应&amp;quot;Method Not Allowed&amp;quot;，并返回状态码405; 如果没有其他方法被允许，将会委托给NotFound的handler
    HandleMethodNotAllowed bool
    // 是否转发客户端ip
    ForwardedByClientIP    bool
    // 如果开启将会在请求中增加一个以&amp;quot;X-AppEngine...&amp;quot;开头的header
    AppEngine bool
    // 如果开启将会使用url.RawPath去查找参数(默认:false)
    UseRawPath bool
    // 如果开启，请求路径将不会被转义. 如果UseRawPath为false，该参数实际上就为true(因为使用的是url.Path)
    UnescapePathValues bool
    // maxMemory参数的值(http.Request的ParseMultipartForm调用时的参数)
    MaxMultipartMemory int64
    // 是否删除额外的反斜线(开始时可解析有额外斜线的请求)
    RemoveExtraSlash bool
    // 分隔符(render.Delims表示使用HTML渲染的一组左右分隔符,具体可见html/template库)
    delims           render.Delims
    // 设置在Context.SecureJSON中国的json前缀
    secureJsonPrefix string
    // 返回一个HTMLRender接口(用于渲染HTMLProduction和HTMLDebug两个结构体类型的模板)
    HTMLRender       render.HTMLRender
    // html/template包中的FuncMap map[string]interface{} ,用来定义从名称到函数的映射
    FuncMap          template.FuncMap
    // 以下是gin框架内部定义的一些属性 
    // HandlersChain 是一个HandlerFunc 的数组(HandlerFunc其实就是一个Context的指针,Context会在下一节讲解)
    allNoRoute       HandlersChain
    allNoMethod      HandlersChain
    noRoute          HandlersChain
    noMethod         HandlersChain
    // 这里定义了一个可以临时存取对象的集合(sync.Pool是线程安全的，主要用来缓存为使用的item以减少GC压力，使得创建高效且线程安全的空闲队列)
    pool             sync.Pool
    // methodTrees是methodTree的切片(methodTree是一个包含请求方法和node指针的结构体,node是一个管理path的节点树)
    trees            methodTrees
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HandlerFunc定义&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 定义了一个可以被中间件使用的handler
type HandlerFunc func(*Context)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;初始化Engine的方式&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;New()&lt;/code&gt;: 该函数返回一个默认的Engine引用实例(开启了自动重定向,转发客户端ip和禁止请求路径转义)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Default()&lt;/code&gt;: 内部调用&lt;code&gt;New()&lt;/code&gt;函数，但是增加了Logger和Recovery两个中间件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Engine对外常用的方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Delims(left, right string) *Engine&lt;/code&gt;: 给创建好的gin实例指定模板引擎的左右分割符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SecureJsonPrefix(prefix string) *Engine&lt;/code&gt;: 给创建好的gin实例设置secureJsonPrefixi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetHTMLTemplate(templ *template.Template)&lt;/code&gt;: 该方法会gin实实例绑定一个模板引擎(内部其实是设置了engine的HTMLRender属性)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadHTMLGlob(pattern string)&lt;/code&gt;: 该方法用来加载glob模式(类似于shell中的正则)的html模板文件，然后将结果和HTML模板引擎关联(内部调用&lt;code&gt;SetHTMLTemplate&lt;/code&gt;方法将全部匹配到模板注册进去)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadHTMLFiles(files ...string)&lt;/code&gt;: 该方法用上，需要指定一组模板文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetFuncMap(funcMap template.FuncMap)&lt;/code&gt;: 该方法会设置一个FuncMap给template.FuncMap使用(内部其实设置了engine的FuncMap)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoRoute(handlers ...HandlerFunc)&lt;/code&gt;: 该方法为NoRoute增加一些handler，它默认会返回404(通常在企业里，404我们会处理的比较优雅一些，比如给一些企业的静态页啥的)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoMethod(handlers ...HandlerFunc)&lt;/code&gt;: 同上，该方法用于给NoMethod增加handler，默认返回405&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use(middleware ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法用于绑定一个全局的中间件给router. 通过该方法注册的中间件将包含在每个请求的handler chain中(比如可以在这里使用一些logger或者error相关的中间件). 在上面初始化实例的&lt;code&gt;Default()&lt;/code&gt;函数中其实内部使用了&lt;code&gt;engine.Use(Logger(), Recovery())&lt;/code&gt;来加载logger和recovery中间件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Routes() (routes RoutesInfo)&lt;/code&gt;: 该方法用来返回一个路由列表信息&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L50&#34;&gt;RoutesInfo&lt;/a&gt;(一个路由信息RouteInfo中包含Method,Path,Handler,HandlerFunc)，该方法底层调用engine的trees来获取一些router必要的信息.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Run(addr ...string) (err error)&lt;/code&gt;: 该方法会绑定router到http.Server中并开启一个http监听来接收http请求. 该方法其实是&lt;code&gt;http.ListenAndServe(addr, engine)&lt;/code&gt;的简单实现. 注意:该方法除非出现错误，否则会无期限阻塞调用goroutine来接收请求(engine内部只要实现了http.ServeHTTP方法即可)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunTLS(addr, certFile, keyFile string) (err error)&lt;/code&gt;: 同上，以https方式运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunUnix(file string) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;方法，通过指定的unix socket文件运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunFd(fd int) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;方法，通过指定的文件描述符(fd)来运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunListener(listener net.Listener) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;，通过制定的&lt;code&gt;net.Listener&lt;/code&gt;来运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/code&gt;: 该方法遵循了&lt;code&gt;http.Handler&lt;/code&gt;的接口规范，可使gin内部调用&lt;code&gt;http.ListenAndServe&lt;/code&gt;来启动一个http服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandleContext(c *Context)&lt;/code&gt;: 该方法会重新确认一个被重写的context(可以通过c.Request.URL.Path来实现). 需要注意的是该方法可能造成context的循环使用(会绕死你,谨慎使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-gin框架中的router&#34;&gt;2.Gin框架中的Router&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;Engine&lt;/code&gt;结构体中提供的相关方法，我们就可以快速的启动一个HTTP服务了，但是如何对外暴露一个URL来简单实现一个HTTP的数据传输呢，这个时候就需要使用Router中的方法了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gin框架中Router相关的结构体&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouterGroup&lt;/code&gt;: 该结构体被用来在Gin内部配置一个路由，一个RouterGroup被用来关联URL前缀和一组具体的handler业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IRoutes&lt;/code&gt;: IRoutes是一个定了了所有路由处理的接口(包含一些常用的HTTP方法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IRouter&lt;/code&gt;: IRouter则是一个包含单个路由和路由组的所有路由处理的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;RouterGroup相关结构定义&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// RouterGroup 结构体
type RouterGroup struct {
	Handlers HandlersChain
	basePath string
	engine   *Engine
	root     bool
}

// IRoutes 接口
type IRoutes interface {
	Use(...HandlerFunc) IRoutes

	Handle(string, string, ...HandlerFunc) IRoutes
	Any(string, ...HandlerFunc) IRoutes
	GET(string, ...HandlerFunc) IRoutes
	POST(string, ...HandlerFunc) IRoutes
	DELETE(string, ...HandlerFunc) IRoutes
	PATCH(string, ...HandlerFunc) IRoutes
	PUT(string, ...HandlerFunc) IRoutes
	OPTIONS(string, ...HandlerFunc) IRoutes
	HEAD(string, ...HandlerFunc) IRoutes

	StaticFile(string, string) IRoutes
	Static(string, string) IRoutes
	StaticFS(string, http.FileSystem) IRoutes
}

// IRouter接口
type IRouter interface {
	IRoutes
	Group(string, ...HandlerFunc) *RouterGroup
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还记得在上一节中我们的&lt;code&gt;Engine&lt;/code&gt;结构体中有一个&lt;code&gt;RouterGroup&lt;/code&gt;字段吗，该字段会在我们创建一个&lt;code&gt;Engine&lt;/code&gt;的gin实例后帮助我们初始化一个默认的&lt;code&gt;RouterGroup&lt;/code&gt;实例。&lt;/p&gt;

&lt;p&gt;比如在&lt;code&gt;Engine&lt;/code&gt;结构体的中的&lt;code&gt;New()&lt;/code&gt;函数，会初始化一个带有如下&lt;code&gt;RouterGroup&lt;/code&gt;的gin实例，并将gin实例注册到RouterGroup的&lt;code&gt;engine&lt;/code&gt;字段.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L126&#34;&gt;源码文件&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// https://github.com/gin-gonic/gin/blob/master/gin.go#L129
		RouterGroup: RouterGroup{
			Handlers: nil,
			basePath: &amp;quot;/&amp;quot;,
			root:     true,
		},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;RouterGroup结构体对外暴露的常用方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Use(middleware ...HandlerFunc) IRoutes&lt;/code&gt;: 注册一个中间件并返回Iroutes接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Group(relativePath string, handlers ...HandlerFunc) *RouterGroup&lt;/code&gt;: Group方法会创建一个新的路由组。通常我们会创建一个公共的中间件或者是具有相同前缀的路由，来归并到一个路由组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BasePath() string&lt;/code&gt;: 该方法用来返回一个路由组初始路径(比如 v := router.Group(&amp;ldquo;/rest/n/v1/api&amp;rdquo;)，则v.BasePath()就是&amp;rdquo;/rest/n/v1/api&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法会使用给定的HTTP方法和URL来注册一个新的handler。(最后一个handler应该是真正的处理程序，其他的应该是在不同的路由之间共享的中间件)。&lt;code&gt;注意:内部调用了一个handle(httpMethod, relativePath string, handlers HandlersChain)的私有方法来处理核心逻辑&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法是&lt;code&gt;router.Handle(&amp;quot;POST&amp;quot;, path, handle)&lt;/code&gt;的快速实现，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上，会将HTTP的所有方法都注册上去&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StaticFile(relativePath, filepath string) IRoutes&lt;/code&gt;: 该方法用来注册一台路由来服务本地文件系统的单个文件，比如:&lt;code&gt;router.StaticFile(&amp;quot;favicon.ico&amp;quot;, &amp;quot;./resources/favicon.ico&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Static(relativePath, root string) IRoutes&lt;/code&gt;: 该方法用来提供一个指定文件系统根路径的的路由，内部调用&lt;code&gt;group.StaticFS(path,Dir(root,false))&lt;/code&gt;来提供服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StaticFS(relativePath string, fs http.FileSystem) IRoutes&lt;/code&gt;: 指定文件系统(http.FileSystem)来创建一个服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-gin实例示例&#34;&gt;3.Gin实例示例&lt;/h4&gt;

&lt;p&gt;有了上面两个核心模型&lt;code&gt;Engine&lt;/code&gt;和&lt;code&gt;RouteGroup&lt;/code&gt;的了解，此时我们就可以通过Gin框架快速来创建一个简单HTTP服务了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.默认路由&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 测试示例
$ cat case1.go
package main

import (
    &amp;quot;net/http&amp;quot;

    &amp;quot;github.com/gin-gonic/gin&amp;quot;
)

func main() {
    // 使用Default()函数来初始化一个gin实例(engine结构体的引用对象)
    // Default函数内部调用New()函数来初始化一个gin实例，
    // 同时使用Use(middleware ...HandlerFunc) IRoutes 方法注册了Logger和Recovery两个中间件
    // 在New()初始化gin实例的过程中还默认初始化了一个bathPath为&amp;quot;/&amp;quot;的RouterGroup，其实就是一个router实例
    ginObj := gin.Default()
    // 由于RouterGroup在engine结构体中是一个匿名对象，因此实例化的engine引用对象就可以直接操作RouterGroup结构体里对外暴露的所有方法
    // 这里我们尝试注册一个包含所有HTTP方法的路由
    // https://github.com/gin-gonic/gin/blob/master/routergroup.go#L133
    // 而在RouterGroup的各种对外暴露的方法中，底层调用了 Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes方法，后面可以传入多个handler来处理具体的业务逻辑，当handler有多个时最后一个处理实际的业务请求，前面的handler来处理中间件和共享的组件

    // 而HandlerFunc 其实就是一个func(*Context)的匿名函数.Context会在下一节具体分析
    ginObj.Any(&amp;quot;/hello&amp;quot;,func(c *gin.Context){
        // context结构体相关的方法下一节会具体分析，这里是一个简单的示例
        c.String(http.StatusOK,&amp;quot;Hello BGBiao.&amp;quot;)
    })


    // 当所有的路由注册之后，我们可以使用gin的结构体方法(engine结构体的引用对象)来实际运行HTTP服务，以接收用户的http请求
    // 我们前面说过该方法除非出现错误，否则会无期限阻塞调用goroutine来接收请求
    ginObj.Run(&amp;quot;localhost:8080&amp;quot;)
}




# 运行实例
$ go run case1.go
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &amp;quot;debug&amp;quot; mode. Switch to &amp;quot;release&amp;quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] POST   /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] PUT    /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] PATCH  /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] HEAD   /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] OPTIONS /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] DELETE /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] CONNECT /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] TRACE  /hello                    --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] Listening and serving HTTP on localhost:8080

# 模拟请求(因为我们注册了全部的HTTP方法的路由)
$ curl localhost:8080/hello
Hello BGBiao.%                                                                                        
$ curl -X POST  localhost:8080/hello
Hello BGBiao.%                                                                                        
$ curl -X DELETE   localhost:8080/hello
Hello BGBiao.%                                                                                        
$ curl -X TRACE   localhost:8080/hello
Hello BGBiao.%
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>关于如何挣钱的35条建议</title>
      <link>https://bgbiao.top/post/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8C%A3%E9%92%B1%E7%9A%8435%E6%9D%A1%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8C%A3%E9%92%B1%E7%9A%8435%E6%9D%A1%E5%BB%BA%E8%AE%AE/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;这篇《关于如何挣钱的35条建议》，是波波从《How to Get Rich : Every Episode》[附录1]这篇长文(超过3.6万英文单词)翻译整理而来。波波非常认同原文作者Naval关于挣钱和财富的理念，有种强烈的得道恨晚的感觉～要是早十年就懂这些道理就好了，所以专门花时间翻译整理，并且放在自己的公众号里头。期望以后可以经常回顾，加深理解，并最终深入自己的mindset.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;注:&lt;/code&gt;本篇文章转自公众号&amp;rdquo;程序新视界&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.追寻财富，而不是金钱和地位(Seek Wealth, Not Money or Status)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth is assets that earn while you sleep.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;财富是你睡觉时都能挣钱的资产。诸如工厂，机器人，计算机软件，作家的著作，被租赁的房产，被投资进入其它领域的钱等等&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth buys your freedom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;财富的目标就是换取自由，你不必在不喜欢的地方呆着，不必在不喜欢的工作上消磨人生，仅此而已。它并不是让你能够买高级外套，或者开法拉利，或者开游艇，或者周游世界。这些物质享受会让你很快产生厌倦和愚蠢感。财富只是让你成为你自己的主宰。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Money is how we transfer wealth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;金钱是可以转换成资产财富的媒介。金钱是一种社会信用，它代表可以使用他人时间的一种能力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Status is your rank in the social hierarchy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;社会中有两大游戏，几乎每个人都参与其中。一个是金钱游戏，另外一个是身份地位游戏。在地位和财富之间始终上演着一种微妙的竞争，玩身份地位的人，经常会攻击或利用创造财富的人。
创造财富是一种正和游戏(positive-sum)，你拥有一个房子，不会妨碍我也拥有一个房子。身份地位则是一种零和游戏(zero-sum)，老三要爬到老二的位置，那么老二的位子就必须让出来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.挣钱和运气无关(Making Money Isn&amp;rsquo;t About Luck)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Making money isn&amp;rsquo;t about luck. It&amp;rsquo;s about becoming the kind of person who makes moeny.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;挣钱和运气无关，它是关于如何让自己变成注定挣钱的人。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Four kinds of luck: 1). Blind Luck, 2). Luck from hustling, 3). Luck from preparation, 4). Luck from your unique character&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运气的四种分类：
- &lt;code&gt;撞大运&lt;/code&gt;，纯运气
- &lt;code&gt;奋力争取带来的好运&lt;/code&gt;，俗语：幸运眷顾勇敢的人，也就是积极行动大量做事后获得好运，经常折腾的人也会有好运。
- &lt;code&gt;积极准备带来的好运&lt;/code&gt;，俗语：机会永远只给有准备的人。当你在某个领域积累很深，当大多数对这个领域不熟的人还没有觉察到的时候，你可以提前洞察这个领域的机会。
- &lt;code&gt;独特个性带来的好运&lt;/code&gt;，你塑造了一个独特的个性，独特的品牌，独特的思维模式，然后运气就盯上了你(运气变成确定的事)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In 1,000 parallel universes, you want to be wealthy in 999 of them&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在1000个平行宇宙中，你应该期望在其中的999个都是富有的，而不是只在其中的50个，靠运气才富有。通过追寻第四种运气，你可以消除运气因素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.让运气变成你的命运(Make Luck Your Destiny)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Build your character in a way so luck becomes deterministic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以特定方式塑造你的个性，让运气成为注定的事&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Build your character so opportunity finds you&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;塑造你的独特个性(专业，可信赖，正直诚实，勇于担责，具有长线思维)，让机会自己来找你&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You have to be a little eccentric to be out on the frontier by yourself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第四种运气大都源于古怪的行事方式。想要非常收获，你必须要有非常表现。世界是一个高效场所，所有明显的地方都已经被挖掘过，为了找到新奇的尚未发现的事物，你必须要以非常规方式行事，你要有强烈意愿和兴趣，要比别人挖得更深，深到让人感觉非理性的地步。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Extreme people get extreme results ~ Sam Altman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;极端的人获得极端的结果&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t be normal and expect abnormal returns ~ Jeffrey Pfeffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你不可能表现平凡，但却期望不平凡的回报&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Play stupid games win stupid prizes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;玩愚蠢的游戏，只会赢得愚蠢的奖励。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.通过出租时间的方式，你不太可能致富(You Won&amp;rsquo;t Get Rich Renting Out Your Time)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You won&amp;rsquo;t get rich renting out your time, because you can&amp;rsquo;t earn non-linearly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过出租时间(比如打工)的方式，你不太可能致富，因为你的输入(时薪)和输出(工作产出)高度相关，你无法以非线性方式挣钱。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Renting out your time means you&amp;rsquo;re essentially replacable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;出租你的时间意味着你根本上是可以被替代的。大部分输入和输出高度相关的工作，会逐步被机器人或AI所取代。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You must own equity to gain your financial freedom.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你必须拥有资产(生意的一部分，如产品，生意，知识产权，股票期权等)，才可能以非线性方式挣钱，并赢得财务自由。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You want a career where your inputs don&amp;rsquo;t match your outputs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要选择输入和输出不严格相关的，能以非线性方式挣钱的行业。要找高度创新，能够利用工具和杠杆的行业。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.通过量入为出获得自由(Live Below Your Means for Freedom)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People living far below their means enjoy a freedom that people busy upgrading their lifestyles just can&amp;rsquo;t fathom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;量入为出的人能够体会到的自由，是那些忙于升级生活方式的人所无法理解的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The most dangerous things are heroin and a monthly salary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最危险的东西是海洛因和月光族。真正的致富之道是甘于朴素的生活+持续不断的努力积累。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ideally, you&amp;rsquo;ll make your money in discret lumps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以逐步增量的方式挣钱(而非暴发户)是最理想的。财富来得太快去得也快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.为社会创造它想要但是还不知道如何获取的东西(Give Society What It Doesn&amp;rsquo;t Know How to Get)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Society will pay you for creating what it wants, but doen&amp;rsquo;t know how to get, and delivering it at scale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你能够规模化创造和交付社会想要，但是还不知道如何获得的东西，那么社会就会回报你。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Figure out what product you can provide and then figure out how to scale it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;基于你的特质/能力，思考你能够提供什么产品，然后思考如何能够规模化地交付这种产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Entrepreneur&amp;rsquo;s job is to try to bring the high end to the mass market&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;企业家的工作就将高端产品普及大众化。创造新事物 -&amp;gt; 预测社会需要这个新事物 -&amp;gt; 规模化生产 -&amp;gt; 普及到大众 -&amp;gt; 可盈利可持续&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.互联网极大扩展了职业的可能性(The Internet Has Massively Broadened Career Possibilities)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Internet has massively broadened the possible space of careers, by allowing you to scale any niche obsession.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;互联网极大的扩展了可能的职业空间，它让你可以规模化任何你擅长和痴迷的细分市场。每个人都独一无二，互联网连接每一个人，通过它，你可以为你的产品/天赋/技能，找到足够听众，不管距离多么遥远。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Escape competition through authenticity. No one can compete with you on being you.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过真诚避开竞争。不要模仿，不要复制，每个人都不同，每个人都各有所长，做你自己擅长的事，没有人可以和做自己的人竞争。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.和具有长线思维的人玩长线游戏(Play Long-term Games With Long-term People)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pick an industry where you can play long-term games with long-term people. All returns in life come from compound interest over many turns of the game.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选择一个你能够和具有长线思维的人玩长线游戏的行业。生命中所有的回报(关系/挣钱/学习)都来自于反复游戏后产生的复利效应。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When you switch industries, you&amp;rsquo;re starting over from scratch&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你频繁换行业，那们你就要每次从零开始。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Long-term players make each other rich. In short-term game, it seems like everybody is making themselves rich.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;长期玩家让彼此都致富，短期玩家只顾自己挣钱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.选择聪明，精力充沛和正直的合伙人(Pick Partners With Intelligence, Energy and Integrity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Picking partners with high intelligence, energy and integrity is the three-part checklist that you can&amp;rsquo;t compromise on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选择合伙人如下三点是你不能将就的:
- &lt;code&gt;聪明&lt;/code&gt;: 保证做事的方向正确，勤奋的蠢人很多
- &lt;code&gt;精力充沛&lt;/code&gt;: 聪明的懒人也非常多
- &lt;code&gt;正直&lt;/code&gt;: 这点最重要，没有这点上面两点归零&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Motivation has to come intrinsically. If you&amp;rsquo;re trying to keep someone motivated for the long-term, that motivation has to come intrinsically.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;必须是自激励和自驱动的人。如果你想让某人对某事长期处于激励状态，那么这种激励必须是发自内在的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Integrity is what someone does, despite what they say they do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;考察一个人是否正直，主要看他真正做了什么，而不是他说了什么。注意细微的细节(subtle signals)，当他认为周围没人在看的时候，他的所言所行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People are oddly consistent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然可以短期隐瞒，但人的本性极具有一致性。如果一个人在餐厅对服务员不礼貌，那么他对你不礼貌只是时间问题。如果一个人有报复敌人倾向，那么他把你从朋友重新定义为敌人只是时间问题，你早晚会感受到&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Status Signalling: If you overtly bid for status, if you overtly talk about being high status, that is a low status move.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你过度看重和强调身份地位，你越可能内心自卑。你越讲自己诚实/可靠/正直，情况越可能相反。已有的实在的东西没必要强调，缺乏的虚的东西才需要强调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.和理性乐观者为伍(Partner With Rational Optimists)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t partner with cynics and pessimists. Their beliefs are self-fulfilling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不要和愤世嫉俗和悲观者为伍，他们的信条是自证预言。自证预言者：如果别人失败了，他会说我早就预言会失败，如果别人成功了，他会说这是撞大运。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Either lead, follow, or get out of the way.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要么领导大家，要么跟随领导，要么让开。愤世嫉俗和悲观者，他们不想领导，不想跟随，也不想让开，他们只是无休止散布悲观言论。所有的成功人士都是行动导向的，判断某事是否可行的最简单方式就是行动。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Partner with rational optimists.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;乐观但是要理性，要清楚知道事物的艰难和不利面，但是依然乐观前行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.用特长知识武装自己(Arm Yourself With Specific Knowledge)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Arm yourself with specific knowledge. It can&amp;rsquo;t be trained but it can be found by pursuing your genuine curiosity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用特长知识武装自己。特长知识无法通过培训获得，它只能通过追寻你的单纯的好奇而获得。对特长领域的好奇可能源于先天基因，也可能在儿童时期养成，它构成你后续职业的核心竞争。特长知识几乎无法后天培养，大致20岁以后，个人的特长领域已经初步显现，你需要意识到自己的特长领域，并基于它构建你的职业。很多时候，个人其实并不能清楚认识到自己的特长领域，周围亲近的人反而更清楚。特长知识无法通过培训简单获得，如果社会能够培训你，那么它也能培训其他人，然后取代你&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12.特长知识具有高度创新和技术性(Specific Knowledge Is Highly Creative or Technical)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge tends to be creative or technical. It&amp;rsquo;s on the bleeding edge of technology, art and communication.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特长知识具有高度创新和技术性。它存在于技术/艺术/沟通的前沿。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge can be taught through apprenticeships.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过学徒关系可以获得特长知识。巴菲特(Warren Buffett)和格雷厄姆(Benjamin Graham)是一个典型例子。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge is highly specific to the situation, it’s specific to the individual, it’s specific to the problem, and it can only be built as part of a larger obsession, interest, and time spent in that domain.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特长知识和情景/个体/问题领域高度相关。它只能通过对某个领域的痴迷/兴趣和大量时间的投入才能获得。简单读一本书，上一门课无法获取特长知识，特长知识也无法被编程为一个算法(无法自动化)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t be too deliberate about assembling specific knowledge. Build specific knowledge where you are a natural。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不要刻意追求特长知识(过于目标导向)，找到你内在真正擅长和喜欢的事(你天生就是干这个的料)，然后基于此构建特长知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13.学习销售，学习制造(Learn to Sell, Learn to Build)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Learn to sell. Learn to build. If you can do both, you will be unstoppable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;学习销售，学习制造。如果你两样都会，你将不可阻挡。制造范畴：开发，制造，物流，采购，设计和运营服务。销售范畴：售卖，市场，沟通，招聘，筹钱，激励员工，公关&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Silicon Valley model is a builder and seller&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;硅谷模式=世界级销售+世界级制造。例子，苹果创始人Steve Jobs + Steve Wozniak，微软创始人Gates + Allen，谷歌创始人Larry + Sergey。CEO + CTO组合。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you can do both you will be unstoppable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者兼备可创造整个行业。例子埃隆·马斯克(Elon Musk)，史蒂夫·乔布斯(Steve Jobs), 拉里·埃里森(Larry Ellison/Oracle)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;d rather teach an engineer marketing than a marketer engineering&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;制造者容易转行为销售者(前提沟通能力好)，销售者不易转成制造者。职业早期建议从制造者开始(打下基础)，后期可转行为销售者。制造者需要大量聚焦时间的投入，而且新人新产品始终会推陈出新，所以制造技能难以规模化和保持前沿，销售技能则长期更易于规模化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14.从读你喜欢的书开始，一直到你喜欢上阅读(Read What You Love Until You Love to Read)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;培养大量阅读和终身学习习惯。早期要读原创经典(基础+第一性原理)，以后各类学科都要广泛涉猎&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15.基础是数学和逻辑(The Foundations Are Math and Logic)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现代最重要五项基础技能：&lt;code&gt;阅读&lt;/code&gt;，&lt;code&gt;写作&lt;/code&gt;，&lt;code&gt;算术&lt;/code&gt;，&lt;code&gt;沟通(说服力)&lt;/code&gt;，&lt;code&gt;计算机编程&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16.没有所谓“商业&amp;rdquo;技能(There&amp;rsquo;s No Actual Skill Called &amp;ldquo;Business&amp;rdquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过实践锻炼你的做生意能力，而非纯理论学习。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The number of &amp;ldquo;doing&amp;rdquo; iterations drives the learning curve.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;试错迭代才能快速驱动学习曲线，迭代是不断尝试新的方法，而非重复劳动。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;are willing to bleed a little every day, you may win big later&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;普通大众期望每天能挣一点，企业家则相反，他们愿意承受每天出一点血(比如损失金钱)，但最终可能会赢得更多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17.通过勇于承担风险来获得杠杆(Embrace Accountability to Get Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Embrace accountability. Society will reward you with leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;致富需要杠杆(人力/资金等)。只有建立勇于承担责任和风险的信誉，社会才会回报杠杆予你。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People who can fail in public have a lot of power.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;敢于公开承担失败的人其实非常强大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18.通过勇于承担风险来赢得资产(Take Accountability to Earn Equity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you have high accountability, you&amp;rsquo;re less replaceable and you can get a piece of the business.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你具有勇于承担风险的信誉，别人才会觉得你不可替代，才会把生意/资产交给你。位置越高，承担风险越大，同样受益也可能越大。船要沉没的时候，船长必须最后一个离开。公司破产的时候，员工最先得到工资补偿，然后是银行，最后才是资产投资人(风险最大，收益也可能越大)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Accountability is reputational skin in the game&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;skin in the game是风险共担意思，来自黑天鹅的作者塔勒布的新书《非对称风险》。回报要和风险承担成正比，敢于压上你的声誉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19.劳动力和资本是老式杠杆(Labor and Capital Are Old Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth requires leverage. Labor and capital are older forms of leverage that everyone is fighting for.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;获得财富需要利用杠杆。劳动力和资本是几乎每个人都在竞争的老式杠杆。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Society overvalues labor leverage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当前社会过度看重劳动力杠杆。看职位高低，就看带多少人，看公司实力，就看公司有多少人，实际上看的是能用多大的人力杠杆。
&amp;gt; You want the minimum amount of labor that allows you to use the other forms of leverage.&lt;/p&gt;

&lt;p&gt;劳动力杠杆的劣势：管人并不容易，需要很强领导管理技能；劳动力杠杆竞争非常激烈，一不小心会成为政治斗争或政变中的牺牲品(历史上资本和劳动力之间的斗争从未停止)。所以应该尽量减少劳动力杠杆的使用，你只需少量劳动力，能够支持你使用其它形式的杠杆即可。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Capital has been the dominant form of leverage in the last century.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;资本是上个世纪以来的一种主要的杠杆形式，少数人靠它获得巨量财富，大部分甚至还不懂如何利用它。资本是一种很强大的杠杆，可以转换成其它形式的杠杆(比如劳动力)，资本也易于规模化。运用好资本需要好的资本管理能力和分析技能&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You need specific knowledge and accountability to obtain capital&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要有特长知识和良好的信誉记录，社会才会放心把资本交到你手，以此作为杠杆，让你帮忙挣取更多资本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20.产品和媒体是新杠杆(Product and Media are New Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product and media are the leverage of new wealth. Create software and media that work for you while you sleep.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;产品和媒体几乎没有边际复制成本，是新财富的杠杆。从印刷出版开始 -&amp;gt; 到广播电视媒体开始加速 -&amp;gt; 互联网+代码大爆发。现在，你甚至可以不靠(或只是少量依靠)人力和资本杠杆，就可以放大你的努力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product leverage is where the new fortunes are made&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上一代财富主要靠资本杠杆，典型例子是巴菲特。新一代的财富主要靠代码和媒体杠杆，典型例子杰夫·贝佐斯(亚马逊创始人)，马克·艾略特·扎克伯格(Facebook创始人)，拉里·佩奇(谷歌创始人)，比尔·盖茨(微软创始人)，斯蒂夫·乔布斯(苹果创始人)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Combining all three forms of leverage is a magic combination&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;1.劳动力杠杆：工程师+设计师+产品开发。&lt;/li&gt;
&lt;li&gt;2.资本杠杆: 市场，广告，规模化&lt;/li&gt;
&lt;li&gt;3.代码+媒体杠杆&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三者结合可以产生巨大杠杆效应&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product and media leverage are permissionless&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于劳动力杠杆，别人要愿意跟你才行。对于资本杠杆，要有人愿意投资给你才行。编程/写书/录制播客视频/写博客，所有这些都是不需要许可的，所以说它们是最公平的杠杆。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21.产品杠杆人人平等(Product Leverage is Egalitarian)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Labor and capital are limited to the people who control those resources. But products reach global markets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;劳动力和资本仅限于控制这些资源的人，但是产品可以触达全球市场。产品杠杆是一种正和游戏，如果你在乎要以道德的方式获取财富，你最好使用代码和媒体来创造财富，因为这类产品任何人都可以使用(具有平等属性)，而劳动力和资本则只有少数人能够使用(不平等)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22.寻找一个能够利用杠杆的生意(Pick a Business Model With Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ideally, you should pick a business model with network effects, low marginal costs and scale economies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你最好选择一个具有&lt;code&gt;网络效应&lt;/code&gt;的业务，&lt;code&gt;低边际成本&lt;/code&gt;，并且是&lt;code&gt;经济地规模化&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scale economies: the more you produce, the cheaper it gets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;规模经济&lt;/code&gt;: 生产越多，越便宜。造第12个产品比造第5个产品便宜，造第10000个产品比造前一个要便宜很多，这种方式易于商品化，并且能够自动给竞争者制造障碍&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Zero marginal cost of reproduction: producing more is free&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;零边际复制成本&lt;/code&gt;: 生产更多是免费的，典型例子是媒体产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Network effects: value grows as the square of the customers. Network effect business are natual monopolies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;网络效益&lt;/code&gt;: 价值以客户的平方增长。典型例子: Facebook/Uber/Google/Twitter/YouTube。具有网络效应的业务具有天然垄断(natual monopolies)和赢者通吃(winner-take-all)特性。语言具有网络效应，未来世界可能只有英语和中文两种语言。货币也具有网络效应，未来世界可能只有一种储备货币(目前是美元)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Zero marginal cost business can pivot into network effect business.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;零边际成本的产品-&amp;gt;易于规模化-&amp;gt;易于产生网络效益-&amp;gt;每增加一个用户都会增加整个网络的价值。网络效应是终极杠杆，你选择业务模式的时候一定要思考每增加一个客户，客户之间如何彼此增加价值，然后你躺在海滩上旅游的时候，客户都会自动增加价值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23.从劳工到企业家的案例(Example: From Laborer to Entrepreneur)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The continuum from laborer to real estate tech company goes from low to high specific knowledge, accountability and leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从建筑工人到房地产技术公司的案例，展示特长知识、职责风险承担和杠杆，从低到高的发展历程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laborers get paid hourly and have low accountability&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;底层是建筑工人/水电工等，他们按小时计薪，但承担职责风险最小，社会地位低。他们需要掌握的特长知识很少，除了手头工具没有多少杠杆可用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;General contractors get equity, but they&amp;rsquo;re also taking risk.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二层是总承包商，他们拥有资产，可以利用人力杠杆(承包工队)，可以获得项目收入的大头，但同时承担职责和风险也更多，如果项目失败，他们也要承担大头。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Property developers pocket the profit by applying capital leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第三层是房地产开发商，他们利用资本杠杆获取利润。经验丰富的承包商可能转型为房地产开发商，他们发展出了地产领域的商业敏锐性（知道哪块地皮会增值，政策经济层面因素等)，然后他们有能力找到资本投资(自己也可投资)。这层需要更多特长知识，风险承担和利用资本杠杆的能力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Architects, large developers and REITs are even higher in the stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;建筑师，大开发商由于之前的成功带来的声誉，会让他们更加增值。也有部分转做房地产投资信托，他们同时熟悉房地产和金融/资本市场，他们不用去真正开发房地产，也不用管理很多人，他们可以充分利用资本杠杆。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Real estate tech companies apply the maximum leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最上层是房地产技术公司(类似美国Trulia/RedFin/Zillow这样的公司)，他们可以最大程度利用杠杆。需要同时具备房地产、技术、投资领域的特长知识(一般需要互补团队)，承担职责和风险很高，可以利用的杠杆最大，同时潜在收益也可能最高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24.判断就是决断技能(Judgment Is the Decisive Skill)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In an age of infinite leverage, judgment becomes the most important skill。Leverage is a force multipler for your judgment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在杠杆几乎无限的时代，判断力成为最重要的技能。判断力是基础，杠杆则是判断力的倍增器。职业早期你忙于追逐杠杆，一旦获得杠杆，你需要歇一歇，因为这个时候判断力就更加重要了(因为风险也更大了)。巴菲特如此富有主要是因为他的判断力，即便你把他的钱全部拿走，明天投资者仍然会給他1千亿，因为他的判断力还在&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Without experience, judgment is often less than useless.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;光有高智商还不够，判断力源于快速迭代+实战体验。需要切身投入和切肤之痛(skin in the game)才会产生真正的判断力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The people with the best judgment are among the least emotional&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具有最好判断力的人是最不情绪化的。很多最好的投资人/企业家是近乎毫无情绪的机器人。情绪是真正阻碍你看清事物真相的东西。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The more outraged someone is, the worse their judgment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个人越愤怒，他们的判断就越糟糕。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25.给自己设定一个超高时薪(Set an Aspirational Hourly Rate)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If outsourcing a task will cost less than your hourly rate, outsource it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果外包某项工作所需费用比你的时薪少，那么就外包。对于大部分要花时间的事情，都要和你的时薪比较，再决定是否自己去做。如果致富你是的首要目标，那么你的主要时间都应该投在这件事情上。花费时间和别人争吵，买错小东西自己亲自去退货，都是浪费时间的蠢事。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t penny pinch your way to wealth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于基本的生活所需，你可以节俭，你也可以始终保持低开销，但是对于致富这件事情，你无法通过吝啬来实现。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My aspirational rate was $5,000/hr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我(原文作者)给自己设定的超高时薪是每小时5000美金。如果你给自己设定的超高时薪，看起来还没有到荒谬的程度，那么你设得还不够高。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You should be working on your product and getting product-market fit. And you should be exercising and eating healthy. That&amp;rsquo;s all you have time for while you&amp;rsquo;re on wealth creation mission. ~ Paul Graham(保罗·格雷厄姆)，美国著名程序员、风险投资家、博客和技术作家。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创业者只应该关注和花费时间在：产品，产品和市场契合，锻炼，健康饮食。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26.奋力工作(Work As hard As You Can)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Work as hard as you can. Even Though what you work on and who you work with are more important.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果致富是你的目标(如果只是朝九晚五的上班则另当别论)，那么你必须奋力工作，同时要清楚意识到，做什么工作，和谁一起工作，比努力本身更重要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;正确的工作领域&lt;/code&gt;: 最重要，选择职业或者做生意，先要弄清楚做什么，有没有市场，我能够开发出什么产品，能否发挥我的特长知识，我有没有兴趣能否持续投入&lt;/li&gt;
&lt;li&gt;其次是和&lt;code&gt;正确的人(聪明/精力充沛/正直)&lt;/code&gt;, 和优秀的人一起工作，优秀的标准也要超高(now matter how high your bar is, raise your bar)。&lt;/li&gt;
&lt;li&gt;最后才是&lt;code&gt;努力工作&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Nobody really works 80 hours a week&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有人能真正工作80甚至120小时，这样说的人无非是在身份炫耀。没有人能持续工作80甚至120小时，同时还保持高产出和头脑清醒，你的脑袋会迟钝，灵感缺失。&lt;/p&gt;

&lt;p&gt;在知识领域的高效工作方式是：在灵感和兴趣来的时候，像冲刺一样奋力工作一段时间，然后休息一段更长的时间。这种方式更像猎捕狮子，而不是像马拉松，但长期看，致富的过程是一系列冲刺组成的一个马拉松。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Inspiration is perishable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;灵感容易腐烂。灵感稍纵即逝，灵感点子来的时候要及时抓住，及时动手去做。比如脑中突然来了写博文的灵感，马上动手去写，如果延迟或迟疑，它可能很快消失。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Impatience with actions, patience with results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对行动可以没有耐性(积极行动)，但是对结果要有耐心。灵感来的时候，抓住行动，问题来的时候，不睡觉也要解决。但是产品被市场接受需要很长时间，与人合作磨合也需要很长时间，伟大的产品诞生需要不断的打磨，打磨，再打磨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27.你应该足够忙，没有多少时间去社交(Be Too Busy to &amp;ldquo;Do Coffee&amp;rdquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You should be too busy to &amp;ldquo;do coffee&amp;rdquo;, while still keeping an uncluttered calendar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你应该足够忙，没有多少时间去社交，同时日程表最好空白，换句话说，你应该专注自己的要事，没有时间社交和开会。&lt;/p&gt;

&lt;p&gt;在职业早期的探索(exploring)阶段，你可以参与一些社交和建立一些关系。在职业的中后期利用(exploiting)阶段，你有更重要的事情要做，你必须无情地将会议从你的生活中剔除。&lt;/p&gt;

&lt;p&gt;如果某人要和你开会，你就问能否用电话代替。如果某人要和你电话沟通，你就问能否用电子邮件代替。如果某人想要发电子邮件给你，你就问能否用短信代替，实际上到这一步，大部分短信都是可以忽略的，除非是真正紧急的事情&lt;/p&gt;

&lt;p&gt;你应该无情地拒绝会议。如果真的要开会，就边走边谈，或站着谈。让会谈保持简短，保持行动导向(actionable)。大部分超过8个人的圆桌会议，不会有任何产出，你基本上浪费至少一个小时。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People will meet with you when you have proof of work&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你手头真有重要和有价值的产品，可以考虑找合适的人会谈合作。找重量级投资人谈，你必须先有工作证明(proof of work，区块链术语)，也就是你实际开发的产品或者项目进度，而不是ppt，更不是脑袋里的想法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Networking is overrated even early in your career&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便在职业早期，社交的作用也被夸大了。通过社交手段建立人脉获得机会，表面上看如此，实际这种机会顶多是第一(撞大运)和第二类(奋力争取带来的好运)。你应该把重点放在第三(积极准备带来的好运)和第四类(独特个性带来的好运)，专注建立声誉，开发产品，建立独特视角，善于发掘机会(在别人还没看到时)。&lt;/p&gt;

&lt;p&gt;忙碌的日程表和忙碌的脑瓜，做不了伟大的事情。自由的时间和思考，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28.不断重新定义你的工作(Keep Redefing What You Do)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Become the best in the world at what you do. Keep redefining what you do until this is true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在你专注的工作上做到世界最佳，不断重新定义和打磨你的工作，直到世界最佳成真。这个工作必须和你的特长知识/技能/职位/能力/位置/兴趣相匹配(遵循自己的内心，being authentic to yourself)，探索之旅会很漫长，但你始终要意识这点。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Find founder-product-market fit&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;企业家最重要的事：找到有&lt;code&gt;市场&lt;/code&gt;的&lt;code&gt;产品&lt;/code&gt;，而且你天生&lt;code&gt;擅长&lt;/code&gt;干这事，三者缺一不可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29.通过做自己避开竞争(Escape Competition Through Authenticity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Competition will trap you in a lesser game&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;受到社会上身份地位游戏的影响，我们容易追逐模仿而迷失自我。如果周围的人都是成功的商务人士，我也要成为商务人士。如果我周围的人都是成功的社会活动家，我也要成为社会活动家。如果我周围的人都是成功的架构师，我也要成为架构师。实际上这种追逐模仿更多是一种零和竞争游戏。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No one can complete with you on being you&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有人能够和做自己的人竞争，做你最擅长的事，基于你的特长知识打造你的核心竞争。同时也要注意产品和市场匹配问题(product-market fit)，如果真实做自己，但是市场不大，你也要注意调整。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In entrepreneurship, the masses are never right&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从企业视角看，大众判断往往不正确。如果大众判断正确，那么大家早就发财致富了。如果大众都在谈论某个领域或产品，那么恰恰说明这个领域的竞争趋于饱和，已经没有多少机会了。相反，如果没人谈论某个领域，则可能这个领域的机会也不大。企业家需要在两者之间找到平衡。大部分人倾向模仿追逐热点，伟大的企业家倾向真实做自己。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Combine your vocation and avocation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最好将自己的事业和爱好结合起来，这样的人更容易做自己。经过不断尝试，很多人最终会找到自己最擅长的事业。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30.玩愚蠢的游戏，赢愚蠢的奖励(Play Stupid Games, Win Stupid Prizes)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Competition will blind you to greater games. You&amp;rsquo;re one step away from a better market.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;热衷模仿竞争会蒙蔽你的双眼，陷入零和游戏，让你迷失自我。真实面对自己和客户才能找到更好市场。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31.最终你会获得你应得的（Eventually You Will Get What You Deserve）&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Apply specific knowledge with leverge and eventually you will get what you deserve.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果满足特长知识，责任心，利用杠杆和真实做自己这些先决条件，那么从足够长的时间范围来看，你最终会获得回报。这个通常需要十年甚至二十年，也有快的三五年的，但是这种是例外。期间你会经历很多失败，但在企业界，有时往往做对一次就够了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are you really good at that the market values?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;致富要素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.特长知识的稀缺性&lt;/li&gt;
&lt;li&gt;2.能够利用多大的杠杆&lt;/li&gt;
&lt;li&gt;3.判断力的准确度&lt;/li&gt;
&lt;li&gt;4.责任心强度&lt;/li&gt;
&lt;li&gt;5.所做事情的社会价值多大(product market fit)&lt;/li&gt;
&lt;li&gt;6.持续投入时间+持续学习改进&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;核心:&lt;/code&gt; 你擅长(特长知识)+社会需要(product market fit)，其它自然会来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;32.拒绝大部分建议(Reject Most Advice)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Most advice is people giving you their winning lottery ticket numbers. The best founders listen to everyone but make up their own mind.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你问那些速成人士是如何获得成功的，他们可能只是告诉你他们中奖的彩票号码(也就是说，你得到的建议往往只适用于特定的人和特定上下文环境)，可能完全不适用于你和你的环境。你应该关注系统，而非单一目标，也就是什么的系统或者说环境，才促成了某些人的成功。盲目生搬硬套只会适得其反。&lt;/p&gt;

&lt;p&gt;真正的创始人会聆听所有人的视角和建议，但是在最后做决策时，他会忽略所有人，而是根据自己的系统和上下文做决定。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Advice is maxims you can recall later, when you get your own experience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓建议可以认为是一种格言，也就是你有了自己体验之后，你能回忆起来并能对上号的格言。本文的35条建议也是35条格言，我(原文作者)碰到问题时也时常会回顾这些格言，作为我的处事指导，比如是否要和某人一起共事，如果我不能和他一起共事10年(长线游戏)，那么我何必要和他共事一天？如果你看过建议以后有体验共鸣，那么对你就要价值；如果你无感，那么请忽略，继续做自己的事就好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;33.平和的内心，健康的身体和充满爱的家庭(A Calm Mind, a Fit Body, a House Full of Love)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When you&amp;rsquo;re finally wealthy, you&amp;rsquo;ll realize it wasn&amp;rsquo;t what you were seeking in the first place.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当你某天最终变得富有，你会意识到这其实并不是你最初的追求。钱只能解决你钱的问题(获得一定的物质世界的自由度)，但是内心的平静，健康的身体，和谐有爱的家庭，这些靠钱买不来，这些也要靠你去挣取，不可偏废。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34.致富没有捷径(There Are No Get Rich Quick Schemes)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Get rich quick schemes are just someone else getting rich off you.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓的致富速成，往往是别人想从你身上挣钱的把戏。世界是一个高效之地，如果有容易挣钱的地方，那么这个地方早就被探索和利用过了。&lt;/p&gt;

&lt;p&gt;另一方面，作为专家或成功人士，可以给其他人一些(高质量和可执行的)致富建议，同时要坦承过程漫长且艰难，否则会毁掉自己的声誉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;35. 将自己产品化(Productize Yourself)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Figure out what you&amp;rsquo;re uniquely good at and apply as much leverage as possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找到你擅长的事业，并尽可能利用杠杆。Productize Yourself，把独特的你和你的特长知识进行产品化，勇于承担风险，真实面对自己，充分利用杠杆规模化你的产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Making money isn&amp;rsquo;t even something you do, it&amp;rsquo;s not a skill. It&amp;rsquo;s who you are.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做最真实的自己，&lt;code&gt;挣钱并不是关于你做的事情，也不是一种技能，而是你到底是谁的问题。&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Find hobbies that make you rich, fit and creative&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;挣钱是一个函数，输入是你的身份和你的爱好。找到你的三个爱好，一个让你挣钱，一个让你健康，一个让你富有创造力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2019年总结之瞎扯淡</title>
      <link>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E7%9E%8E%E6%89%AF%E6%B7%A1/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E7%9E%8E%E6%89%AF%E6%B7%A1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;大胡子&lt;/code&gt;是我特别佩服的一位老师，第一次知道他是17年偶尔一次线上讲座，具体题目忘记了，内容大概是关于&amp;rdquo;技术人如何赚钱&amp;rdquo;，很real，告诉一些晚辈如何赚钱，以及拥有一些赚钱思维，我觉得这个真的很酷。后来才了解到他的&lt;code&gt;疯人院&lt;/code&gt;和星球，所以立马入会，所幸会费不是很高(这要是再高个几百的，当时的我是肯定不会去&amp;rdquo;割韭菜&amp;rdquo;社群)。不过，在这两年里，虽然不曾在社群发表自己的观点，但是通过群里各种大牛、前辈们的探讨，在加上自己的思考，也的确让自己再技术之外成长了很多，所以，在这里我向大家极力推荐大胡子老师，他的公众号是&lt;code&gt;姜胡说&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;年初了，总该总结总结过去一年的成长和收获，也该去梳理梳理新一年的征程如何走下去，这里有一篇胡子老师的文章，觉得很有意思，感兴趣的可以去仔细读读&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIxMjE4NzM5MA==&amp;amp;mid=2651785933&amp;amp;idx=1&amp;amp;sn=867e1c2e54dc124d60d9ad3c7a759a49&amp;amp;chksm=8cb24b5cbbc5c24a7a3f51f882e2a8c13f05312bdf33d5a5e03e52ea89eb818b32dfad65a43b#rd&#34;&gt;早知道这个，我至少可以少奋斗3年&lt;/a&gt;，虽然有点标题档了，但不妨碍这依然是一篇值得看和值得思考的文章.&lt;/p&gt;

&lt;p&gt;以下摘录几个观点，用于鞭策自己:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Stay hungry,Stay foolish&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Stay hungry,Stay foolish!&lt;/code&gt;是乔布斯老爷子在斯坦福大学大学演讲时结尾的一句话，翻译过来即为&amp;rdquo;求知若饥，虚心若愚&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;记得那个时候我还在上大学，乔老爷子的自传以及演讲都那么激动人心，我还曾经将&lt;code&gt;Stay hungry,Stay foolish!&lt;/code&gt;作为我的微信签名，直到后来我懂得了做的重要性，才将微信签名换成如今的&lt;code&gt;Never try,Never known!&lt;/code&gt;。要说&amp;rdquo;Stay hungry,Stay foolish&amp;rdquo;是内在修养的话，那么&amp;rdquo;Never try,Never known&amp;rdquo;就是外在表现，我们要一直对外保持不断的好奇心，不断尝试，只有不断尝试，我们才会发现我们是多么的无知，而当你长时间处于无知状态时，往往会被别人远远的甩在最后。&lt;/p&gt;

&lt;p&gt;所以，&lt;code&gt;当你对这个世界失去了敬畏和好奇心时，你就一定会落后&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;落后就肯定会挨打，我相信从小到大大家都不愿成为挨打的那个人。&lt;/p&gt;

&lt;p&gt;那该怎么办呢？我在&amp;rdquo;Stay hungry,Stay foolish&amp;rdquo;的后面再加一个&amp;rdquo;Never try,Never known!&amp;ldquo;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stay hungry: &lt;code&gt;保持对知识的敬畏，保持对这个世界的好奇心&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Stay foolish: &lt;code&gt;接触到新事物时，不要让固有的观念影响自己。真正强大的人，允许自己的大脑里同时存在两种或者两种以上完全相反的声音。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Never try,Never known: &lt;code&gt;不去尝试，永远不知道这个世界本身的运行机制，当你知道再多也不去尝试仍然是不知道&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.技不压身&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像我们搞运维的，最早之前可能会比较熟悉使用Linux，然后擅长Linux环境下一些常用服务的规划和实施，并且能够尽快排查故障和问题。在我刚开始从业的一段时间，我一度有点茫然，纠其原因是因为运维这个行业，起码像我上面提到的这个定义，其实任何一个有相关技术背景，并且本身还算是一个靠谱的人，及时对运维一点儿也不懂，如果有运维的活儿，那他也一定可以完成，不过就是多花点时间多花点儿精力而已。&lt;/p&gt;

&lt;p&gt;所以，我那个时候在想，作为一个运维从业者，未来将如何破局。这就跟一两年前同行相遇都会问&amp;rdquo;我们搞运维的，要不要去学点开发啊&amp;rdquo;，到目前为止，我想市面上应该再没有不懂开发的运维了吧。至少你写个Python、Shell、Perl脚本是最基本的吧,再有甚者可能还会对运维有Golang或者Java开发的能力的要求。&lt;/p&gt;

&lt;p&gt;那我想说的也是:&lt;code&gt;多了解一些其他技术，对运维，甚至是其他事情都会有莫大的好处&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这两年我也因此去多学习了一些其他技术，比如&lt;code&gt;Golang、Vue、基于Hadoop体系的大数据处理&lt;/code&gt;，虽然在这几个方面都不是很深入，也不是很资深，但此时作为一个运维从业者来说，或者想要成为一个更加优秀的运维从业者来说，这些技能都是非常有帮助的。&lt;/p&gt;

&lt;p&gt;2020年，我会在巩固常用技术的基础上再去多拓展一些技术，比如&lt;code&gt;Rust&lt;/code&gt;或者&lt;code&gt;JavaScript&lt;/code&gt;之类的，毕竟2020年都要实现全面建设小康社会了，我们自身的技能也应该再全面一些不是么？&lt;/p&gt;

&lt;p&gt;有些人可能就会说了，学那么多技术，也不一定用的上，其实古人有句话就是&amp;rdquo;书到用时，方恨少&amp;rdquo;，很多时候我们在不断学习和了解的过程中并不一定是在未来一定要用它，而是&lt;code&gt;用整个经历来还原他人决策的依据&lt;/code&gt;，让你能够以更贴近他人的角度去理解一件事，更何况万一在未来用上了，不是也不用去求他人了不是。&lt;/p&gt;

&lt;p&gt;这个时候，可能还会有人说了，我想去学习一些先进的技术，但是在国内网站上都无法找到，而且信息杂乱。其实，只要你确定了要去学习一些新技术，那怎么学就不是那么重要了，毕竟&lt;code&gt;做什么比怎么做更重要&lt;/code&gt;，是吧，只要目标明确，就一定能找到对应的途径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.知识获取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接着上面说到的，我想学习一门新技术，我该如何去学习呢？&lt;/p&gt;

&lt;p&gt;我的建议其实如同大胡子老师的观点，一定要吸收&lt;code&gt;最原始的知识&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一定要&lt;code&gt;拒绝二手知识。更何况是三手、四手。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前两天，偶然在群里看到有小伙伴说&amp;rdquo;现在就是照着网上的配置抄，然后埋大bug&amp;rdquo;。现实可能的确是这样的，因为大家时间都很宝贵，遇到问题也都着眼于解决眼下&amp;rdquo;问题&amp;rdquo;，所以对于本质问题也少有人会追根溯源了。这就是典型的多手知识，目前网络上充斥着各种良莠不齐的文章，我们可能不了解别人的场景，也不了解问题的上下文，照抄别人的配置，可能是暂时解决问题了，也许也埋下了一个祸根，但终究对于我们个人而言，没有任何成长。&lt;/p&gt;

&lt;p&gt;胡子老师在那篇文章说:
&amp;gt; 读书这种事很美妙。
&amp;gt; 思考也是。
&amp;gt; 不要让他人剥夺走。
&amp;gt; 获取一些有养料的知识。
&amp;gt; 不仅仅是读书。&lt;/p&gt;

&lt;p&gt;我们搞技术的人，大多数场景都在使用开源技术构建产品，所以在成长的路上我们完全可以阅读那些&lt;code&gt;官方文档&lt;/code&gt;，及时那些英文官方文档不那么容易理解，我也依然建议去阅读官方文档，起码在核心问题上，要比那些多手翻译的官方文档要好很多。再者，我们如果有时间和经历，其实是可以针对核心逻辑去阅读源代码来追溯源头。&lt;/p&gt;

&lt;p&gt;到现在为止，我在工作上遇到的任何技术问题，如果是开源组件，我都会第一时间去&lt;code&gt;GitHub&lt;/code&gt;或&lt;code&gt;Google&lt;/code&gt;上查找官方文档，当然我也会借鉴一些多手翻译的官方文档(毕竟英语水平不咋地)。&lt;/p&gt;

&lt;p&gt;当然这里并不是想说是怎么去获取知识的，而是一种思维模式，即&amp;rdquo;对于知识，我们一定要思考要不要去学习，然后找到一手渠道去学习最原始、最纯的知识&amp;rdquo;。知识其实是无处不在的，我们需要的是有鉴别知识的能力.&lt;/p&gt;

&lt;p&gt;然后，&lt;code&gt;基于需求或者人类的社会动机将那些想法进行分类整理&lt;/code&gt;。 这句话也是胡子老师文章中的，很有感触。将我们学到知识进行分门别类，仔细想想，&lt;code&gt;一个不能和人类需求和社会动机联系在一起的知识，它可以用在什么地方呢？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以尝试思考一下:
&amp;gt; 这条信息主要覆盖哪个团体和人群？
&amp;gt; 这个想法代表了哪些深层的人类需求和行为？
&amp;gt; 这件事有趣的地方在哪里？
&amp;gt; 别人是怎么做的？
&amp;gt; 不同团体之间他们互相是如何做的？&lt;/p&gt;

&lt;p&gt;最后，依然以大胡子老师的话结尾。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;观察生活中既有的生活方式,
和那些新鲜事物做对比。看看发生了什么。
最后&lt;code&gt;把所有的问题全部回归到人类的需求和社会动机上来。&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;人活着都有什么需求，你考虑了，别人没考虑，那，这就是你和别人的差距。&lt;/p&gt;

&lt;p&gt;劳心者制人，劳力者制于人，这才是自然规律。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2019年总结之财务投资</title>
      <link>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E8%B4%A2%E5%8A%A1%E6%8A%95%E8%B5%84/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E8%B4%A2%E5%8A%A1%E6%8A%95%E8%B5%84/</guid>
      
        <description>&lt;p&gt;18年的时候，我在个人公众号&lt;code&gt;BGBiao&lt;/code&gt;上写了一篇关于如何&amp;rdquo;选鸡&amp;rdquo;的文章，大概介绍下了作为一名不了解投资和没有投资经验的人如何选一只性价比较高的基金，感兴趣的同学可以回顾下&lt;a href=&#34;https://mp.weixin.qq.com/s/swAOiIT-tWkpC0wa24C51Q&#34;&gt;门外汉如何选择一只&amp;rdquo;鸡&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;作为一个在IT行业工作的人来说，我认为非常有必要提前考虑个人的投资和理财计划，毕竟年轻时的高薪和高强度工作很容易让你在后面很多年感觉到无所适从，因为随着年龄的增大，持续高薪的工作并不好找，而且高强度的工作，也可能没有小伙子们的那种撑劲儿，所以，提前规划自己的理财和投资，我个人觉得还是蛮重要的。&lt;/p&gt;

&lt;p&gt;2019年即将结束，回想一下自己过去一年的&amp;rdquo;选鸡&amp;rdquo;经历，还是想在这里总结一下，并希望和期待今后能够做的更好，同时也希望将自己总结的几个点分享出来。&lt;/p&gt;

&lt;p&gt;先晒一下过去一年入仓的一些&amp;rdquo;鸡&amp;rdquo;以及整体的收益状况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaf2h7cjwyj30cn29cn1y.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.基金投资如何开户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;购买基金一般可以从基金公司官网、银行、以及第三方基金销售平台购买。&lt;/p&gt;

&lt;p&gt;不过通常情况下，我都会在第三方App上进行投资，比如我会使用&lt;code&gt;支付宝&lt;/code&gt;和&lt;code&gt;天天基金网&lt;/code&gt;来进行基金投资，一个是因为方便和权威，并且基金的种类也特别丰富，另外一个原因是在这些平台上通常都会有较低的费率(通常有1折优惠)。&lt;/p&gt;

&lt;p&gt;有些人可能会问，为什么同时使用两个软件进行基金投资，其实最早是因为刚工作那会，支付宝有余额，想着可以通过一种理财策略来省钱，但是又不甘心余额宝那么低的收益，所以当16年左右，支付宝刚开始推出&amp;rdquo;一天10块钱，轻轻松松做理财&amp;rdquo;时，就买了些基金，并一直观察持有，且不断加仓(搞理财的都知道，频繁换手其实是非常不利的，所以既然认定了一只好鸡，索性就一直将这只鸡重仓在支付宝了).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;天天基金网&lt;/code&gt;是在我开始玩基金一段时间后，向一个在银行从业的朋友那了解到的，当时是想象她请教如何选鸡，如何交易，所以后面更多就使用该软件来进行交易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.投资基金应该如何配置基金&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基金其实分很多种类，在之前的文章中，我好想写过，比如说有纯债基金，混合基金，指数基金，股票型基金等等。&lt;/p&gt;

&lt;p&gt;通常情况下来讲，混合基金，要看基金经理本身的能力，这个需要有一定的经验去挑选基金经理。&lt;/p&gt;

&lt;p&gt;如果想简单操作，搭配纯债基金+指数基金，这个方案也是没问题的。&lt;/p&gt;

&lt;p&gt;不过在我入仓的一些基金里，大部分都是股票型基金，当然了风险也会相对的比较高，因此对于该基金背后的团队，以及基金经理还有所持有的股票都需要有一定的了解，相对于普通人来说会有一定的难度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.如何入仓&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的建议是通过&amp;rdquo;基金定投&amp;rdquo;来入仓和不断加仓。&lt;/p&gt;

&lt;p&gt;因为使用基金定投从长远角度来考虑可以将整体的风险降低，并且可以不断的累计自己的基金池。&lt;/p&gt;

&lt;p&gt;相反，如果是追涨杀跌，看着基金涨了就想多买点，这会影响定投摊平风险的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建议在刚开始玩基金时，不要对收益有太大的幻想，因为任何成长都需要有成本的，不论是资金成本还是时间成本或者知识成本，但是如果选择定投基金，从长远角度是肯定会存储一笔资金的。另外，对于基金的买卖一定要沉住气，切勿&lt;code&gt;追涨杀跌&lt;/code&gt;，在我个人刚开始玩基金时，会频繁根据涨跌情况去调仓，后面会发现其实很多调仓都会出现反涨的情况，再加之费率的问题，其实整体会很不划算。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips: 其实还有另外一个技巧就是，当你看好一只基金时，除了定投之外，也可以定期的去看基金一天的估价，通常情况下，在交易日下午三点前会是一个相对稳定的估价，此时可以做一些类似买跌类的操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先简单分享到这里，业余玩鸡，2020年一起进步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexzwmo1wj30j60pa40b.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CronJob控制器中的一些绕坑指南</title>
      <link>https://bgbiao.top/post/cronjob%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E5%9D%91%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/cronjob%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 作为企业里唯一熟悉各种云产品的工种，通常需要和各种云产品打交道。当前，我们大部分的云基础设施和云服务都运行在阿里云上，而每个云产品都有独立的管理系统，这使得我们在运维过程中经常无法将相关产品和关联信息有效的组织在一起，来进行快速的问题诊断和信息查询，这对于运维和开发同学来说，在多个系统之间来回跳转查找关联信息是一个低效且极易出错的事务，因此通常来讲，不论是作为运维和开发，我们都希望将企业关联的云资源和服务进行整合关联，以实现效率的最大化。而在这过程中，我们采用Kubernetes集群的CronJob来定期获取阿里云的一些资源，在这过程中，遇到一些问题，根据问题重新细读CronJob官方文档，特记录于此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CronJob简单介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;CronJob&lt;/code&gt;对象就像是一个Linux环境的&lt;code&gt;crontab&lt;/code&gt;文件一样，它会在给定的调度周期(crontab格式)内定期的创建一些job.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;所有的定时任务的调度周期都依赖于k8s的master节点的时区&lt;/p&gt;

&lt;p&gt;通常情况下，CronJob对于创建定期和重复的任务非常有用，比如定期的备份和邮件发送之类的任务场景。&lt;/p&gt;

&lt;p&gt;当然了，在Kubernetes集群中，Cronjob也有一些局限性和特性，需要详细了解下才能用的比较好。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: Cronjob控制器当前官方仍然是beta版本，也就意味着还是有一些问题存在的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cronjob的局限性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个Cronjob会在它每执行一次调度就&lt;code&gt;大概&lt;/code&gt;会创建一个Jobs对象。&lt;code&gt;大概&lt;/code&gt;是因为有时候可能会有两个job被创建，或者没有任务创建。
官方实现中尝试去解决这种问题，但是目前仍然无法避免。因此在设计过程中，所有的Job都应该是幂等性的(idempotent)&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数被设置为一个比较大的值，或者没有设置(默认)，并且&lt;code&gt;concurrencyPolicy&lt;/code&gt;设置为&lt;code&gt;Allow&lt;/code&gt;，那么Job总是会运行至少一次。&lt;/p&gt;

&lt;p&gt;对于每一个Cronjob来说，&lt;code&gt;CronJob&lt;/code&gt;控制器会检查从上一次调度时间到现在的持续时间内它错过了多少个调度，如果错过调度100次，它将不再执行调度，并且会有如下相关异常.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cannot determine if job needs to be started. Too many missed start time (&amp;gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值得关注的是，如果设置了&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数(不为空),控制器统计错过的调度次数将不再是从最后一次调度时间，而是
从&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;的值到现在进行统计。比如，如果设置&lt;code&gt;startingDeadlineSeconds:200&lt;/code&gt;,控制器会统计在最后200秒内错
过了的调度次数。&lt;/p&gt;

&lt;p&gt;如果CronJob未能在预定时间创建，则该任务将被视为错过调度。比如，当设置&lt;code&gt;concurrencyPolicy: Forbid&lt;/code&gt;时，当前一个任务还在运
行时CronJob尝试再次被调度，此时会被&lt;code&gt;forbid&lt;/code&gt;掉，因此也会被记录为错过一次调度。&lt;/p&gt;

&lt;p&gt;再比如，我们假设一个定时任务被设置在&lt;code&gt;08:30:00&lt;/code&gt;后每一分钟执行一次，并且&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数没有被设置。如果CronJob控制器在&lt;code&gt;08:29:00&lt;/code&gt;到&lt;code&gt;10:21:00&lt;/code&gt;之间故障了，Job将不会运行，因此错过调度的任务数量将远超过100。&lt;/p&gt;

&lt;p&gt;为了更深层次说明这个问题，假设一个定时任务被设置在&lt;code&gt;08:30:00&lt;/code&gt;开始每一分钟执行一次，并且&lt;code&gt;startingDeadlineSeconds:200&lt;/code&gt;。如果CronJob控制器依然在相同时间段故障了，Job将会在&lt;code&gt;10:22:00&lt;/code&gt;开始继续执行。 因为控制器仅会计算在过去的200秒内，错过调度的
次数有多少，因此仅会错过调度3次，远远小于100次，所有定时任务会在控制器恢复后继续调度，而不会影响正常的任务。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，CronJob仅负责调度和创建匹配的Jobs，而由Jobs真正去管理真正执行任务的Pods。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cronjob的参数详情&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;spec.startingDeadlineSeconds&lt;/code&gt;: 表示统计错过调度次数(100次)的开始时间，默认从最后一次调度时间开始统计错过调度次数(超
过100不再调度)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.concurrencyPolicy&lt;/code&gt;: 并发调度策略，可选值:{&amp;ldquo;Allow&amp;rdquo;:&amp;ldquo;允许并发&amp;rdquo;,&amp;ldquo;Forbid&amp;rdquo;:&amp;ldquo;不允许&amp;rdquo;,&amp;ldquo;Replace&amp;rdquo;:&amp;ldquo;调度覆盖&amp;rdquo;}.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Allow&lt;/code&gt;: &lt;code&gt;注意:&lt;/code&gt;当设置为&lt;code&gt;Allow&lt;/code&gt;时，需要考虑到任务执行时间和调度周期，因为可能上个任务没执行成功，下个任务就到执行时间了，如此下来可能会有很多任务都执行积压，造成资源误使用;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Replace&lt;/code&gt;: 当使用&lt;code&gt;Replace&lt;/code&gt;遇到上述情况，后个任务会将前一个任务替换掉，如此以来所有的任务可能都不会完整执行;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Forbid&lt;/code&gt;: 则不允许并发调度，也即就调度一次，下一次调度周期再调度，但是可能由于任务执行过长，导致大部分的任务在每一
次调度时间都完美的错过了，此时&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数也并没有设置，就可能会出现该任务不会再调度，对应到k8s里的事
件可能是&lt;code&gt;Cannot determine if job needs to be started: too many missed start time (&amp;gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.schedule&lt;/code&gt;: 调度周期，格式为标准的crontab格式[分 时 日 月 周]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.failedJobsHistoryLimit&lt;/code&gt;: 历史失败的任务数限制(通常可以保留1-2个，用于查看失败详情，以调整调度策略)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.successfulJobsHistoryLimit&lt;/code&gt;: 历史成功的任务数限制(可以自己决定保留多少个成功任务)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.jobTemplate&lt;/code&gt;: 标准的pod运行的模板(容器运行时的相关参数)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.suspend&lt;/code&gt;: 可选参数，如果设置为&lt;code&gt;true&lt;/code&gt;,所有后续的任务都会被暂停执行，该参数不适用于已经运行的任务，默认为False&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CronJob示例&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 配置了一个定期去阿里云云解析获取解析详情的数据
$ cat dnsall-cronjob.yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  labels:
    run: dnsall
  name: dnsall
  namespace: myapp
spec:
  # 强烈建议设置并发策略，根据调度周期和任务特性进行设置
  concurrencyPolicy: Forbid
  # 强烈建议设置失败任务数，用于排查任务失败根因，以优化任务
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 3
  # 强烈建议设置错过调度的计算时间
  startingDeadlineSeconds: 600
  # 调度周期
  schedule: &#39;05,15,25,35,45,55 */1 * * *&#39;
  suspend: false
  jobTemplate:
    metadata:
    spec:
      template:
        metadata:
          labels:
            run: dnsall
        spec:
          imagePullSecrets:
          - name: mydocker
          containers:
          - args:
            - -cmdbtype
            - dns
            image: harbor.bgbiao.top/cron-job:2019-12-04
            imagePullPolicy: Always
            name: dnsall
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
          dnsPolicy: ClusterFirst
          # 强烈建议设置任务的重启策略(任务的失败会触及到Jobs控制器中的Backofflimit参数，导致job失败)
          restartPolicy: OnFailure
          schedulerName: default-scheduler
          securityContext: {}
          terminationGracePeriodSeconds: 30

$ kubectl  get cronjob -n myapp
NAME             SCHEDULE                      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
dnsall           05,15,25,35,45,55 */1 * * *   False     0        8m41s           23h

# cronjob其实定期的创建了job，因此具体的任务pod其实是由job控制器来维护的
# 这里可以看到，我们上面的cronjob保存的三个执行成功的任务
$ kubectl  get jobs -n myapp  | grep dns
dnsall-1577597100           1/1           23s        22m
dnsall-1577597700           1/1           24s        12m
dnsall-1577598300           1/1           24s        2m22s

# 再查看一个job真正管理的pod任务的执行
# 任务已经已完成，所以任务的期望值为1，当前值为0
$ kubectl  get pods -n myapp | grep dnsall-1577598300
dnsall-1577598300-hdl4z           0/1     Completed   0          3m29s

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>软件工程师们必须了解的画图工具</title>
      <link>https://bgbiao.top/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%AC%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%AC%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;作为一名在IT行业摸爬滚打多年的少年，选择一款适手的画图工具可以说是爽到不行。记得学生时代，鉴于条件的限制，都只能选择Visio进行绘制流程图、类图、UML图等，但是微软家的东西，大家也懂。特别是作为一名长期混迹在开源世界的从业者，我们都喜欢使用一种免费且好用的替代方案来完成日常的工作需求。比如&lt;code&gt;Markdown&lt;/code&gt;就基本上成功替代了&lt;code&gt;Document&lt;/code&gt;去编写文档，然后&lt;code&gt;Xmind&lt;/code&gt;、&lt;code&gt;ProcessOn&lt;/code&gt;、&lt;code&gt;Draw&lt;/code&gt;之类的工具基本上也可以实现对&lt;code&gt;Visio&lt;/code&gt;的替代，当然我这里仅说的是我个人遇到的情况，不能以偏概全，微软家的很多产品也依然是不错的。接下来像大家推荐几个常用的画图工具.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;在线类产品&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.processon.com/&#34;&gt;ProcessOn&lt;/a&gt;: 很好用的产品，但是对于免费用户来说可保存的文件有限&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuque.com/&#34;&gt;语雀&lt;/a&gt;: 阿里开源的一个在线知识写作平台，个人免费用户基本没什么限制，其中有个实验室功能，可以在线使用&lt;code&gt;PlantUML&lt;/code&gt;语法绘制各种图(流程图，时序图，UML图等)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://online.visual-paradigm.com/cn/&#34;&gt;Visual-paradigm&lt;/a&gt;: 和ProcessOn类似&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://draw.io/&#34;&gt;Draw&lt;/a&gt;: 开源免费的在线绘图(需要使用谷歌账号进行注册登录,不过既然开源是可以私有化部署，支持各种客户端)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;draw相关地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_33929309/article/details/91609993&#34;&gt;参考文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.elkpi.com:8080/draw/&#34;&gt;国内在线draw&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jgraph/drawio&#34;&gt;draw开源地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jgraph/drawio-desktop&#34;&gt;draw客户端&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Goroutine与主进程的通信</title>
      <link>https://bgbiao.top/post/goroutine%E4%B8%8E%E4%B8%BB%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Fri, 13 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/goroutine%E4%B8%8E%E4%B8%BB%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1/</guid>
      
        <description>&lt;p&gt;还记得前半年去某条面试，面试小哥问我，当一个进程启动多个goroutine时，某个goroutine挂了，如何让主进程知道，当时大概知道可以通过&lt;code&gt;context&lt;/code&gt;这个包来实现，但是当时没有具体去了解和熟悉这块，在这里再总结下。&lt;/p&gt;

&lt;p&gt;子goroutine与主线程同步的集中方式:
- &lt;code&gt;channel&lt;/code&gt;: 每个goroutine往主进程的&lt;code&gt;chan&lt;/code&gt;写数据，然后由主进程去读取，直到读取完了全部goroutine的&lt;code&gt;chan&lt;/code&gt;就算运行完毕，此时主进程即可正常退出。这种方式是子线程通知主线程结束.
- &lt;code&gt;context&lt;/code&gt;: 使用&lt;code&gt;context&lt;/code&gt;中的&lt;code&gt;cancel&lt;/code&gt;，这种模式是主线程通知子线程结束
- &lt;code&gt;sync.WaitGroup&lt;/code&gt;: 通过&lt;code&gt;Add&lt;/code&gt;方法设置等待子goroutine的数量，使用&lt;code&gt;Done&lt;/code&gt;方法设置等待子goroutine的数量减1，当等待数量为0时，&lt;code&gt;Wait&lt;/code&gt;函数退出.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.通过channel实现同步&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat channel-sync.go
package main
import (
    &amp;quot;fmt&amp;quot;
)
// 通过向主进程中的channel来和主进程进行通信
func subTask(c chan int) {
    defer close(c)
    for i :=0;i&amp;lt; 10;i++ {
        c &amp;lt;- i
    }
}

func main() {
    isok := make(chan int,10)
    go subTask(isok)
    // 通过channel来让子goroutine和主线程共享内存(通过通信实现共享内存)
    for v := range isok {
        fmt.Println(v)
    }
}
$ go run channel-sync.go
0
1
2
3
4
5
6
7
8
9

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;**2.context方式传递数据给主线程 **&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat context-sync.go
package main
import (
    &amp;quot;context&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func subTask(ctx context.Context) (chan int) {
    dst := make(chan int)
    n := 0
    go func() {
				// 通过使用select执行和channel相关的IO操作(类似switch)
				// select关键字其实是go并发模型中比较重要的
        for {
            select {
                case &amp;lt;- ctx.Done():
                    return
                case dst &amp;lt;- n:
                    n++
            }
        }
    }()
    return dst
}

func main() {
    ctx,cancel := context.WithCancel(context.Background())
    defer cancel()

    // subTask中其实是一个死循环会不断将n自增并返回到dst
    testChan := subTask(ctx)

    for n := range testChan {
        // 主进程通过chan中的值控制并发？然后通过cancel()来通知子routine结束
        if n == 9 {
          break
        }
        fmt.Println(n)
    }

}

$ go run context-sync.go
0
1
2
3
4
5
6
7
8

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.通过sync.WaitGroup来实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat waitgroup-sync.go
package main
import (
    &amp;quot;sync&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func subTask(wg *sync.WaitGroup){
    // 在并发函数中通知waitgroup完成
    defer wg.Done()
    for i := 0;i &amp;lt; 10;i++ {
        fmt.Println(i)
    }
}

func main() {
    wg := &amp;amp;sync.WaitGroup{}
    // 设置waitgroup等待次数(并发次数)
    wg.Add(2)
    for i:=0;i&amp;lt;2;i++ {
      go subTask(wg)
    }
    wg.Wait()
}

$go run waitgroup-sync.go
0
1
2
3
4
5
6
7
8
9
0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4.多个子goroutine之间通信&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat mutil-goroutines-sync.go
package main
import (
    &amp;quot;fmt&amp;quot;
)

// 两个task互相协作，通过两个channel来互相通知对方执行的阻塞和继续
// 因为c2其实是一个带缓冲的(1)的channel，会阻塞主直到另外一个task处理
func task1(c1 chan bool,c2 chan bool) {
    for i:= 1;i&amp;lt; 11;i += 2{
        // c2是一个带缓冲的channel，因此第一次打印12后到这里会等待读取c2
        &amp;lt;- c2
        fmt.Printf(&amp;quot;%d&amp;quot;,i)
        fmt.Printf(&amp;quot;%d&amp;quot;,i+1)
        c1 &amp;lt;- true

    }
}

func task2(c1 chan bool,c2 chan bool,c3 chan struct{}) {
    char_seq := [...]string{&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;D&amp;quot;, &amp;quot;E&amp;quot;, &amp;quot;F&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;H&amp;quot;, &amp;quot;I&amp;quot;, &amp;quot;J&amp;quot;}
    for i:=0;i&amp;lt;10;i += 2{
        &amp;lt;- c1
        fmt.Printf(&amp;quot;%s&amp;quot;, char_seq[i])
        fmt.Printf(&amp;quot;%s&amp;quot;, char_seq[i+1])
        c2 &amp;lt;- true
    }
    // 通知主进程任务执行完成
    c3 &amp;lt;- struct{}{}
}


func main() {
    c1 := make(chan bool)
    // 通过有缓冲的channel来争抢执行
    c2 := make(chan bool,1)
    // 定义一个struct{}类型的channel
    done := make(chan struct{})

    // 创建两个goroutine在后台执行
    go task1(c1,c2)
    go task2(c1,c2,done)

    // 继续执行，此时channel c2开始通过值告诉task1开始执行
    fmt.Println(&amp;quot;begin&amp;quot;)
    c2 &amp;lt;- true
    // 通过一个struct{}类型的channel将主进程阻塞住
    &amp;lt;- done
}

$ go run mutil-goroutines-sync.go
begin
12AB34CD56EF78GH910IJ%

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>Linux下快速构建Android编译环境</title>
      <link>https://bgbiao.top/post/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAandroid%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BAandroid%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 在移动互联网时代，大多数的企业内部都有移动客户端，而移动客户端又因为OS的不同产生了两个派系，即&lt;code&gt;安卓(Android)&lt;/code&gt;和&lt;code&gt;苹果(IOS)&lt;/code&gt;，而对于互联网技术从业者来说，这两者最直接的区别就是&lt;code&gt;开源&lt;/code&gt;和&lt;code&gt;闭源&lt;/code&gt;，因而也导致了在构建移动客户端时，为了整体的稳定性和可靠性的考虑(甚至有成本的考虑)，需要进行分别编译，本篇文章记录下如何在Linux环境下构建&lt;code&gt;Android&lt;/code&gt;编译环境.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;介绍&#34;&gt;介绍&lt;/h3&gt;

&lt;p&gt;通常，开发&lt;code&gt;苹果&lt;/code&gt;系列的软件均需要使用一些专有开发工具，比如&lt;a href=&#34;https://developer.apple.com/xcode/&#34;&gt;xcode&lt;/a&gt;,而此工具必须运行在&lt;code&gt;Mac OS X&lt;/code&gt;设备上(当然你也可以尝试各种黑苹果的方式)，所以不论是对于个人开发者还是企业构建服务器来说，都需要购买更多的&lt;code&gt;Mac&lt;/code&gt;设备，通常，我知道的企业内部会使用&lt;code&gt;Mac Mini&lt;/code&gt;来作为苹果系列的构建环境。&lt;/p&gt;

&lt;p&gt;而作为&lt;code&gt;安卓(Android)&lt;/code&gt;系列的软件，由于本身是谷歌开源的移动端操作系统，因此对于底层开发环境和构建环境没有太高的要求。一般而言，开发者会使用&lt;a href=&#34;https://developer.android.com/studio/&#34;&gt;Android Studio&lt;/a&gt;来开发安卓系列的软件，而内置的命令行工具&lt;a href=&#34;https://developer.android.com/studio/command-line/&#34;&gt;command-line&lt;/a&gt;则默认提供了安卓软件的编译工具和环境。值得一提的是，由于&lt;code&gt;Android Studio&lt;/code&gt;是开源的，因此该工具也提供了多个平台的支持(Windows,Mac,Linux,Chrome OS)。而这也极大的降低了企业的整体成本，通常开发环境可以在任意的OS环境中进行开发，而企业内部也可以使用&lt;code&gt;Linux&lt;/code&gt;环境进行安卓软件的持续集成和交付.&lt;/p&gt;

&lt;p&gt;接下来主要讲解下如何在Linux环境下构建安卓的编译环境。&lt;/p&gt;

&lt;h3 id=&#34;linux下安卓-android-编译环境的搭建&#34;&gt;Linux下安卓(Android)编译环境的搭建&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;前提条件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，对于&lt;code&gt;安卓(Android)&lt;/code&gt;应用来说，一些依赖包的管理主要依靠&lt;code&gt;sdkmanager&lt;/code&gt;这个命令行工具，该工具可以在&lt;a href=&#34;https://developer.android.com/studio/&#34;&gt;Android Studio&lt;/a&gt;页面找到，并且支持&lt;code&gt;Windows&lt;/code&gt;,&lt;code&gt;Mac&lt;/code&gt;,&lt;code&gt;Linux&lt;/code&gt;三个不同平台的版本。&lt;/p&gt;

&lt;p&gt;同时，&lt;code&gt;安卓(Android)&lt;/code&gt;应用的开发工具&lt;code&gt;Android Studio&lt;/code&gt;使用&lt;code&gt;[Gradle](https://github.com/gradle/gradle)&lt;/code&gt;来进行编译和打包，因此对于&lt;code&gt;安卓(Android)&lt;/code&gt;应用而言，也将使用&lt;code&gt;gradle&lt;/code&gt;来进行编译和打包操作，该软件可以在&lt;a href=&#34;https://services.gradle.org/distributions/&#34;&gt;Gradle&lt;/a&gt;页面找到。&lt;/p&gt;

&lt;p&gt;其次，&lt;code&gt;[NDK(原生开发套件)](https://developer.android.google.cn/ndk/guides/)&lt;/code&gt;是一套工具，可以使开发者能够在 Android 应用中使用 C 和 C++ 代码，并提供众多平台库，开发者可使用这些平台库管理原生 Activity 和访问物理设备组件，例如传感器和轻触输入。该开发套件可以在&lt;a href=&#34;https://developer.android.google.cn/ndk/downloads&#34;&gt;NDK&lt;/a&gt;页面找到.&lt;/p&gt;

&lt;p&gt;最后，如上几个组件的底层语言均使用&lt;code&gt;java&lt;/code&gt;进行开发，因此需要安装&lt;code&gt;JDK&lt;/code&gt;相关环境。&lt;/p&gt;

&lt;p&gt;综上所述，在Linux环境下编译安卓(Android)环境需要如下几个组件:
- &lt;a href=&#34;https://www.oracle.com/technetwork/java/javase/downloads/index.html&#34;&gt;JDK&lt;/a&gt;: java语言的基础编译和运行环境
- &lt;a href=&#34;https://developer.android.com/studio/&#34;&gt;sdkmanager&lt;/a&gt;: 安卓(Android)应用下的依赖包管理器
- &lt;a href=&#34;https://developer.android.google.cn/ndk/downloads&#34;&gt;NDK&lt;/a&gt;: 安卓原生开发套件，可调用底层&lt;code&gt;C&lt;/code&gt;和&lt;code&gt;C++&lt;/code&gt;代码
- &lt;a href=&#34;https://github.com/gradle/gradle&#34;&gt;Gradle&lt;/a&gt;: 安卓系列软件编译工具(类似&lt;code&gt;maven&lt;/code&gt;之类的工具)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;快速安装基本环境&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 下载基础软件包
$ mkdir -p /opt/servers/ &amp;amp;&amp;amp; cd /opt/servers/
# JDK(可以选择openjdk)
$ wget http://dl.bgbiao.top/dav/jdk1.8.0_191.tar.gz
$ tar -zxf jdk1.8.0_191.tar.gz -C /opt/servers/


# 下载并配置sdkmanager
$ wget https://dl.google.com/android/repository/sdk-tools-linux-4333796.zip
$ unzip sdk-tools-linux-4333796.zip 
$ mkdir -p /opt/sdk
$ ln -s /opt/servers/tools /opt/sdk/tools

# 配置环境变量
$ cat /etc/profile
export JAVA_HOME=/opt/servers/jdk1.8.0_191
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH
export PATH=${JAVA_HOME}/bin:${PATH}
export ANDROID_HOME=/opt/sdk
export PATH=${ANDROID_HOME}/tools/bin:${ANDROID_HOME}/tools/bin:${ANDROID_HOME}:${PATH}

# 测试sdkmanager使用
$ source /etc/profile
$ sdkmanager --list
Warning: File /root/.android/repositories.cfg could not be loaded.
Installed packages:
  Path    | Version | Description              | Location
  ------- | ------- | -------                  | -------
  tools   | 26.0.1  | Android SDK Tools 26.0.1 | tools/


# 安装指定版本的包
$ sdkmanager --list | grep cmake
Warning: File /root/.android/repositories.cfg could not be loaded.
  cmake;3.10.2.4988404              | 3.10.2       | CMake 3.10.2.4988404
  cmake;3.6.4111459                 | 3.6.4111459  | CMake 3.6.4111459

$ sdkmanager &#39;cmake;3.6.4111459&#39; 
....

# 下载并安装ndk
$ cd /opt/servers &amp;amp;&amp;amp; wget https://dl.google.com/android/repository/android-ndk-r16b-linux-x86_64.zip
$ unzip android-ndk-r16b-linux-x86_64.zip
$ ln -s /opt/servers/android-ndk-r16b /opt/ndk

# 配置ndk配置环境(增加如下配置)
$ cat /etc/profile
export NDK_HOME=/opt/ndk
export ANDROID_NDK_HOME=/opt/ndk
export PATH=$NDK_HOME:${ANDROID_NDK_HOME}:$PATH


# 下载并安装gradle
$ cd /opt/servers &amp;amp;&amp;amp; wget https://services.gradle.org/distributions/gradle-4.10.1-all.zip
$ unzip gradle-4.10.1-all.zip
$ ln -s /opt/servers/gradle-4.10.1 /opt/gradle

# 配置gradle环境(增加如下配置)
$ cat /etc/profile
export GRADLE_HOME=/opt/gradle
export PATH=${GRADLE_HOME}/bin:${PATH}

# 测试gradle
$ gradle -v

------------------------------------------------------------
Gradle 4.10.1
------------------------------------------------------------

Build time:   2018-09-12 11:33:27 UTC
Revision:     76c9179ea9bddc32810f9125ad97c3315c544919

Kotlin DSL:   1.0-rc-6
Kotlin:       1.2.61
Groovy:       2.4.15
Ant:          Apache Ant(TM) version 1.9.11 compiled on March 23 2018
JVM:          1.8.0_191 (Oracle Corporation 25.191-b12)
OS:           Linux 3.10.0-862.el7.x86_64 amd64


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;安装Android基础依赖&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 正式编译之前先生成license，并将&lt;code&gt;licenses&lt;/code&gt;目录移动到&lt;code&gt;/opt/sdk/&lt;/code&gt;下,和&lt;code&gt;sdkmanager&lt;/code&gt;的tools目录平级&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装android基础依赖包
$ sdkmanager &#39;build-tools;28.0.3&#39; &#39;platforms;android-28&#39; &#39;cmake;3.6.4111459&#39;

# 生成licences
$ sdkmanager --licenses
$ cp -rp licenses /opt/sdk/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;编译Android包&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 加载下整体环境变量
$ cat /etc/profile
....
....
export JAVA_HOME=/opt/servers/jdk1.8.0_191
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH
export PATH=${JAVA_HOME}/bin:${PATH}
export ANDROID_HOME=/opt/sdk
export PATH=${ANDROID_HOME}/tools/bin:${ANDROID_HOME}/tools/bin:${ANDROID_HOME}:${PATH}
export GRADLE_HOME=/opt/gradle
export PATH=${GRADLE_HOME}/bin:${PATH}
export NDK_HOME=/opt/ndk
export ANDROID_NDK_HOME=/opt/ndk
export PATH=$NDK_HOME:${ANDROID_NDK_HOME}:$PATH

$ source /etc/profile

# 下载安卓(android)应用的源码文件
$ git clone http://git.bgbiao.top/test-app.git

$ cd test-app
$ export ENV=&amp;quot;fNormal&amp;quot;
$ gradle clean assemble${ENV}Release
Starting a Gradle Daemon, 2 busy Daemons could not be reused, use --status for details
Parallel execution with configuration on demand is an incubating feature.
&amp;lt;-------------&amp;gt; 0% CONFIGURING [29s]
&amp;gt; root project &amp;gt; Resolve dependencies of :classpath &amp;gt; guava-18.0.pom &amp;gt; 3 KB/5 KB downloaded
&amp;gt; IDLE
&amp;gt; root project &amp;gt; Resolve dependencies of :classpath &amp;gt; commons-lang-2.6.pom &amp;gt; 9 KB/17 KB downloaded
&amp;gt; root project &amp;gt; Resolve dependencies of :classpath &amp;gt; osdetector-gradle-plugin-1.4.0.pom
....
....

BUILD SUCCESSFUL in 7m 7s
501 actionable tasks: 164 executed, 288 from cache, 49 up-to-date


# 查看生成的apk包
$ ls app/build/outputs/apk/fNormal/release/
app-fNormal-release.apk  output.json


# 安装二维码生成器
$ yum install qrencode-3.4.1-3.el7.x86_64 -y

# 将生成的apk包上传到指定的http服务中
$ curl -T app/build/outputs/apk/fNormal/release/app-fNormal-release.apk http://dl.bgbiao.top/dav/

# 给apk下载文件生成一个二维码
$ qrencode -o test-android.png &amp;quot;http://dl.bgbiao.top/dav/app-fNormal-release.apk&amp;quot;

# 上传二维码
$ curl -T test-android.png http://dl.bgbiao.top/dav/

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，开发者用户即可以使用&lt;code&gt;http://dl.bgbiao.top/dav/test-android.png&lt;/code&gt;二维码地址进行扫描安装，对该版本的app功能进行测试验证了。&lt;/p&gt;

&lt;p&gt;需要注意的是，通常情况下，开发者如果使用&lt;code&gt;Mac OSX&lt;/code&gt;来编写代码，可能会在代码里使用类似&lt;code&gt;#include &#39;MD5.h&#39;&lt;/code&gt;之类的代码，看起来好像没有什么问题，但是因为&lt;code&gt;Mac OSX&lt;/code&gt;或&lt;code&gt;Windows&lt;/code&gt;系统中对大小写不敏感，所以那样写不会有什么太大影响，因为编译器可以找到系统中的&lt;code&gt;md5.h&lt;/code&gt;，但是在&lt;code&gt;Linux&lt;/code&gt;环境下，系统对大小写很敏感，如果代码里写死了&lt;code&gt;MD5.h&lt;/code&gt;，而系统库中是&lt;code&gt;md5.h&lt;/code&gt;，那肯定会编译失败，而且一般人看到该异常情况不会想到是大小写的问题。&lt;/p&gt;

&lt;p&gt;好了，趟坑算是趟完了，接下来提供一个福利，我自己基于以上构建历史环境打包了一个docker镜像，用以封装&lt;code&gt;Android&lt;/code&gt;编译的基本环境.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;docker镜像&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat Dockerfile
FROM centos:7.5.1804
MAINTAINER &amp;quot;BGBiao &amp;lt;https://bgbiao.top/&amp;gt;&amp;quot;
ENV TZ &amp;quot;Asia/Shanghai&amp;quot;

RUN yum clean all &amp;amp;&amp;amp; \
    yum install unzip wget curl -y &amp;amp;&amp;amp; \
    mkdir -p /opt/{servers,app} &amp;amp;&amp;amp; \
    cd /opt/servers/ &amp;amp;&amp;amp; \
    wget  http://dl.bgbiao.top/hadoop/jdk1.8.0_191.tar.gz &amp;amp;&amp;amp; \
    wget http://dl.bgbiao.top/dav/android-build/android-ndk-r16b-linux-x86_64.zip &amp;amp;&amp;amp; \
    wget http://dl.bgbiao.top/dav/android-build/gradle-4.10.1-all.zip &amp;amp;&amp;amp; \
    wget http://dl.bgbiao.top/dav/android-build/sdk-tools-linux-4333796.zip

RUN pushd /opt/servers &amp;amp;&amp;amp; \
    tar -zxf jdk1.8.0_191.tar.gz &amp;amp;&amp;amp; \
    unzip android-ndk-r16b-linux-x86_64.zip &amp;amp;&amp;amp; \
    unzip gradle-4.10.1-all.zip &amp;amp;&amp;amp; \
    unzip sdk-tools-linux-4333796.zip &amp;amp;&amp;amp; \
    mkdir -p /opt/sdkmanager &amp;amp;&amp;amp; \
    ln -s /opt/servers/tools /opt/sdkmanager/tools &amp;amp;&amp;amp; \
    ln -s /opt/servers/gradle-4.10.1 /opt/gradle &amp;amp;&amp;amp; \
    ln -s /opt/servers/android-ndk-r16b /opt/ndk

COPY profile /opt/servers/setenv.sh
$ cat profile
export JAVA_HOME=/opt/servers/jdk1.8.0_191
export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH
export PATH=${JAVA_HOME}/bin:${PATH}
export ANDROID_HOME=/opt/sdkmanager
export PATH=${ANDROID_HOME}/tools/bin:${ANDROID_HOME}/tools/bin:${ANDROID_HOME}:${PATH}
export GRADLE_HOME=/opt/gradle
export PATH=${GRADLE_HOME}/bin:${PATH}
export NDK_HOME=/opt/ndk
export ANDROID_NDK_HOME=/opt/ndk
export PATH=$NDK_HOME:${ANDROID_NDK_HOME}:$PATH

# 用户可以根据上述Dockerfile构建镜像，同时也可以直接使用我构建好的一个镜像
$ docker pull xxbandy123/android-build-env:19-12-12

# 使用方式
# 基于上述镜像，用户需要使用sdkmanager 安装依赖的安卓库，同时编排好自己的gradle打包命令，在自己的安卓项目中直接编译即可
$ docker run -itd --name android-build-env:19-12-12 bash 
[root@4c05d4ded28d /]# source /opt/servers/setenv.sh
[root@4c05d4ded28d /]# git clone your-android-app.git
[root@4c05d4ded28d /]# sdkmanager &#39;build-tools;28.0.3&#39; &#39;platforms;android-28&#39; &#39;cmake;3.6.4111459&#39;
[root@4c05d4ded28d /]# sdkmanager --licenses
[root@4c05d4ded28d /]# cp -rp licenses ${ANDROID_HOME}/
[root@4c05d4ded28d /]# ls ${ANDROID_HOME}
build-tools  cmake  licenses  platforms  platform-tools  tools
# 开始执行编译(之后就是漫长的等待了)
[root@4c05d4ded28d /]# cd your-android-app &amp;amp;&amp;amp; gradle clean assembleRelease

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.通常持续集成会使用&lt;code&gt;Jenkins&lt;/code&gt;来进行编译打包，因此以上环境再接入Jenkins-salve之前需要安装&lt;code&gt;git&lt;/code&gt;客户端名&lt;/li&gt;
&lt;li&gt;2.通常客户端在测试包时会通过二维码扫描来下载包，因此环境上需要安装&lt;code&gt;qrencode&lt;/code&gt;软件，用于生成二维码&lt;/li&gt;
&lt;li&gt;3.需要注意&lt;code&gt;gradle&lt;/code&gt;在编译过程中会启动一个守护进程，如果编译异常结束，该守护进程可能不会立即释放，此时立即再次编译将有可能导致OOM&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>salt-master高可用架构</title>
      <link>https://bgbiao.top/post/salt%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 11 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/salt%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 新来这家公司使用&lt;a href=&#34;https://docs.saltstack.com/en/latest/&#34;&gt;Salt&lt;/a&gt;来作为基础配置库管理和自动化运维的工具，但是前期同事刚开始使用时只是简单使用，因此对于可用性和可靠性来说都会存在很大问题(具体可能出现的问题下面会提到)。不过作为一个专业的SRE或者运维人员，在使用一个基础组件时，必须要考虑的一个问题就是&lt;code&gt;可用性&lt;/code&gt;和&lt;code&gt;可靠性&lt;/code&gt;，以前使用&lt;a href=&#34;https://docs.ansible.com/&#34;&gt;Ansible&lt;/a&gt;作为配置管理和自动化运维工具时只需对&lt;code&gt;ssh-key&lt;/code&gt;或者密码进行管理即可通过水平扩容来保证高可用，而在&lt;code&gt;Salt&lt;/code&gt;中需要涉及到&lt;code&gt;salt-minion&lt;/code&gt;的发现以及&lt;code&gt;key&lt;/code&gt;的管理，接下来对&lt;code&gt;高可用的Salt集群架构&lt;/code&gt;进行介绍和实施。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;单节点salt-master问题&#34;&gt;单节点salt-master问题&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;比如说2c2g的机器在管理500+左右的ECS时，就会发现异常慢，而且调用salt-api会出现异常，此时如果去检查资源使用率，就会发现cpu和load都会暴涨，这是因为在使用salt的场景中大部分会使用同步调用，此时salt相关的进程会一直占用资源，直到minion返回结果&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当单节点主机异常时，整体的salt管控端将会失效，也就意味着全量的主机将无法被统一管理，这对于任何一个基于salt的自动化管理系统来说都是一个大灾难&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因此，基于以上考虑，salt-master高可用架构的构建对于任何一个&lt;code&gt;生产环境&lt;/code&gt;的自动化基础设施来讲都是刻不容缓的。&lt;/p&gt;

&lt;h3 id=&#34;salt-master高可用架构方案&#34;&gt;salt-master高可用架构方案&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.saltstack.com/en/master/topics/highavailability/index.html&#34;&gt;salt高可用方案&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在salt的官方文档中提供了三种高可用的方案:
- &lt;a href=&#34;https://docs.saltstack.com/en/master/topics/tutorials/multimaster.html#tutorial-multi-master&#34;&gt;多Master结构&lt;/a&gt;: 该种方式需要在&lt;code&gt;minion&lt;/code&gt;中配置多个master，此时默认所有的master都是在线的，同时多个master必须共享相同的&lt;code&gt;cryptographic keys&lt;/code&gt;，而且&lt;code&gt;minion keys&lt;/code&gt;必须在所有的master节点单独允许，此外还需要&lt;code&gt;file_roots&lt;/code&gt;和&lt;code&gt;pillar_roots&lt;/code&gt;保持同步
- 故障切换的多Master结构: 同上，都是多Master架构，默认情况下采用的是顺序master，不过可以通过&lt;code&gt;master_type&lt;/code&gt;参数修改为&lt;code&gt;failover&lt;/code&gt;，以此来保障多Master节点之间的故障切换(通常failover需要&lt;code&gt;master_alive_interval&lt;/code&gt;和&lt;code&gt;master_shuffle: True&lt;/code&gt;参数支持)
- &lt;a href=&#34;https://docs.saltstack.com/en/master/topics/topology/syndic.html#syndic&#34;&gt;syndic&lt;/a&gt;: salt-syndic其实不能算是一种严格的高可用架构，它有点儿类似代理的方式，即在主控master节点下设置syndic节点，由syndic节点来管控旗下的minion节点
- [多Master结构下的syndic]: 同上&lt;/p&gt;

&lt;p&gt;大概了解了集中高可用方案之后，我们做一个简单分析:&lt;br /&gt;
1. 首先我们为了保障高可用，需要允许任意节点都是高可用的，因此排除&lt;code&gt;syndic&lt;/code&gt;方案
2. 在&lt;code&gt;多master&lt;/code&gt;，&lt;code&gt;故障切换的多master&lt;/code&gt;和&lt;code&gt;多master下的syndic&lt;/code&gt;中，在可用用性和性能承受范围内考虑架构的简洁性，排除&lt;code&gt;多master下的syndic&lt;/code&gt;方案&lt;/p&gt;

&lt;p&gt;因此，最终可供我们选择的即为&lt;code&gt;多master&lt;/code&gt;方案，至于&lt;code&gt;failover&lt;/code&gt;其实只是&lt;code&gt;多master&lt;/code&gt;下的一种类型。&lt;/p&gt;

&lt;h3 id=&#34;salt-master高可用实施&#34;&gt;salt-master高可用实施&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在&lt;code&gt;多Master结构&lt;/code&gt;中也提到了，&lt;code&gt;cryptographic key&lt;/code&gt;和&lt;code&gt;file_roots&lt;/code&gt;以及&lt;code&gt;pillar_roots&lt;/code&gt;需要保持同步，我们这里使用共享存储方式来实现多master节点的文件同步。&lt;/p&gt;

&lt;p&gt;如果使用的是阿里云，可以使用&lt;a href=&#34;https://www.aliyun.com/product/nas?source=5176.11533457&amp;amp;userCode=n0qkvlxu&amp;amp;type=copy&#34;&gt;NAS&lt;/a&gt;服务来实现多主机的共享文件存储.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.aliyun.com/product/nas?source=5176.11533457&amp;amp;userCode=n0qkvlxu&amp;amp;type=copy&#34;&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9sqdlv593j316i0eun0l.jpg&#34; alt=&#34;NAS存储&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是非云，或者非阿里云的环境，可以采用传统的&lt;code&gt;NFS&lt;/code&gt;存储方式来实现共享存储，不过&lt;code&gt;NFS&lt;/code&gt;仅提供了共享，却不保证高可用性，如果需要大规模使用也是需要考虑备份错输。另外其他的方式就是采用&lt;code&gt;GlusterFS&lt;/code&gt;或者&lt;code&gt;CephFS&lt;/code&gt;之类的分布式共享存储方案。因此在迁移迁移阶段，我们先采用&lt;code&gt;GlusterFS&lt;/code&gt;来提供底层的高可用的共性存储(后期会直接迁移到阿里云的NAS服务)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.创建一个glusterfs volume&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 创建一个salt卷(复制卷)
$ gluster volume create salt replica 2 node4:/data/salt node5:/data/salt force

# 查看当前gluster集群下的volume(也供给k8s中的自建mysql使用)
$ gluster volume list
k8s
salt

# 启动salt volume
$ gluster volume start salt
$ gluster volume info salt


# 开启磁盘配额的限制
$ gluster volume quota salt enable
volume quota : success

$ gluster volume quota salt limit-usage / 200GB 90%
volume quota : success

# 查看磁盘配额情况
$ gluster volume quota salt list
+----  1 line: Path                   Hard-limit  Soft-limit      Used  Available  Soft-limit exceeded? Hard-limit exce
-------------------------------------------------------------------------------------------------------------------------------
/                                        200.0GB     90%(180.0GB)   0Bytes 200.0GB              No                   No

# 使用(被挂载节点需要绑定这个hosts)
# 所有的客户端主机均需要安装(glusterfs客户端)
$ yum install glusterfs glusterfs-client -y
$ cat /etc/hosts
10.0.21.74  node4
10.0.21.73 node5

$ mount -t glusterfs 10.0.21.73:/salt /opt/data/salt-data/
$ df -H | grep /opt/data/
10.0.21.73:/salt  215G     0  215G    0% /opt/data/salt-data

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.修改salt-master配置文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 每次master接收minion的认证后会将认证文件统一存放在&lt;code&gt;pki_dir&lt;/code&gt;目录下，如果是在单master像多Master改造，需要保持该文件的全量同步&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# salt-master-1
$ grep -v ^#  /etc/salt/master  | grep -v ^$
interface: 10.0.217.78
pki_dir: /opt/data/salt-data/pki/master
timeout: 10
file_recv: True
log_file: /var/log/salt/master
log_level: info

# salt-master-2
$ grep -v ^#  /etc/salt/master  | grep -v ^$
interface: 10.0.79.88
pki_dir: /opt/data/salt-data/pki/master
timeout: 10
file_recv: True
log_file: /var/log/salt/master
log_level: info

# salt-minion配置示例
# 这里使用随机master，可以减少master的负载
# 如果使用failover模式的话，将永远只有失败之后使用另外的salt-master，整体性价比较低(不过可随时切换)
$ grep -v ^# /etc/salt/minion | grep -v ^$
master:
    - salt-master-2.bgbiao.top
    - salt-master-1.bgbiao.top
random_master: True
id: 10.0.79.90

# 分别重启salt-master和salt-minion进程
# 在任意一台salt-master中同步key
$ salt-key -a 10.0.79.90 -y

# 测试后发现两个salt-master均可以对目标主机执行操作
[root@salt-master-2 ~]# salt 10.0.79.90 test.ping
10.0.79.90:
    True

[root@salt-master-1 ~]# salt 10.0.79.90 test.ping
10.0.79.90:
    True

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.修改file_roots和pillar_sls目录&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 修改salt-master相关配置
# 增加file_roots目录(默认在/srv/salt/目录下)
$ grep -v ^#  /etc/salt/master  | grep -v ^$
interface: 10.0.79.88
pki_dir: /opt/data/salt-data/pki/master
timeout: 10
file_recv: True
file_roots:
  base:
    - /opt/data/salt-data/salt-sls/
log_file: /var/log/salt/master
log_level: info

# 将源master节点/srv/salt/下文件同步到/opt/data/salt-data/salt-sls/目录即可

# 测试salt state文件使用
# 测试hadoop客户端安装
[root@salt-master-2 salt-sls]# salt 10.0.79.90 state.sls hadoop-client.init-hadoop-env
....
....
Summary
-------------
Succeeded: 25 (changed=24)
Failed:     0
-------------
Total states run:     25

# 使用state初始化hadoop环境后测试hadoop客户端是否正常
[root@salt-master-2 salt-sls]# salt 10.0.79.90 cmd.run &#39;source /etc/profile &amp;amp;&amp;amp; hadoop fs -ls /hive;&#39;
10.0.79.90:
    19/12/10 16:37:59 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable
    19/12/10 16:38:00 WARN shortcircuit.DomainSocketFactory: The short-circuit local reads feature cannot be used because libhadoop cannot be loaded.
    Found 3 items
    drwxr-x--x   - root   hadoop          0 2018-12-03 20:05 /hive/dw
    drwxr-x--x   - root   hadoop          0 2019-04-02 11:03 /hive/ods
    drwxr-x--x   - hadoop hadoop          0 2019-07-18 21:26 /hive/rpt

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在新的master节点验证完毕后，将全部master节点的&lt;code&gt;/etc/salt/master&lt;/code&gt;配置文件进行同步(&lt;code&gt;interface&lt;/code&gt;参数需要为指定的地址)即可.&lt;/p&gt;

&lt;h3 id=&#34;salt-minion接入使用&#34;&gt;salt-minion接入使用&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 安装salt-minion
$ yum install salt-minion -y

# 修改salt-minion配置文件(id为唯一标识salt-minion)
$ cat /etc/salt/minion
master:
    - salt-master-2.bgbiao.top
    - salt-master-1.bgbiao.top
random_master: True
# 其实这里的id可以不用指定，默认为socket.getfqdn()函数值(其实就是ipv4)
id: 10.0.79.90

# 重启salt-minion
$ systemctl daemon-reload &amp;amp;&amp;amp; systemctl restart salt-minion

# salt-master手动同意请求(可用设置成定期accept all)
$ salt-key -a 10.0.79.90 -y

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;salt使用问题和注意事项&#34;&gt;salt使用问题和注意事项&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; master设备会为每个minion的auth-request请求计算签名。 在有许多minions和频繁的auth请求时，这可以消耗掉master服务器上相当多的CPU资源.&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
    </item>
    
    <item>
      <title>快速使用互联网检索有用数据</title>
      <link>https://bgbiao.top/post/%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/</link>
      <pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E4%BA%92%E8%81%94%E7%BD%91%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 随着互联网的普及和发展，互联网上充斥了大量的数据，如何从海量数据中识别自己最想要的数据成为了很多人头疼的问题，接下来给大家分享一些自己常用的检索数据的网站和方法.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;搜索引擎&#34;&gt;搜索引擎&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.搜索关键字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在搜索关键字的时候，尽量选择具体的关键字，比如&lt;code&gt;大数据&lt;/code&gt;就没有&lt;code&gt;大数据就业&lt;/code&gt;，&lt;code&gt;大数据行业&lt;/code&gt;，&lt;code&gt;大数据企业&lt;/code&gt;具体；另外在搜索关键词的时候，通常推荐使用多次分词，也就是使用一个词一个词，词词之间使用空格分开，比如&lt;code&gt;大数据 云计算&lt;/code&gt;,同时在检索内容时，也可以根据关键程度将词前后位置进行转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.搜索技巧&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.文件类型搜索:在搜索引擎搜索框最后增加&lt;code&gt;空格 filetype:type&lt;/code&gt; type可以是[pdf,ppt,xls,doc]中的任意一个&lt;/li&gt;
&lt;li&gt;2.网站定位搜索:在搜索引擎搜索框最后增加&lt;code&gt;空格 site:URL&lt;/code&gt;  URL即为指定网站(其实各种搜索引擎都是去定向爬取各个网站的关键字进行收录的)&lt;/li&gt;
&lt;li&gt;3.限制性搜索: 使用&lt;code&gt;intitle&lt;/code&gt;,如在百度键入&lt;code&gt;intitie:大数据&lt;/code&gt;，限定于搜索标题中含有&lt;code&gt;大数据&lt;/code&gt;网页，如果输入&lt;code&gt;intitie:大数据市场规模&lt;/code&gt;限定于搜索标题中含有&lt;code&gt;大数据&lt;/code&gt;和&lt;code&gt;市场规模&lt;/code&gt;的网页&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其实上述三个搜索技巧，在各个搜索引擎中会默认支持工具，但是通常会被放在很隐蔽的地方&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1g9rfguy2qoj310m0hc42h.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另外，除了常用的搜索引擎:百度,谷歌,必应,搜狗之外，通常还会有一些垂直领域或者非商业化的搜索引擎.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Google学术搜索: &lt;a href=&#34;http://scholar.google.com/&#34;&gt;http://scholar.google.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;科技文献搜索: &lt;a href=&#34;http://www.scirus.com&#34;&gt;http://www.scirus.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;学术搜索引擎: &lt;a href=&#34;http://www.base-search.net/&#34;&gt;http://www.base-search.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;交叉学科门户网站: &lt;a href=&#34;http://www.vascoda.de/&#34;&gt;http://www.vascoda.de/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个神奇的网站: &lt;a href=&#34;http://www.goole.com/&#34;&gt;http://www.goole.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Amazon推出的: &lt;a href=&#34;http://www.a9.com&#34;&gt;http://www.a9.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;免费paper检索: &lt;a href=&#34;http://www.findarticles.com/&#34;&gt;http://www.findarticles.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;计算机和信息科学: &lt;a href=&#34;http://citeseer.ist.psu.edu/&#34;&gt;http://citeseer.ist.psu.edu/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;谷歌马甲: &lt;a href=&#34;https://search.aol.com/&#34;&gt;https://search.aol.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;

&lt;p&gt;数据库是研究人员重要的数据来源之一，目前券商、基金研究研究机构都购买有商业数据库，目前研究用的数据库主要分为两大类，一是商业数据库，二是学术数据库。&lt;/p&gt;

&lt;p&gt;由于一般是个人使用，这里仅介绍一些免费可用的数据库.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据汇: &lt;a href=&#34;http://www.shujuhui.com/database/&#34;&gt;http://www.shujuhui.com/database/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;数据圈子: &lt;a href=&#34;http://www.shujuquan.com.cn/&#34;&gt;http://www.shujuquan.com.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;FRED: &lt;a href=&#34;http://research.stlouisfed.org/fred2/&#34;&gt;http://research.stlouisfed.org/fred2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;OECD: &lt;a href=&#34;http://www.oecd-ilibrary.org/economics&#34;&gt;http://www.oecd-ilibrary.org/economics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;台湾学术数据库: &lt;a href=&#34;http://fedetd.mis.nsysu.edu.tw/&#34;&gt;http://fedetd.mis.nsysu.edu.tw/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;台湾大学电子书: &lt;a href=&#34;http://ebooks.lib.ntu.edu.tw/Home/ListBooks&#34;&gt;http://ebooks.lib.ntu.edu.tw/Home/ListBooks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;共享文库&#34;&gt;共享文库&lt;/h3&gt;

&lt;p&gt;主要介绍下国外的，国内的&lt;code&gt;百度文库&lt;/code&gt;,&lt;code&gt;道客巴巴&lt;/code&gt;之类的文档太差，而且还收费.&lt;/p&gt;

&lt;p&gt;Scribd：&lt;a href=&#34;http://www.scribd.com&#34;&gt;http://www.scribd.com&lt;/a&gt;
Docstoc: &lt;a href=&#34;http://www.docstoc.com&#34;&gt;http://www.docstoc.com&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;专业网站&#34;&gt;专业网站&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;人大经济论坛: &lt;a href=&#34;http://bbs.pinggu.org/&#34;&gt;http://bbs.pinggu.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;经济学家: &lt;a href=&#34;http://bbs.jjxj.org/&#34;&gt;http://bbs.jjxj.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;随意网-经济论坛: &lt;a href=&#34;http://economic.5d6d.net/&#34;&gt;http://economic.5d6d.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;理想在线: &lt;a href=&#34;http://www.55188.com&#34;&gt;股票券商研究报告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;迈博汇金: &lt;a href=&#34;http://www.hibor.com.cn/&#34;&gt;股票券商研究报告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博瑞金融: &lt;a href=&#34;http://www.brjr.com.cn/forum.php&#34;&gt;金融行业专业型论坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;华尔街社区: &lt;a href=&#34;http://forum.cnwallstreet.com/index.php&#34;&gt;国内专业的金融论坛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中华股权投资论坛: &lt;a href=&#34;http://www.tzluntan.com/&#34;&gt;pe投资专业型论坛&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;政府数据&#34;&gt;政府数据&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;国家统计局: &lt;a href=&#34;http://www.stats.gov.cn/&#34;&gt;http://www.stats.gov.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;工业和信息化部: &lt;a href=&#34;http://www.miit.gov.cn&#34;&gt;http://www.miit.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国人民银行: &lt;a href=&#34;http://www.pbc.gov.cn/&#34;&gt;http://www.pbc.gov.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;银监会: &lt;a href=&#34;http://www.cbrc.gov.cn&#34;&gt;http://www.cbrc.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国海关: &lt;a href=&#34;http://www.customs.gov.cn&#34;&gt;http://www.customs.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;国家知识产权局: &lt;a href=&#34;http://www.sipo.gov.cn&#34;&gt;http://www.sipo.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中国证监会: &lt;a href=&#34;http://www.csrc.gov.cn&#34;&gt;http://www.csrc.gov.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;巨潮信息网:&lt;a href=&#34;http://www.cninfo.com.cn/&#34;&gt;中国资本市场指定披露平台&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;证券交易所&#34;&gt;证券交易所&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;上海证券交易所: &lt;a href=&#34;http://www.sse.com.cn/&#34;&gt;http://www.sse.com.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;深圳证券交易所: &lt;a href=&#34;http://www.szse.cn/&#34;&gt;http://www.szse.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;全国中小企业股份转让系统: &lt;a href=&#34;http://www.neeq.com.cn/&#34;&gt;http://www.neeq.com.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;香港证券交易所: &lt;a href=&#34;http://www.hkexnews.hk/index_c.htm&#34;&gt;http://www.hkexnews.hk/index_c.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;台湾证券交易所: &lt;a href=&#34;http://www.tse.com.tw/ch/index.php&#34;&gt;http://www.tse.com.tw/ch/index.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新加坡证券交易所: &lt;a href=&#34;http://www.sgx.com/&#34;&gt;http://www.sgx.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;纽约证券交易所: &lt;a href=&#34;http://www.nyse.com&#34;&gt;http://www.nyse.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;纳斯达克证券交易所: &lt;a href=&#34;http://www.nasdaq.com&#34;&gt;http://www.nasdaq.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;行业网站&#34;&gt;行业网站&lt;/h3&gt;

&lt;p&gt;互联网及传媒
1）资讯类
新浪科技 &lt;a href=&#34;http://tech.sina.com.cn/&#34;&gt;http://tech.sina.com.cn/&lt;/a&gt;
腾讯科技 &lt;a href=&#34;http://tech.qq.com/&#34;&gt;http://tech.qq.com/&lt;/a&gt;
艾瑞网 &lt;a href=&#34;http://www.iresearch.cn/&#34;&gt;http://www.iresearch.cn/&lt;/a&gt;
艺恩网 &lt;a href=&#34;http://www.entgroup.cn/&#34;&gt;http://www.entgroup.cn/&lt;/a&gt;
虎嗅网 &lt;a href=&#34;http://wwww.huxiu.com/&#34;&gt;http://wwww.huxiu.com/&lt;/a&gt;
36kr &lt;a href=&#34;http://36kr.com/&#34;&gt;http://36kr.com/&lt;/a&gt;
钛媒体 &lt;a href=&#34;http://www.tmtpost.com/&#34;&gt;http://www.tmtpost.com/&lt;/a&gt;
游戏大观 &lt;a href=&#34;http://www.gamelook.com.cn/&#34;&gt;http://www.gamelook.com.cn/&lt;/a&gt;
亿欧网 &lt;a href=&#34;http://www.iyiou.com/&#34;&gt;http://www.iyiou.com/&lt;/a&gt;
媒介360 &lt;a href=&#34;http://www.chinamedia360.com/main&#34;&gt;http://www.chinamedia360.com/main&lt;/a&gt;
　
2）数据类
中国票房 &lt;a href=&#34;http://www.cbooo.cn/&#34;&gt;http://www.cbooo.cn/&lt;/a&gt;
中国互联网络信息中心 &lt;a href=&#34;http://www.cnnic.net.cn/&#34;&gt;http://www.cnnic.net.cn/&lt;/a&gt;
艾瑞网
&lt;a href=&#34;http://www.iresearch.com.cn/report/viewlist.aspx&#34;&gt;http://www.iresearch.com.cn/report/viewlist.aspx&lt;/a&gt;
易观智库 &lt;a href=&#34;http://www.analysys.cn/&#34;&gt;http://www.analysys.cn/&lt;/a&gt;
游戏产业网
&lt;a href=&#34;http://www.cgigc.com.cn/list/79644663134.html&#34;&gt;http://www.cgigc.com.cn/list/79644663134.html&lt;/a&gt;
百度指数 &lt;a href=&#34;http://index.baidu.com/&#34;&gt;http://index.baidu.com/&lt;/a&gt;
大数据导航 &lt;a href=&#34;http://hao.199it.com/&#34;&gt;http://hao.199it.com/&lt;/a&gt;
CSM（电视收视率） &lt;a href=&#34;http://www.csm.com.cn/&#34;&gt;http://www.csm.com.cn/&lt;/a&gt;
微排片 &lt;a href=&#34;http://www.weipaipian.com&#34;&gt;http://www.weipaipian.com&lt;/a&gt;
　
医药行业
1）样本医院数据
化药、生物药和中药注射剂 &lt;a href=&#34;http://pdb.pharmadl.com/&#34;&gt;http://pdb.pharmadl.com/&lt;/a&gt;
中成药、化药 &lt;a href=&#34;http://www.menet.com.cn/&#34;&gt;http://www.menet.com.cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;银行业
1）新闻资讯
中证网 &lt;a href=&#34;http://www.cs.com.cn/xwzx/hg/&#34;&gt;http://www.cs.com.cn/xwzx/hg/&lt;/a&gt;
一财网 &lt;a href=&#34;http://www.yicai.com/economy&#34;&gt;http://www.yicai.com/economy&lt;/a&gt;
财新网 &lt;a href=&#34;http://finance.caixin.com/bank/&#34;&gt;http://finance.caixin.com/bank/&lt;/a&gt;
华尔街见闻 &lt;a href=&#34;http://wallstreetcn.com/news?cid=19&#34;&gt;http://wallstreetcn.com/news?cid=19&lt;/a&gt;
新浪财经 finance.sina.com.cn/
证券时报网 &lt;a href=&#34;http://www.stcn.com/&#34;&gt;http://www.stcn.com/&lt;/a&gt;
中国金融新闻网
&lt;a href=&#34;http://www.financialnews.com.cn/yh/xw/&#34;&gt;http://www.financialnews.com.cn/yh/xw/&lt;/a&gt;
　
2）公告、数据查找
中国货币网 &lt;a href=&#34;http://www.chinamoney.com.cn/index.html&#34;&gt;http://www.chinamoney.com.cn/index.html&lt;/a&gt;
巨潮网 &lt;a href=&#34;http://www.cninfo.com.cn/&#34;&gt;http://www.cninfo.com.cn/&lt;/a&gt;
统计局 www.stats.gov.cn/
中国人民银行 www.pbc.gov.cn
银监会 &lt;a href=&#34;http://www.cbrc.gov.cn/index.html&#34;&gt;http://www.cbrc.gov.cn/index.html&lt;/a&gt;
上海证券交易所 www.sse.com.cn/
深圳证券交易所 www.szse.cn/
最常用wind股票数据库。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang中的单元测试、基准测试、覆盖测试</title>
      <link>https://bgbiao.top/post/go-unit-test/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/go-unit-test/</guid>
      
        <description>&lt;h2 id=&#34;单元测试-基准测试-覆盖测试&#34;&gt;单元测试、基准测试、覆盖测试&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;背景: 之前很长一段时间再写Golang程序时，不会有意识去写单元测试，直到后来写了独立项目后，慢慢才发现给一个功能编写对应的单元测试是多么高效和方便，接下来就再一起复习下Golang中的测试.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;UnitTest(单元测试)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单元测试是程序开发者适用一段代码来验证另外一段代码写的是否符合预期的一种相对高效的自我测试方法。&lt;/p&gt;

&lt;p&gt;还记得最早开始搞运维时，写的程序基本上是通过&lt;code&gt;main&lt;/code&gt;程序去调用具体的功能函数，然后通过具体的输出来主观验证结果是否符合预期，这种方式对于搞正统的软件开发者而言会感觉很傻，但这对于运维领域来说却很实用，很有效，因为通常运维工作中需要的一些开发都不会是逻辑较为复杂的程序，所以没有必要专门去写测试程序去测试另外一个程序是否符合预期。&lt;/p&gt;

&lt;p&gt;但是随着工作内容和运维需求的变化，不得不使用一些正规软件工程领域的相关方法来进行测试，因为对于程序开发来说，经过长期的积累和方法总结，单元测试是一种比较好的开发程序验证方式，而且能够提高程序开发的质量。而在&lt;code&gt;Golang&lt;/code&gt;语言中内置了一系列的测试框架，加下来就主要讲讲&lt;code&gt;UnitTest&lt;/code&gt;单元测试的相关知识点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UnitTest的编写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在Golang中，对于单元测试程序来说通常会有一些重要约束，主要如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单元测试文件名必须为&lt;code&gt;xxx_test.go&lt;/code&gt;(其中xxx为业务逻辑程序)&lt;/li&gt;
&lt;li&gt;单元测试的函数名必须为&lt;code&gt;Testxxx&lt;/code&gt;(xxx可用来识别业务逻辑函数)&lt;/li&gt;
&lt;li&gt;单元测试函数参数必须为&lt;code&gt;t *testing.T&lt;/code&gt;(测试框架强要求)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试程序和被测试程序文件在一个包&lt;code&gt;package&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 示例文件
# 假设我们为某段业务逻辑专门写了一个package(用来初始化一个矩形，并计算体积)，此时看到到整体结构如下
$ tree -L 2 ./unittest
./unittest
├── area.go
└── area_test.go

# 业务逻辑代码(业务逻辑需要和单元测试在一个package下)
$ cat ./unittest/area.go
package unittest

type box struct {
length  int
width   int
height  int
name    string
}

// 初始化一个结构体指针对象，后面使用结构体指针方法来设置和获取对象属性
func Newbox() (*box) {
return &amp;amp;box{}
}

// 给结构体对象设置具体的属性(名称，规格大小)
// 注意: 在如下几个方法中，方法接受者为指针类型，而方法参数为值类型，因此在赋值时可能有人产生疑惑，这里其实是Golang底层做了优化(v.name = name 等同于(*v).name = name)
func (v *box) SetName(name string) {
v.name = name
}
func (v *box) SetSize(l,w,h int) {
v.length = l
v.width = w
v.height = h
}

// 获取对象的一些属性(名称和体积)
func (v *box) GetName() (string) {
return v.name
}
func (v *box) GetVolume() (int) {
return (v.length)*(v.width)*(v.height)
}

# 对应业务逻辑的单元测试逻辑
$ cat unittest/area_test.go
package unittest
// 必须导入testing模块，并且方法的接受者为(t *testing.T)
import (
&amp;quot;fmt&amp;quot;
&amp;quot;testing&amp;quot;
)
// 测试1: 测试名称是否符合预期
func TestSetSomething(t *testing.T) {
box := Newbox()
box.SetName(&amp;quot;bgbiao&amp;quot;)
if box.GetName() == &amp;quot;bgbiao&amp;quot; {
    fmt.Println(&amp;quot;the rectangular name&#39;s result is ok&amp;quot;)
}
}
// 测试2: 测试计算出来的体积是否符合预期
func TestGetSomething(t *testing.T) {
box := Newbox()
box.SetSize(3,4,5)
if box.GetVolume() == 60 {
    fmt.Println(&amp;quot;the rectangular volume&#39;s result is ok&amp;quot;)
}
}

# 运行单元测试程序
# 可以看到我们编写的两个单元测试都经过预期测试
$ cd unittest
$ go test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
ok  	_/User/BGBiao/unittest	0.005s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;单元测试的运行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过上面那个测试示例，我们都知道了可以使用&lt;code&gt;go test&lt;/code&gt;来对Golang代码进行测试，接下来具体讲解一些&lt;code&gt;go test&lt;/code&gt;的其他用法(其实上面说的那些规则也可以在&lt;code&gt;go help test&lt;/code&gt;帮助文档中找到)&lt;/p&gt;

&lt;p&gt;这里主要总结下几个常用的参数:
- -args: 指定一些测试时的参数(可以指定超时时间,cpu绑定,压测等等(go test包含单元测试，压力测试等))
- - -test.v: 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例
- - -test.run pattern: 只跑哪些单元测试用例
- - -test.bench patten: 只跑那些性能测试用例
- - -test.benchmem : 是否在性能测试的时候输出内存情况
- - -test.benchtime t : 性能测试运行的时间，默认是1s
- - -test.cpuprofile cpu.out : 是否输出cpu性能分析文件
- - -test.memprofile mem.out : 是否输出内存性能分析文件
- - -test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c: 编译测试文件到pkg.test,但是不会运行测试程序&lt;/li&gt;
&lt;li&gt;-exec xprog: 使用xprog参数来运行编译的测试文件(参数类似go run后的参数)&lt;/li&gt;
&lt;li&gt;-i: 安装测试程序中的依赖包，但是不运行测试程序&lt;/li&gt;
&lt;li&gt;-json: 以json格式输出测试结果&lt;/li&gt;
&lt;li&gt;-o file: 指定测试程序编译后生成的文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单元测试中常用的命令参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 对当前目录下的全部单元测试程序进行运行测试(也就是所有的xxx_test.go文件中的所有function都会运行)
$ go test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
ok  	_/Users/BGBiao/unittest	0.005s

# 查看详细的单元测试结果
# (go test -v 等同于go test -args -test.v)
$ go test -v
=== RUN   TestSetSomething
the rectangular name&#39;s result is ok
--- PASS: TestSetSomething (0.00s)
=== RUN   TestGetSomething
the rectangular volume&#39;s result is ok
--- PASS: TestGetSomething (0.00s)
PASS
ok  	_/Users/BGBiao/unittest	0.005s

# 指定单元测试function来进行测试(-run参数可以指定正则匹配模式-run=&amp;quot;test1|test2&amp;quot;)
# go test -v -run functionname 
$ go test -v -test.run TestGetSomething
=== RUN   TestGetSomething
the rectangular volume&#39;s result is ok
--- PASS: TestGetSomething (0.00s)
PASS
ok  	_/Users/BGBiao/unittest	0.005s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;单元测试注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在单元测试时，一个比较重要的事情就是如何构造测试数据，因为通常我们能够想到的测试数据都是在预期之中的，有些核心逻辑的测试数据往往不能考虑到，因此构造测试数据时可考虑如下几个方面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 正常输入: 正常的可预测的测试用例&lt;/li&gt;
&lt;li&gt;2. 边界输入: 极端情况下的输入来测试容错性&lt;/li&gt;
&lt;li&gt;3. 非法输入: 输入异常数据类型，整个逻辑是否能够正常处理或者捕获&lt;/li&gt;
&lt;li&gt;4. 白盒覆盖: 需要设计的测试用例能够覆盖所有代码(语句覆盖、条件覆盖、分支覆盖、分支/条件覆盖、条件组合覆盖)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在写项目时，对于基础的工具层&lt;code&gt;util&lt;/code&gt;的逻辑代码，一定要进行全方位，多场景的进行测试，否则当项目大起来后到处引用可能会造成较大麻烦;其次，我们的代码逻辑通常是更新迭代的，单元测试代码也应该进行定期更新.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;华丽的分割线&#34;&gt;华丽的分割线&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Golang的测试断言工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在&lt;code&gt;testing&lt;/code&gt;包中包含了一些常用的断言工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestPrint(t *testing.T) {
    // 输出测试日志
    t.Logf()
    // 标记错误，但仍然执行后面的语句
    t.Fail()
    // 获取是否当前用例是执行错误的
    t.Failed()
    // 错误输出，等于 t.Logf 再执行 t.Fail()
    t.Errorf(&amp;quot;%s&amp;quot;, &amp;quot;run ErrorF&amp;quot;)
    // 标记函数错误，并中断后面的执行
    t.FailNow()
    // 致命错误输出，等同于调用了 t.Logf 然后调用 t.FailNow()
    t.Fatalf(&amp;quot;%s&amp;quot;, &amp;quot;run Fatelf&amp;quot;)
    // 测试用例的名字
    t.Name()
    //运行子测试用例
    t.Run()
    // 跳过后面的内容，后面将不再运行
    t.SkipNow()
    // 告知当前的测试是否已被忽略
    t.Skipped()
    // 并行测试
    t.Parallel()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试覆盖率统计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;Golang内置工具包中也提供了测试覆盖率相关的工具，&lt;code&gt;go test&lt;/code&gt;常用参数如下:
- &lt;code&gt;-cover&lt;/code&gt;: 是否开启覆盖测试率统计的开关.(当有&lt;code&gt;-covermode&lt;/code&gt;、&lt;code&gt;-coverpkg&lt;/code&gt;、&lt;code&gt;-coverprofile&lt;/code&gt;参数时会自动打开)
- &lt;code&gt;-covermode&lt;/code&gt;: 设置覆盖测试率模式(可选值:set,count,atomic). set(默认)仅统计语法块是否覆盖;count 会统计语法块覆盖了多少次;atomic 用于多线程测试中统计语法块覆盖了多少次
- &lt;code&gt;-coverpkg&lt;/code&gt;: 指定覆盖率统计package的范围(默认只统计有执行了测试的packages)
- &lt;code&gt;-timeout&lt;/code&gt;: 指定单个测试用例的超时时间，默认10分钟
- &lt;code&gt;-coverprofile&lt;/code&gt;: 指定覆盖率profile文件的输出地址&lt;/p&gt;

&lt;p&gt;&lt;code&gt;第三方的测试覆盖统计&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://goconvey.co/&#34;&gt;goconvey&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/smartystreets/goconvey&#34;&gt;goconvey&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://codecov.io/&#34;&gt;codecov&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 使用golang内置的工具来执行覆盖测试，执行之后生成.test的执行文件，执行后会执行所有单元测试代码，然后输出覆盖率的报告
$ go test -c -covermode=count -coverpkg ./
➜  unittest git:(master) ✗ ls
area.go       area_test.go  unittest.test
➜  unittest git:(master) ✗ ./unittest.test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
coverage: 100.0% of statements in ./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;统计单元测试的覆盖率，也就是白盒测试的覆盖率.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;覆盖率测试报告&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 将测试覆盖率结果写入一个数据文件
$ go test -coverpkg=./ -coverprofile=coverage.data -timeout=5s

# 将覆盖率报告数据文件转化成对应的人类可识别模式(go tool cover可查看覆盖率相关的工具)
$  go tool cover -func=coverage.data -o coverage.txt
➜  unittest git:(master) ✗ cat coverage.txt
/Users/BGBiao/unittest/area.go:19:	Newbox		100.0%
/Users/BGBiao/unittest/area.go:23:	SetName		100.0%
/Users/BGBiao/unittest/area.go:27:	SetSize		100.0%
/Users/BGBiao/unittest/area.go:33:	GetName		100.0%
/Users/BGBiao/unittest/area.go:37:	GetVolume	100.0%
total:										(statements)	100.0%

# 转化成html格式(会在本地生成html文件)
$ go tool cover -html=coverage.data -o coverage.html

# 直接以html形式展示覆盖测试率报告
$ go tool cover -html=coverage.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8tw12ghvej317l0u0jvu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基准测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基准测试是测量一个程序在固定工作负载下的性能。在Golang中，基准测试函数和普通的单元测试函数写法类似，同样需要遵循以下规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.函数以&lt;code&gt;Benchmark&lt;/code&gt;开头&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2.函数参数为&lt;code&gt;b *testing.B&lt;/code&gt; (区别于单元测试的&lt;code&gt;t *testing.T&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: &lt;code&gt;*testing.B&lt;/code&gt;参数提供了一些额外的性能测量相关的方法，同时还提供了一个随机整数&lt;code&gt;N&lt;/code&gt;，用于限定执行的循环次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 编写benchmark函数
func Benchmark_GetSomething(b *testing.B) {
    box := Newbox()
    volume := 0
    for i := 0; i &amp;lt; b.N; i++ {
        box.SetSize(10,1111,2222)
        volume = box.GetVolume()
    }
    b.Log(volume)
}

# 运行测试(运行所有的基准测试，-bench可以指定函数名，-benchmem可以指定分配内存的次数和字节数)
# 和单元测试不同的是，我们需要使用-bench来手工指定需运行的基准测试函数(.表示全部的基准测试函数)
# 如下输出结果表示:GOMAXPROCS为4核心,每次调用GetSomething函数平均花费0.35ns(调用了2000000000次)
$ go test -v -run=&amp;quot;none&amp;quot; -bench=Benchmark_GetSomething -benchmem
goos: darwin
goarch: amd64
Benchmark_GetSomething-4   	2000000000	         0.35 ns/op	       0 B/op	       0 allocs/op
--- BENCH: Benchmark_GetSomething-4
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
PASS
ok  	_/Users/BGBiao/unittest	0.749s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;性能分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 当我们的程序在运行过程中可能会消耗非常多的资源(通常是程序性价比较低时，比如处理一个很小的数据，却占用了几个G的内存，并且CPU长期处于高负荷状态)，此时我们就需要通过一些技术手段来分析程序性能损耗点，以此来提高程序的性价比。&lt;/p&gt;

&lt;p&gt;Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。基本上常用的为&lt;code&gt;MEM分析&lt;/code&gt;、&lt;code&gt;CPU分析&lt;/code&gt;以及&lt;code&gt;block分析&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MEM分析: 主要是堆分析，可以标识出最耗内存的逻辑，内置库会会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CPU分析: 可以标识最耗CPU时间的函数,每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Block分析: 记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁; 当goroutine被这些操作阻塞时，剖析库都会记录相应的事件.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 剖析对于长期运行的程序尤其有用，因此可以通过调用Go的&lt;code&gt;runtime API&lt;/code&gt;来启用运行时剖析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 通过不同的参数来获取指定性能分析数据
$ go test -cpuprofile=cpu.out
$ go test -blockprofile=block.out
$ go test -memprofile=mem.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们通过上述内置工具获取到相关的分析数据，我们就可以使用&lt;code&gt;pprof&lt;/code&gt;来分析数据，使用&lt;code&gt;go help pprof&lt;/code&gt;可以查看更多帮助信息，最常用的即: 生成这个概要文件的可执行程序和对应的剖析数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 获取CPU基准测试数据
$ go test  -run=&amp;quot;none&amp;quot; -bench=Benchmark_GetSomething -cpuprofile=cpu.log
goos: darwin
goarch: amd64
Benchmark_GetSomething-4   	2000000000	         0.36 ns/op
--- BENCH: Benchmark_GetSomething-4
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
PASS
ok  	_/Users/BGBiao/unittest	0.944s
➜  unittest git:(master) ✗ ls
area.go       area_test.go  cpu.log       unittest.test

# 之后会生成测试程序和cpu分析数据(unittest.test和cpu.log) 
# 使用pprof工具分析相关数据(-text用于指定输出格式;-nodecount=10限制只输出前10行结果)
$ go tool pprof -text -nodecount=10 ./unittest.test cpu.log
File: unittest.test
Type: cpu
Time: Nov 11, 2019 at 12:12pm (CST)
Duration: 938ms, Total samples = 680ms (72.49%)
Showing nodes accounting for 680ms, 100% of 680ms total
      flat  flat%   sum%        cum   cum%
     510ms 75.00% 75.00%      680ms   100%  _/Users/BGBiao/unittest.Benchmark_GetSomething
     170ms 25.00%   100%      170ms 25.00%  _/Users/BGBiao/unittest.(*box).GetVolume
         0     0%   100%      680ms   100%  testing.(*B).launch
         0     0%   100%      680ms   100%  testing.(*B).runN

# web可视化分析(会弹出web页面,可查看程序每个逻辑的cpu使用)
$ go tool pprof -http=:8080 -nodecount=10 ./unittest.test cpu.log

# 对应的，我们也可以使用-memprofile参数来获取内存分析数据，来查看处理逻辑对内存的消耗状况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8tz9u4xz2j30u00xxdjd.jpg&#34; alt=&#34;cpu性能分析&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8u1yeltk4j305p0ptgmk.jpg&#34; alt=&#34;mem分配&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://johng.cn/go-test-profile-and-cover/&#34;&gt;Go性能测试、单元测试以及代码覆盖率&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Prometheus入门实践</title>
      <link>https://bgbiao.top/post/prometheus%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 20 Jun 2019 17:33:14 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/prometheus%E5%85%A5%E9%97%A8%E5%AE%9E%E8%B7%B5/</guid>
      
        <description>&lt;h2 id=&#34;prometheus入门实践&#34;&gt;Prometheus入门实践&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://prometheus.io/download/&#34;&gt;Prometheus下载地址&lt;/a&gt;
&lt;a href=&#34;https://www.kubernetes.org.cn/tags/prometheus&#34;&gt;Prometheus相关文档&lt;/a&gt;
&lt;a href=&#34;https://prometheus.io/docs/introduction/overview/&#34;&gt;Prometheus官方文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;一-基本原理&#34;&gt;一、基本原理&lt;/h3&gt;

&lt;p&gt;通过&lt;code&gt;HTTP协议周期性抓取被监控组件的状态&lt;/code&gt;,任意组件只要提供对应的HTTP接口就可以接入监控。&lt;/p&gt;

&lt;p&gt;输出被监控组件信息的HTTP接口被叫做&lt;code&gt;exporter&lt;/code&gt;,也就是数据采集端，通常来说，最需要接入改造的就是expoter. 当前互联网上已经有很多成熟的&lt;code&gt;exporter&lt;/code&gt;组件，当然用户也可用根据官方提供的sdk自行编写exporter.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bookstack.cn/read/prometheus-manual/instrumenting-exporters.md&#34;&gt;开箱即用的exporter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://prometheus.io/docs/instrumenting/clientlibs/&#34;&gt;官方的sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/oliver006/redis_exporter&#34;&gt;redis-exporter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:prometheus的时间序列数据分为四种类型&lt;/code&gt;
- Counter: 收集的数据是按照某个趋势（增加／减少）一直变化的，我们往往用它记录服务请求总量，错误总数等
- Gauge: 搜集的数据是一个瞬时的，与时间没有关系，可以任意变高变低，往往可以用来记录内存使用率、磁盘使用率等
- Histogram: 用于表示一段时间范围内对数据进行采样,并能够对其指定区间以及总数进行统计，通常我们用它计算分位数的直方图。
- Summary: 和Histogram类似，用于表示一段时间内数据采样结果。它直接存储了 quantile 数据，而不是根据统计区间计算出来的&lt;/p&gt;

&lt;h3 id=&#34;二-组件介绍&#34;&gt;二、组件介绍&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1. Prometheus-server: 负责&lt;code&gt;数据采集和存储(TSDB)&lt;/code&gt;,提供PromQL查询语言的支持&lt;/li&gt;
&lt;li&gt;2. Alertmanager: 警告管理器，用来进行报警&lt;/li&gt;
&lt;li&gt;3. Push Gateway: 支持临时性Job主动推送指标的中间网关(通常对应于短声明周期的任务监控)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三-服务过程&#34;&gt;三、服务过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;Prometheus Daemon&lt;/code&gt;定时去目标上抓取&lt;code&gt;metrics(指标)数据&lt;/code&gt;,每个抓取目标需要暴露一个http服务的接口给server进行定时获取。支持配置文件、文本文件、Zookeeper、Consul、DNS SRV Lookup方式抓取目标；对于长生命周期的服务，采用Pull模式定期拉取数据，对于段生命周期的任务，通过push-gateway来主动推送数据&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;Prometheus&lt;/code&gt;本地存储抓取的所有数据，并通过一定规则进行清理和整理数据，并把得到的结果存储到新的时间序列中。&lt;/li&gt;
&lt;li&gt;3. Prometheus通过PromQL和其他API可视化地展示收集的数据. 可以作为&lt;code&gt;Grafana&lt;/code&gt;的数据源进行图标输出，也可通过API对外提供数据展示&lt;/li&gt;
&lt;li&gt;4. &lt;code&gt;PushGateway&lt;/code&gt;支持client主动推送metrics到push-gateway(相当于是一个常驻的exporter服务),prometheus定期去push-gateway中获取数据&lt;/li&gt;
&lt;li&gt;5. &lt;code&gt;Alertmanager&lt;/code&gt;是独立于prometheus的一个组件，支持PromQL查询语句，提供灵活的报警功能&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;四-pronetheus服务构建使用&#34;&gt;四、pronetheus服务构建使用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://prometheus.io/download/&#34;&gt;下载地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源码安装&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 三个组件
$ wget https://github.com/prometheus/node_exporter/releases/download/v0.18.1/node_exporter-0.18.1.linux-amd64.tar.gz -O node_exporter-0.18.1.tar.gz

$ wget https://github.com/prometheus/prometheus/releases/download/v2.10.0/prometheus-2.10.0.linux-amd64.tar.gz -O prometheus-2.10.0.linux-amd64.tar.gz

$ wget https://github.com/prometheus/pushgateway/releases/download/v0.8.0/pushgateway-0.8.0.linux-amd64.tar.gz -O pushgateway-0.8.0.linux-amd64.tar.gz


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;docker方式安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:prometheus默认使用yaml格式来定义配置文件&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 编写prometheus默认配置文件
$ cat prometheus.yml
global:
  scrape_interval:     15s
  evaluation_interval: 15s

rule_files:
  # - &amp;quot;first.rules&amp;quot;
  # - &amp;quot;second.rules&amp;quot;

scrape_configs:
  # 会在每个metrics数据中增加job=&amp;quot;prometheus&amp;quot;和instance=&amp;quot;localhost:9090&amp;quot;的基本数据
  - job_name: prometheus
    static_configs:
      - targets: [&#39;localhost:9090&#39;]

# 热启动prometheus服务
$ docker run --name=prometheus -d -p 9090:9090  -v /Users/xuxuebiao/Desktop/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle

$ docker ps -l
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
5e1698a320b2        prom/prometheus     &amp;quot;/bin/prometheus -...&amp;quot;   3 days ago          Up 2 minutes        0.0.0.0:9090-&amp;gt;9090/tcp   prometheus


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; prometheus为golang编写的程序，因此只有一个二进制文件，使用&amp;ndash;config.file来制定配置文件，使用&amp;ndash;web.enable-lifecycle来启用远程热加载配置文件. 调用指令&lt;code&gt;curl -X POST http://localhost:9090/-/reload&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此时可以访问&lt;a href=&#34;http://localhost:9090&#34;&gt;prometheus-web&lt;/a&gt;即可查看prometheus的状态页面。此时它会每30s对自己暴露的http metrics数据进行采集。可以访问prometheus本身的&lt;a href=&#34;http://localhost:9090/metrics&#34;&gt;metrics数据&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-e6e1d386fcd43a0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus-graph&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-64dcaa81e432aa04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus-metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-746ef7f040089d80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus-当前收集上来的指标项&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-5d97ef27b313ef6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;go-info指标&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-943befcf74a6d6a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;单metrics指标数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过node exporter提供metrics&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 启动node-exporter
$ docker run -d --name=node-exporter -p 9100:9100  prom/node-exporter
$ docker ps -l
CONTAINER ID        IMAGE                COMMAND                CREATED             STATUS              PORTS                    NAMES
0f60bcce1ea6        prom/node-exporter   &amp;quot;/bin/node_exporter&amp;quot;   3 days ago          Up 42 seconds       0.0.0.0:9100-&amp;gt;9100/tcp   node-exporter
# 查看服务暴露的metrics
$ curl http://localhost:9100/metrics

# 将配置暴露给prometheus，并重载prometheus
$ cat prometheus.yml
global:
  scrape_interval:     15s
  evaluation_interval: 15s

rule_files:
  # - &amp;quot;first.rules&amp;quot;
  # - &amp;quot;second.rules&amp;quot;

scrape_configs:
  - job_name: prometheus
    static_configs:
      - targets: [&#39;localhost:9090&#39;]
			# 增加一个target 并附加一个label来标记该metrics
      # 注意:在prometheus启动时增加了一些参数,因此target不需要写协议和uri(http和/metrics)
      - targets: [&#39;10.13.13.60:9100&#39;]
        labels:
          group: &amp;quot;client-node-exporter&amp;quot;


# prometheus服务重载
$ curl -X POST http://localhost:9090/-/reload

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-0daae077328b80f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;node-exporter数据采集到prometheus&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-4461cc2d08501e1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;node-exporter采集的15分钟平均负载&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:如果需要同时查找多个项，其实需要熟悉prometheus的表达式编写&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;五-安装pushgateway&#34;&gt;五、安装pushgateway&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:push-gateway服务启动后也需要将endpoint加入prometheus中&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 启动push-gateway服务
docker run -d -p 9091:9091 --name pushgateway prom/pushgateway

# 查看push-gateway服务
$ curl localhost:9091

# 测试push一条metrics数据到Push-gateway
echo &amp;quot;tps 100&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb

# 多指标推送
cat &amp;lt;&amp;lt;EOF | curl --data-binary @- http://localhost:9091/metrics/job/xxb/instance/bgbiao
tps{label=&amp;quot;xxb&amp;quot;} 8800
tps1 100
tps2 160
tps3 160
EOF

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-e7a94dd04483137d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;push-gateway服务&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-1956a56a26dda95f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus增加push-gateway&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-1b3319b62dfd036d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;push-gateway采集上来的数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-e2e614fc197f2a50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus上查看push-gateway上报的数据&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;六-安装grafana进行图标展示&#34;&gt;六、安装Grafana进行图标展示&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 创建grafana服务
$ docker run -d -p 3000:3000 --name grafana grafana/grafana

$ curl localhost:3000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加数据源，以及基本数据验证&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 向prometheus的push-gateway上主动push数据模拟数据上报
➜  Desktop echo &amp;quot;tps 10&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
➜  Desktop echo &amp;quot;tps 9&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
➜  Desktop echo &amp;quot;tps 20&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
➜  Desktop echo &amp;quot;tps 30&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
➜  Desktop echo &amp;quot;tps 310&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
➜  Desktop echo &amp;quot;tps 222&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-d442c89b5796b2da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;grafana数据源配置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-6f234d69ad8ff8e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;grafana查看prometheus中收集的metrics数据&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;七-安装altermanager&#34;&gt;七、安装AlterManager&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Prometheus&lt;/code&gt;中的告警由独立的两部分组成
- 1. Prometheus服务中的警告规则发送警告到Alertmanager
- 2. Alertmanager管理这些警告.包含:silencing, inhibition, aggregation 并通过一些方式发送通知&lt;/p&gt;

&lt;p&gt;建立告警和通知的基本步骤:
- 1. 创建和配置alertmanager
- 2. 启动prometheus服务时，通过alertmanager.url 配置报警服务alertmanager服务，prometheus和alertmanager通信连接&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;启动altermanager服务&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 编辑alertmanager配置文件
$cat alertmanager.yml
global:
  resolve_timeout: 5m
route:
  group_by: [&#39;cqh&#39;]
  group_wait: 10s #组报警等待时间
  group_interval: 10s #组报警间隔时间
  repeat_interval: 1m #重复报警间隔时间
  receiver: &#39;web.hook&#39;
receivers:
  - name: &#39;web.hook&#39;
    webhook_configs:
      - url: &#39;http://10.13.118.71:8889/open/test&#39;
inhibit_rules:
  - source_match:
      severity: &#39;critical&#39;
    target_match:
      severity: &#39;warning&#39;
    equal: [&#39;alertname&#39;, &#39;dev&#39;, &#39;instance&#39;]

# 启动服务
$ docker run -d -p 9093:9093 --name alertmanager -v /Users/xuxuebiao/Desktop/alertmanager.yml:/etc/alertmanager/alertmanager.yml prom/alertmanager

$ docker ps -l
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
c6ba74bfd03b        prom/alertmanager   &amp;quot;/bin/alertmanager...&amp;quot;   3 days ago          Up 7 seconds        0.0.0.0:9093-&amp;gt;9093/tcp   alertmanager

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-f2e6dec465c35f4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;alertmanager服务&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在prometheus中配置altermanager服务&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 编辑rule配置
$ cat rules.yml
groups:
  # tps 超过150 并且持续10s就报警告通知
  - name: bgbiao
    rules:
      - alert: bgbiao测试
        expr: tps &amp;gt; 150
        for: 10s
        labels:
          status: warning
        annotations:
          summary: &amp;quot;{{$labels.instance}}:tps 超过阈值150.&amp;quot;
          description: &amp;quot;{{$labels.instance}}:tps 超过阈值!. 当前值: {{ $value }}&amp;quot;



# 修改prometheus主配置文件
$ cat prometheus.yml
global:
  # 默认抓取时间间隔为15s
  scrape_interval:     15s
  # 计算rule的间隔
  evaluation_interval: 15s
  # 定义额外的label
  external_labels:
    monitor: &amp;quot;bgbiao-monitor&amp;quot;

rule_files:
  - /etc/prometheus/rules.yml
  # - &amp;quot;first.rules&amp;quot;
  # - &amp;quot;second.rules&amp;quot;

# 抓取对象
scrape_configs:
  - job_name: prometheus
    # 重写数据抓取时间(局部生效)
    scrape_interval: 5s
    static_configs:
      - targets: [&#39;localhost:9090&#39;]
        labels:
          group: &amp;quot;prom&amp;quot;
      - targets: [&#39;10.13.118.71:9100&#39;]
        labels:
          group: &amp;quot;node-exporter&amp;quot;
      - targets: [&#39;10.13.118.71:9091&#39;]
        labels:
          group: &amp;quot;push-gateway&amp;quot;

# 配置报警对象
alerting:
  alertmanagers:
    - static_configs:
        - targets: [&amp;quot;10.13.118.71:9093&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重载prometheus服务&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -X POST http://localhost:9090/-/reload

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;重新导入数据测试&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 循环向push-gateway推送数据
$ cat test-abc.sh
#!/bin/bash
#Author_by:Andy_xu @JR-OPS
num=`date +%s | cut -c10-13`
metrics=`date +%s | cut -c${num}-13`
echo $metrics
echo &amp;quot;tps $metrics&amp;quot; | curl --data-binary @- http://localhost:9091/metrics/job/xxb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-b710723c6e4f9e9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;模拟报警数据&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-2e90930e7db5d1e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;alertmanager中显示的报警规则&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-e3fb656620be40e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus中已出现红色报警&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/2577135-1e0a57bafbb71e5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;prometheus报警详细内容&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;八-后续优化&#34;&gt;八、后续优化&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 此时使用prometheus可以监控到基础服务的资源使用情况，并且也可用借用&lt;code&gt;alertmanager&lt;/code&gt;服务对相关报警规则进行检测和报警，那么需要如何把相关报警及时的通知到相关负责人呢。我们前面在&lt;code&gt;alertmanager&lt;/code&gt;服务中配置了一个web-hook,即&lt;code&gt;http://10.13.118.71:8889/open/test&lt;/code&gt;，可以在alertmanager服务的&lt;code&gt;status&lt;/code&gt;中找到。我们可以很好的借助这个web-hook来对相关的报警发送。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 一个临时用来测试的web-hook服务
$ cat test-web-hook.go
/**
 * @File Name: test-web-hook.go
 * @Author: xxbandy @http://xxbandy.github.io
 * @Email:
 * @Create Date: 2019-06-19 14:06:48
 * @Last Modified: 2019-06-19 15:06:13
 * @Description: 一个临时用来测试的web-hook服务
 * @build:
 GOOS=darwin GOARCH=amd64 CGO_ENABLED=0  build -ldflags &#39;-w -s&#39; -o prometheus-web-hook test-web-hook.go
 */

package main
import (
    &amp;quot;github.com/gin-gonic/gin&amp;quot;
    &amp;quot;net/http&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;fmt&amp;quot;
)


func main() {
   router := gin.Default()
   router.GET(&amp;quot;/open/test&amp;quot;, CollectData)
   router.POST(&amp;quot;/open/test&amp;quot;, CollectData)

   router.Run(&amp;quot;:8889&amp;quot;)

}

func CollectData(c *gin.Context) {
    alertdata,_ := ioutil.ReadAll(c.Request.Body)
    fmt.Println(string(alertdata))
    c.JSON(http.StatusOK,nil)

}

# 构建成二进制文件
$ GOOS=darwin GOARCH=amd64 CGO_ENABLED=0  build -ldflags &#39;-w -s&#39; -o prometheus-web-hook test-web-hook.go
$ chmod a+x prometheus-web-hook

# 运行web-hook并收集报警信息
➜  ./prometheus-web-hook
[GIN-debug] [WARNING] Now Gin requires Go 1.6 or later and Go 1.7 will be required soon.

[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &amp;quot;debug&amp;quot; mode. Switch to &amp;quot;release&amp;quot; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] GET    /open/test                --&amp;gt; main.CollectData (3 handlers)
[GIN-debug] POST   /open/test                --&amp;gt; main.CollectData (3 handlers)
[GIN-debug] Listening and serving HTTP on :8889
{&amp;quot;receiver&amp;quot;:&amp;quot;web\\.hook&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;firing&amp;quot;,&amp;quot;alerts&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;firing&amp;quot;,&amp;quot;labels&amp;quot;:{&amp;quot;alertname&amp;quot;:&amp;quot;bgbiao测试&amp;quot;,&amp;quot;exported_job&amp;quot;:&amp;quot;xxb&amp;quot;,&amp;quot;group&amp;quot;:&amp;quot;push-gateway&amp;quot;,&amp;quot;instance&amp;quot;:&amp;quot;10.13.118.71:9091&amp;quot;,&amp;quot;job&amp;quot;:&amp;quot;prometheus&amp;quot;,&amp;quot;monitor&amp;quot;:&amp;quot;bgbiao-monitor&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;warning&amp;quot;},&amp;quot;annotations&amp;quot;:{&amp;quot;description&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值!. 当前值: 26986&amp;quot;,&amp;quot;summary&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值150.&amp;quot;},&amp;quot;startsAt&amp;quot;:&amp;quot;2019-06-19T06:17:19.247257311Z&amp;quot;,&amp;quot;endsAt&amp;quot;:&amp;quot;0001-01-01T00:00:00Z&amp;quot;,&amp;quot;generatorURL&amp;quot;:&amp;quot;http://5e1698a320b2:9090/graph?g0.expr=tps+%3E+150\u0026g0.tab=1&amp;quot;}],&amp;quot;groupLabels&amp;quot;:{},&amp;quot;commonLabels&amp;quot;:{&amp;quot;alertname&amp;quot;:&amp;quot;bgbiao测试&amp;quot;,&amp;quot;exported_job&amp;quot;:&amp;quot;xxb&amp;quot;,&amp;quot;group&amp;quot;:&amp;quot;push-gateway&amp;quot;,&amp;quot;instance&amp;quot;:&amp;quot;10.13.118.71:9091&amp;quot;,&amp;quot;job&amp;quot;:&amp;quot;prometheus&amp;quot;,&amp;quot;monitor&amp;quot;:&amp;quot;bgbiao-monitor&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;warning&amp;quot;},&amp;quot;commonAnnotations&amp;quot;:{&amp;quot;description&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值!. 当前值: 26986&amp;quot;,&amp;quot;summary&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值150.&amp;quot;},&amp;quot;externalURL&amp;quot;:&amp;quot;http://c6ba74bfd03b:9093&amp;quot;,&amp;quot;version&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;groupKey&amp;quot;:&amp;quot;{}:{}&amp;quot;}

[GIN] 2019/06/19 - 15:24:10 | 200 |     727.873µs |    10.13.118.71 | POST     /open/test
{&amp;quot;receiver&amp;quot;:&amp;quot;web\\.hook&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;firing&amp;quot;,&amp;quot;alerts&amp;quot;:[{&amp;quot;status&amp;quot;:&amp;quot;firing&amp;quot;,&amp;quot;labels&amp;quot;:{&amp;quot;alertname&amp;quot;:&amp;quot;bgbiao测试&amp;quot;,&amp;quot;exported_job&amp;quot;:&amp;quot;xxb&amp;quot;,&amp;quot;group&amp;quot;:&amp;quot;push-gateway&amp;quot;,&amp;quot;instance&amp;quot;:&amp;quot;10.13.118.71:9091&amp;quot;,&amp;quot;job&amp;quot;:&amp;quot;prometheus&amp;quot;,&amp;quot;monitor&amp;quot;:&amp;quot;bgbiao-monitor&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;warning&amp;quot;},&amp;quot;annotations&amp;quot;:{&amp;quot;description&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值!. 当前值: 26986&amp;quot;,&amp;quot;summary&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值150.&amp;quot;},&amp;quot;startsAt&amp;quot;:&amp;quot;2019-06-19T06:17:19.247257311Z&amp;quot;,&amp;quot;endsAt&amp;quot;:&amp;quot;0001-01-01T00:00:00Z&amp;quot;,&amp;quot;generatorURL&amp;quot;:&amp;quot;http://5e1698a320b2:9090/graph?g0.expr=tps+%3E+150\u0026g0.tab=1&amp;quot;}],&amp;quot;groupLabels&amp;quot;:{},&amp;quot;commonLabels&amp;quot;:{&amp;quot;alertname&amp;quot;:&amp;quot;bgbiao测试&amp;quot;,&amp;quot;exported_job&amp;quot;:&amp;quot;xxb&amp;quot;,&amp;quot;group&amp;quot;:&amp;quot;push-gateway&amp;quot;,&amp;quot;instance&amp;quot;:&amp;quot;10.13.118.71:9091&amp;quot;,&amp;quot;job&amp;quot;:&amp;quot;prometheus&amp;quot;,&amp;quot;monitor&amp;quot;:&amp;quot;bgbiao-monitor&amp;quot;,&amp;quot;status&amp;quot;:&amp;quot;warning&amp;quot;},&amp;quot;commonAnnotations&amp;quot;:{&amp;quot;description&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值!. 当前值: 26986&amp;quot;,&amp;quot;summary&amp;quot;:&amp;quot;10.13.118.71:9091:tps 超过阈值150.&amp;quot;},&amp;quot;externalURL&amp;quot;:&amp;quot;http://c6ba74bfd03b:9093&amp;quot;,&amp;quot;version&amp;quot;:&amp;quot;4&amp;quot;,&amp;quot;groupKey&amp;quot;:&amp;quot;{}:{}&amp;quot;}

[GIN] 2019/06/19 - 15:25:20 | 200 |     129.897µs |    10.13.118.71 | POST     /open/test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;注意:我们这里的web-hook服务其实是将报警信息临时全部打印出来了，其实可以根据用户关心程度，将相关值取出来直接发送至用户终端，比如钉钉，微信，或者短信&lt;/code&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang中的异常处理</title>
      <link>https://bgbiao.top/post/golang-expect/</link>
      <pubDate>Wed, 06 Mar 2019 16:01:23 +0800</pubDate>
      
      <guid>https://bgbiao.top/post/golang-expect/</guid>
      
        <description>&lt;h2 id=&#34;golang的异常处理和单元测试&#34;&gt;Golang的异常处理和单元测试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1.Golang语言中没有其他语言中的&lt;code&gt;try...catch...&lt;/code&gt;语句来捕获异常和异常恢复&lt;/li&gt;
&lt;li&gt;2.在Golang中我们通常会使用&lt;code&gt;panic&lt;/code&gt;关键字来抛出异常，在&lt;code&gt;defer&lt;/code&gt;中使用&lt;code&gt;recover&lt;/code&gt;来捕获异常进行具体逻辑处理&lt;/li&gt;
&lt;li&gt;3.Golang中我们通常会在函数或方法中返回&lt;code&gt;error&lt;/code&gt;结构对象来判断是否有异常出现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意事项&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.利用&lt;code&gt;recover&lt;/code&gt;和&lt;code&gt;panic&lt;/code&gt;指令，&lt;code&gt;defer&lt;/code&gt;必须放在panic之前定义(&lt;code&gt;panic会终止其后要执行的代码&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;2.&lt;code&gt;recover&lt;/code&gt;只有在&lt;code&gt;defer&lt;/code&gt;调用的函数中才有效，否则&lt;code&gt;recover&lt;/code&gt;无法捕获到&lt;code&gt;panic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;3.&lt;code&gt;recover&lt;/code&gt;处理异常后，业务逻辑会跑到&lt;code&gt;defer&lt;/code&gt;之后的处理片段中&lt;/li&gt;
&lt;li&gt;4.多个&lt;code&gt;defer&lt;/code&gt;会形成&lt;code&gt;defer栈&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5.panic会等到整个&lt;code&gt;goroutine&lt;/code&gt;退出才会报告错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;常规使用&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;panic&lt;/code&gt;以及&lt;code&gt;recover&lt;/code&gt;参数类型为空接口(可存储任何类型对象)&lt;code&gt;interface{}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
func panic(v interface{})
func recover() interface{}
执行顺序:panic()-&amp;gt;带recover的defer
输出结果:
oh my god!panic.
解释:
defer中的recover成功捕获到了panic的异常
*/

package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
defer func() {
    if err := recover(); err != nil {
        fmt.Println(err)    
    }
}()
panic(&amp;quot;oh my god!panic.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;延迟调用中引发的错误，可被后续延迟调用捕获(&lt;code&gt;仅最后一个错误被捕获&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
执行顺序:panic()-&amp;gt;带panic的defer匿名函数-&amp;gt;带recover()的defer匿名函数
输出结果:
catch the panic
解释:
defer中的recover仅能捕获最后一个错误
package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
defer func() {
    if err := recover();err != nil {
        fmt.Println(&amp;quot;catch the panic&amp;quot;)
    }
}()
defer func() {
    panic(&amp;quot;oh my god! panic.&amp;quot;)
}()

panic(&amp;quot;something panic!&amp;quot;)

}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;捕获函数&lt;code&gt;recover()&lt;/code&gt;只有在&lt;code&gt;defer&lt;/code&gt;调用内直接调用才会终止，否则返回&lt;code&gt;nil&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
代码执行顺序:panic-&amp;gt;在匿名函数中嵌套recover的defer函数-&amp;gt;带fmt的defer-&amp;gt;带recover的defer-&amp;gt;在匿名函数中调用recover的defer
输出结果:
defer inner
&amp;lt;nil&amp;gt;
defer recover panic error
解释: 多个defer之间形成defer栈，最底部的defer优先执行;第三个defer打印了recover()的零值`nil`，仅有第一个defer成功捕获了最底部的panic(&amp;quot;panic error&amp;quot;)
*/
package main
import &amp;quot;fmt&amp;quot;
func main() {
defer func() {
    fmt.Println(&amp;quot;defer recover&amp;quot;,recover())
}()
defer recover()
defer fmt.Println(recover())
defer func() {
    func(){
        fmt.Println(&amp;quot;defer inner&amp;quot;)
        recover()
    }()
}()
panic(&amp;quot;panic error&amp;quot;)
}      
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将代码块放置在匿名函数中可实现在函数逻辑中进行异常恢复，而不影响主函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
代码执行顺序:匿名函数中的panic语句-&amp;gt;匿名函数中i自加运算-&amp;gt;匿名函数中的fmt-&amp;gt;匿名函数中的defer-&amp;gt;主函数中的fmt
输出结果:
i is: 2
解释:panic会终止其之后的执行，因此优先执行匿名函数中的panic之后便被defer中的recover捕获，将i赋值为2，其后匿名函数退出开始继续执行主函数中的fmt.Println语句
*/
package main
import &amp;quot;fmt&amp;quot;
func main() {
test()
}
func test() {
var i int
func() {
    defer func(){
        if err := recover();err != nil {
            i = 2
        }
    }()
    panic(&amp;quot;something panic!&amp;quot;)
    i += 8
    fmt.Println(&amp;quot;no panic, i is:&amp;quot;,i)
}()
fmt.Println(&amp;quot;i is:&amp;quot;,i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;goroutine中的recover&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;如果一个没有&lt;code&gt;recover&lt;/code&gt;的&lt;code&gt;goroutine&lt;/code&gt;发生了panic，那么整个进程都会挂掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
sync.WaitGroup用来等待一组goroutine的结束,Add方法用来设置等待的goroutine数量,Done方法表示一个goroutine运行结束,使用Wait方法将全部的goroutine阻塞住,直到全部goroutine执行完毕

代码执行顺序:goroutine中的逻辑-&amp;gt;wg.Wait()-&amp;gt;fmt.Println
输出结果:
panic recover assignment to entry in nil map
donw
解释:
在goroutine中我们声明了一个info的map[string]string类型，我们都知道在map,slice,channel都是引用类型，需要使用make函数进行初始化操作之后进行赋值。而这里直接使用info[&amp;quot;name&amp;quot;] = &amp;quot;BGBiao&amp;quot;进行赋值导致panic，fmt.Println函数就会被终止执行，从而执行带recover的defer，之后执行带wg.Done()的defer并退出goroutine执行主程序逻辑
*/
package main
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
)
func main() {
    var wg sync.WaitGroup
    wg.Add(4)
    go func() {
        defer wg.Done()
        defer func() {
            if err := recover();err != nil {
                fmt.Println(&amp;quot;panic recover&amp;quot;,err)
            }
        }()
        var info map[string]string
        info[&amp;quot;name&amp;quot;] = &amp;quot;BGBiao&amp;quot;
        fmt.Println(info)
    }()
    wg.Wait()
    fmt.Println(&amp;quot;done&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>使用Python来操作Hive中的数据</title>
      <link>https://bgbiao.top/post/operatehivewithpython/</link>
      <pubDate>Sun, 28 Oct 2018 14:14:39 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/operatehivewithpython/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景:在整个运维内部数据仓库构建中，我们使用了Hadoop大数据生态圈中的组件来支撑运维数据的数据仓库构建。我们使用了&lt;a href=&#34;http://hive.apache.org/&#34;&gt;Hive&lt;/a&gt;作为数据仓库工具，同时使用&lt;a href=&#34;https://github.com/cloudera/hue&#34;&gt;Hue&lt;/a&gt;来对整个运维数据进行管理和查询，最终根据部门需求生成结构化数据存入关系型或K/V型数据库，以供其他部门进行商业化决策。但是在使用command-line方式和hue上操作hive时，经常会有些许问题，并且灵活性交差，因此为了改善数据到Hive的加载过程以及对Hive库中数据的操作，借此机会使用PyHive库进行操作管理Hive.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本篇简单记录下使用Python操作Hive。&lt;/p&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;我们当前整个&lt;a href=&#34;https://baike.baidu.com/item/ETL/1251949&#34;&gt;ETL&lt;/a&gt;过程大概如下:
- 1.使用Python程序对各个维度的运维数据进行采集、加工和初步的清洗处理,按照一定的数据标准和数仓模型进行数据存储
- 2.将上述抽取出来的相对结构化的数据存储到HDFS集群中
- 3.使用Hive定期从HDFS集群中加载数据，并根据已有数据进行再次加工处理，并提取价值信息&lt;/p&gt;

&lt;p&gt;ETL的质量问题具体表现为正确性、完整性、一致性、完备性、有效性、时效性和可获取性等几个特性。由于我们构建的运维数据仓库需要涉及到不同的数据源，且数据源的数据模型各不相同，为保证数据的正确性和完整性，数据加工过程选择在源数据库端执行，进行初步清洗加工后再进行转储到目标数据仓库中。&lt;/p&gt;

&lt;h3 id=&#34;python操作hive&#34;&gt;Python操作Hive&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:想要使用hive，必须要有一个可用的hive集群，同时为了保证可用使用API操作hive，我们需要要求提供hiveserver2服务&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;假设我们的hiveserver2地址为&lt;code&gt;10.0.1.18:10000&lt;/code&gt;,且用户为&lt;code&gt;hdfs&lt;/code&gt;.使用&lt;a href=&#34;https://pypi.org/project/PyHive/&#34;&gt;PyHive&lt;/a&gt;库链接Hive.&lt;/p&gt;

&lt;h4 id=&#34;安装pyhive模块&#34;&gt;安装pyhive模块&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 过程中可能需要依赖sasl，thrift等相关服务，如有需要可以使用系统的包管理器安装(apt-get或yum)
pip install sasl thrift thrift-sasl PyHive
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;python链接hive以及基本使用&#34;&gt;Python链接Hive以及基本使用&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;$ cat pytest_hive.py
# 导入hive模块
from pyhive import hive

# 获取一个hive链接对象(链接到HiveServer2上)
## Connection类的__init__方法:__init__(self, host=None, port=None, username=None, database=u&#39;default&#39;, auth=None, configuration=None, kerberos_service_name=None, password=None, thrift_transport=None)
hiveconn = hive.Connection(host=&#39;10.0.1.18&#39;, port=10000, username=&#39;hdfs&#39;, database=&#39;aiops&#39;)

# 使用连接的cursor()方法获取一个游标对象
hivecur = hiveconn.cursor()

# 使用游标对象的execute()方法进行执行hivesql语句
## execute(self, operation, parameters=None, **kwargs)
hivecur.execute(&amp;quot;show databases&amp;quot;)
## executemany(self, operation, seq_of_parameters) method of pyhive.hive.Cursor instance 参数是一个序列
hivecur.executemany()

# 使用游标对象的fetch类方法获取执行结果(fetchone和fetchall以及fetchmany)
onedata = hivecur.fetchone()
alldata = hivecur.fetchall()
## fetchmany(self, size=None) method of pyhive.hive.Cursor instance
manydata = hivecur.fetchmany()

# 关闭cursor游标对象和conn连接对象
hivecur.close()
hiveconn.close()

# hive的回滚操作
hiveconn.rollback()

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;尝试用python脚本进行数据库操作&#34;&gt;尝试用python脚本进行数据库操作&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1. 数据库查询操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 首先我们使用pyhive库链接hive并查看指定数据库下的表
$ cat pyhive_test.py
import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)
from pyhive import hive

class hiveObj:
    def __init__(self,host,user,dbname=u&#39;default&#39;,port=10000):
        self.host = host
        self.dbname = dbname
        self.user = user
        self.port = port
    def hiveConIns(self):
        conn = hive.Connection(host=self.host, port=self.port, username=self.user, database=self.dbname)
        return conn
    #通常查询个别数量的数据建议在sql中进行优化，可以仅使用cursor的fetchall()方法进行批量操作
    def querydata(self,sql,args=None):
        conn = self.hiveConIns()
        cur = conn.cursor()
        cur.execute(sql,args)
        alldata = cur.fetchall()
        cur.close()
        #cur.fetch类方法返回一个[tuple,tuple]
        for data in alldata:
            print(data)
        conn.close()

if __name__ == &#39;__main__&#39;:
    #默认database为default,默认port为10000
    hiveobj = hiveObj(&amp;quot;10.0.1.18&amp;quot;,&amp;quot;hdfs&amp;quot;)
    #查询数据
    sql = &#39;&#39;&#39;show tables&#39;&#39;&#39;
    hiveobj.querydata(sql)

$ python pyhive_test.py
(u&#39;asset&#39;,)


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 数据库更新操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;思考:其实数据库可以分为两种操作(读和写)，一种为单纯的查询操作，不会对库表结构和数据造成变更，也即为读操作;另外一种为写操作，会对库表结构和数据造成的变更操作，也即写操作.&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 给我们的hiveObj类增加一个写数据操作方法
$ cat pyhive_test.py
....
....
    def changedata(self,sql,args=None):
        conn = self.hiveConIns()
        cur = conn.cursor()
        try:
            #做一个粗暴的判断当args是list时就进行批量插入
            if isinstance(args,list):
                #executemany(sql,args)方法args支持tuple或者list类型
                cur.executemany(sql,args)
            else:
                #execute(sql,args)方法args支持string,tuple,list,dict
                cur.execute(sql,args)
            conn.commit()
        except Exception as e:
            #因为hive不支持事务，因此虽然提供了rollback()但是是没用的
            #conn.rollback()
            print(e)
        finally:
            cur.close()
            conn.close()



# 使用创建表来模拟库表变更(实际上库的变更操作应该由专业的管理员进行审核后操作)
if __name__ == &#39;__main__&#39;:
    #默认database为default,默认port为10000
    hiveobj = hiveObj(&amp;quot;10.0.1.18&amp;quot;,&amp;quot;hdfs&amp;quot;)
    #查询数据
    sql = &#39;&#39;&#39;show tables&#39;&#39;&#39;
    hiveobj.querydata(sql)

    #hive库表变更操作
    tabledesc = &#39;&#39;&#39;
     create table appinfo (
        appname string,
        level string,
        leader string,
        dep string,
        ips  array&amp;lt;string&amp;gt;)
     ROW FORMAT DELIMITED
     FIELDS TERMINATED BY &#39;|&#39;
     COLLECTION ITEMS TERMINATED BY &#39;,&#39;
    &#39;&#39;&#39;
    print(&amp;quot;creating a table....&amp;quot;)
    hiveobj.changedata(tabledesc)
    hiveobj.querydata(sql)

$ python pyhive_test.py
(u&#39;asset&#39;,)
creating a table....
(u&#39;appinfo&#39;,)
(u&#39;asset&#39;,) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 进行数据加载和读取操作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:上面其实我们已经封装了两个抽象的读写方法，可以对hive表进行数据加载和读取操作了&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 假如我们的hdfs上已经存在一份如下结构化的数据
$ hdfs dfs -cat /ips.txt;
data-web|p0|bgbiao|ops1|10.0.0.1,10.0.0.2
data-api|p0|biaoge|sre1|192.168.0.1,192.168.0.2
data-models|p1|xxbandy|sre1|10.0.0.3,192.168.0.3

$ cat pyhive_test.py
...
...
if __name__ == &#39;__main__&#39;:
		#首先进行将hdfs中的数据加载到appinfo表中,加载完成后查询appinfo表
    sql1 = &amp;quot;load data  inpath &#39;hdfs://hdfs-name/ips.txt&#39; overwrite into table appinfo&amp;quot;
    hiveobj.changedata(sql1)
    hiveobj.querydata(&#39;select * from appinfo&#39;)

$ python pyhive_test.py
(u&#39;data-web&#39;, u&#39;p0&#39;, u&#39;bgbiao&#39;, u&#39;ops1&#39;, u&#39;[&amp;quot;10.0.0.1&amp;quot;,&amp;quot;10.0.0.2&amp;quot;]&#39;)
(u&#39;data-api&#39;, u&#39;p0&#39;, u&#39;biaoge&#39;, u&#39;sre1&#39;, u&#39;[&amp;quot;192.168.0.1&amp;quot;,&amp;quot;192.168.0.2&amp;quot;]&#39;)
(u&#39;data-models&#39;, u&#39;p1&#39;, u&#39;xxbandy&#39;, u&#39;sre1&#39;, u&#39;[&amp;quot;10.0.0.3&amp;quot;,&amp;quot;192.168.0.3&amp;quot;]&#39;)

# 接下来我们对上述表进行一个拆分查询
$ cat pyhive_test.py
...
...
if __name__ == &#39;__main__&#39;:
    #对array对象中的元素进行遍历查询
    sql = &amp;quot;select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    hiveobj.querydata(sql)

# 这样子我们就知道每个ip对应的关联关系了
$ python pyhive_test.py
(u&#39;10.0.0.1&#39;, u&#39;data-web&#39;, u&#39;bgbiao&#39;, u&#39;ops1&#39;)
(u&#39;10.0.0.2&#39;, u&#39;data-web&#39;, u&#39;bgbiao&#39;, u&#39;ops1&#39;)
(u&#39;192.168.0.1&#39;, u&#39;data-api&#39;, u&#39;biaoge&#39;, u&#39;sre1&#39;)
(u&#39;192.168.0.2&#39;, u&#39;data-api&#39;, u&#39;biaoge&#39;, u&#39;sre1&#39;)
(u&#39;10.0.0.3&#39;, u&#39;data-models&#39;, u&#39;xxbandy&#39;, u&#39;sre1&#39;)
(u&#39;192.168.0.3&#39;, u&#39;data-models&#39;, u&#39;xxbandy&#39;, u&#39;sre1&#39;)

# 临时表的创建和使用
    #对array对象中的元素进行遍历查询[临时表的创建第一次必须使用create table name as select ],更新数据需要使用[insert into|overwrite table name select] into是追加数据，overwrite是覆盖数据
    #sql = &amp;quot;create  table tmpapp as select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    #sql = &amp;quot;insert into table tmpapp select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    sql = &amp;quot;insert overwrite table tmpapp select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    hiveobj.changedata(sql)
    hiveobj.querydata(&#39;select * from tmpapp limit 1&#39;)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;4. 源码文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat pyhive_test.py
import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)
from pyhive import hive

class hiveObj:
    def __init__(self,host,user,dbname=u&#39;default&#39;,port=10000):
        self.host = host
        self.dbname = dbname
        self.user = user
        self.port = port
    def hiveConIns(self):
        conn = hive.Connection(host=self.host, port=self.port, username=self.user, database=self.dbname)
        return conn
    #通常查询个别数量的数据建议在sql中进行优化，可以仅使用cursor的fetchall()方法进行批量操作
    def querydata(self,sql,args=None):
        conn = self.hiveConIns()
        cur = conn.cursor()
        cur.execute(sql,args)
        alldata = cur.fetchall()
        cur.close()
        #cur.fetch类方法返回一个[tuple,tuple]
        for data in alldata:
            print(data)
        conn.close()
    #注意:hivesql的execute类方法的args是执行过程的参数，而不是sql的参数.比如cursor.execute(&#39;SELECT * FROM my_awesome_data LIMIT 10&#39;, async=True)表示异步执行
    def changedata(self,sql,args=None):
        conn = self.hiveConIns()
        cur = conn.cursor()
        try:
            #做一个粗暴的判断当args是list时就进行批量插入
            if isinstance(args,list):
                #executemany(sql,args)方法args支持tuple或者list类型
                cur.executemany(sql,args)
            else:
                #execute(sql,args)方法args支持string,tuple,list,dict
                cur.execute(sql,args)
            conn.commit()
        except Exception as e:
            #因为hive不支持事务，因此虽然提供了rollback()但是是没用的
            #conn.rollback()
            print(e)
        finally:
            cur.close()
            conn.close()

if __name__ == &#39;__main__&#39;:
    #默认database为default,默认port为10000
    hiveobj = hiveObj(&amp;quot;10.0.1.18&amp;quot;,&amp;quot;hdfs&amp;quot;)
    &#39;&#39;&#39;
    #查询数据
    sql = &amp;quot;show tables&amp;quot;
    hiveobj.querydata(sql)

    #hive创建表
    tabledesc = &amp;quot;create table appinfo (appname string,level string,leader string,dep string,ips  array&amp;lt;string&amp;gt;) ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;|&#39; COLLECTION ITEMS TERMINATED BY &#39;,&#39; &amp;quot;
    print(&amp;quot;creating a table....&amp;quot;)
    hiveobj.changedata(tabledesc)
    hiveobj.querydata(sql)

    #插入数据
    sql1 = &amp;quot;load data  inpath &#39;hdfs://hdfs-name/ips.txt&#39; overwrite into table appinfo&amp;quot;
    hiveobj.changedata(sql1)
    hiveobj.querydata(&#39;select * from appinfo&#39;)
    &#39;&#39;&#39;
    #对array对象中的元素进行遍历查询[临时表的创建第一次必须使用create table name as select ],更新数据需要使用[insert into|overwrite table name select] into是追加数据，overwrite是覆盖数据
    #sql = &amp;quot;create  table tmpapp as select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    #sql = &amp;quot;insert into table tmpapp select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    sql = &amp;quot;insert overwrite table tmpapp select ip,appname,leader,dep from appinfo  LATERAL VIEW explode(ips) appinfo  AS ip&amp;quot;
    hiveobj.changedata(sql)
    hiveobj.querydata(&#39;select * from tmpapp limit 1&#39;)
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>使用Python操作MySQL</title>
      <link>https://bgbiao.top/post/operatemysqlwithpython/</link>
      <pubDate>Sat, 27 Oct 2018 13:53:40 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/operatemysqlwithpython/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言: 最近做内部运维数据的数据仓库，最终将Hive中的数据清洗后需要业务决策相关的数据进行结构化处理，并存储到关系型数据库MySQL中，以供后期对外接口使用。本篇简单记录下使用Python操作MySQL数据库的简单操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;mysql数据库环境准备&#34;&gt;MySQL数据库环境准备&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:在当前容器化基础设施已经全面覆盖的时代，为了快速验证效果，我们及其推荐使用以Docker为代表的容器化基础设施来快速构建你的基础环境。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://hub.docker.com/&#34;&gt;DockerHub&lt;/a&gt;上有丰富的基础中间件的镜像，我们可以使用Docker快速的构建我们的MySQL基础环境，而不必每次重新安装各种复杂的中间件环境，因为我们只是使用者，我相信每个团队都会有专门的中间件维护者。好吧，如果没有，那你依然可以自己根据实际的需求和标准进行构建Docker镜像，这样就为我们创造了一个未来很长一段时间可复用的组件。总之，想说的一件事就是，下面的MySQL环境是用Docker容器跑的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 确保docker环境正常
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

# 下载MySQL指定版本的镜像
$ docker pull mysql:5.6
$ docker images | grep mysql
mysql                                     5.6                 d1f491b20727        2 days ago          256 MB

# 创建一个mysql实例[需要指定至少一个环境变量:MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD]
$ docker run -itd --name mysql -e MYSQL_ROOT_PASSWORD=&amp;quot;123456&amp;quot;  -P mysql:5.6
6c4428b341516c7eeec48cbc5b658a464f76b5f7d42b3e689151392f5cd8ac56

# MySQL密码为123456,端口为32773
$ docker ps
CONTAINER ID        IMAGE                                          COMMAND                  CREATED             STATUS              PORTS                                               NAMES
6c4428b34151        mysql:5.6                                      &amp;quot;docker-entrypoint.sh&amp;quot;   5 seconds ago       Up 3 seconds        0.0.0.0:32773-&amp;gt;3306/tcp                             mysql

# mysql数据库登录测试
$ mysql -h 127.0.0.1 -uroot -P 32773 -p123456
...
Server version: 5.6.42 MySQL Community Server (GPL)
Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.
...
mysql&amp;gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

# 查看数据库字符编码格式
mysql&amp;gt; show variables like &#39;%char%&#39;;
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client     | utf8                       |
| character_set_connection | utf8                       |
| character_set_database   | utf8                       |
| character_set_filesystem | binary                     |
| character_set_results    | utf8                       |
| character_set_server     | utf8                       |
| character_set_system     | utf8                       |
| character_sets_dir       | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
8 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，一个MySQL数据库已经准备好，需要我们注意的是，因为使用的是官方的Docker image，我们需要进行相关配置的检查和设置，否则可能会为后期的操作造成一定麻烦，比如设置数据库的字符编码.&lt;br /&gt;
让MySQL支持中文，一般而言需要关注以下几个点:
- 1. 修改MySQL配置中客户端和服务端的字符编码为&lt;code&gt;utf8&lt;/code&gt;，分别为[mysqld的default-character-set和character-set-server参数以及client的default-character-set参数]
- 2. 创建表时指定表的字符编码(default charset=utf8;)
- 3. 链接数据库的时候指定链接字符编码(charset=utf8)
- 4. 使用Python操作数据库时需要对Python文件进行utf8支持(#encoding=utf-8和sys.setdefaultencoding(utf-8))
- 5. 使用&lt;code&gt;show variables like &#39;%char%&#39;;&lt;/code&gt;命令检查mysql字符集是否为&lt;code&gt;utf8格式&lt;/code&gt;，并使用&lt;code&gt;SET NAMES UTF8; 或者set character_set_server = utf8;&lt;/code&gt;进行设置&lt;/p&gt;

&lt;h3 id=&#34;使用python进行操作mysql&#34;&gt;使用Python进行操作MySQL&lt;/h3&gt;

&lt;p&gt;首先，在使用之前我们需要对Python版的MySQL库有一个了解，当前主流的库有&lt;code&gt;MySQLdb&lt;/code&gt;,&lt;code&gt;PyMySQL&lt;/code&gt;和&lt;code&gt;SQLAlchemy&lt;/code&gt;.&lt;br /&gt;
- &lt;code&gt;MySQLdb&lt;/code&gt;:一般是Linux系统发行版中默认支持的，通常包名为&lt;code&gt;Python-MySQL&lt;/code&gt;，核心由C语言打造，接口精炼，性能最棒，缺点是环境依赖较多，安装复杂，近两年已停止更新，只支持Python2，不支持Python3
- &lt;code&gt;PyMySQL&lt;/code&gt;:纯python打造，接口与Python-MySQL兼容，安装方便，支持Python3
- &lt;code&gt;SQLAlchemy&lt;/code&gt;: 一个ORM框架，它并不提供底层的数据库操作，而是要借助于MySQLdb、PyMySQL等第三方库来完成，目前SQLAlchemy在Web编程领域应用广泛
&lt;code&gt;备注:其实还有类似mysqlclient之类的库，主要集成在一些web框架中作为依赖&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;由于为了快速实现业务逻辑，在接下来的操作中主要使用&lt;code&gt;PyMySQL&lt;/code&gt;库进行操作数据库，虽然性能不及&lt;code&gt;MySQLdb&lt;/code&gt;，但是可以使用&lt;code&gt;pymysql.install_as_MySQLdb()&lt;/code&gt;来兼容&lt;code&gt;MySQLdb&lt;/code&gt;，在业务正式上线时可以不改变业务代码逻辑而平滑的使用&lt;code&gt;MySQLdb&lt;/code&gt;库。&lt;/p&gt;

&lt;h4 id=&#34;安装pymysql库&#34;&gt;安装pymysql库&lt;/h4&gt;

&lt;p&gt;在&lt;code&gt;Linux&lt;/code&gt;环境下，大多数系统工具使用Python语言进行编写，因此在安装额外的Python模块时，通常会有几种选择:
- 1. 使用系统自带工具安装&lt;code&gt;apt-get install or yum install&lt;/code&gt;，该种方式会将模块默认安装的系统环境，可能会影响系统环境
- 2. 使用Python原声的包管理工具&lt;code&gt;pip install&lt;/code&gt; ，该种方式会默认安装到&lt;code&gt;pip&lt;/code&gt;命令所在的Python解释环境下，因此取决于Python环境是否独立于系统环境的Python，通常情况下会使用&lt;code&gt;pyenv&lt;/code&gt;之类的工具进行环境隔离
- 3. 使用包管理工具&lt;code&gt;conda&lt;/code&gt;相关工具进行管理python，可以有效管理python多环境依赖，并且可以很方便构建数据科学相关环境.&lt;a href=&#34;https://www.jianshu.com/c/d2372cb5978e&#34;&gt;conda使用指南&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装pymysql库
$ pip install pymysql
or 
$ conda install pymysql

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;python链接mysql以及基本使用&#34;&gt;python链接MySQL以及基本使用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;使用pymysql库操作mysql&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat pytest_mysql.py
import pymysql
# 获取一个mysql链接对象
conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=&#39;utf8&#39;)
# 使用数据库链接的cursor()方法获取一个游标对象
cursor = conn.cursor()
# 使用游标对象的execute()方法进行执行sql语句
cursor.execute(&amp;quot;SELECT VERSION()&amp;quot;)
## execute方法的定义如下,其中args可以是tuple, list or dict,如果是list or tuple的话，%s会被当做查询的一个占位符;如果是dict的话%(name)s会被当做一个占位符
## execute(self, query, args=None) 


# 使用游标对象的fetch类方法获取数据
## fetchone返回一条数据,fetchall返回查询的所有数据。fetch类方法会返回一个list类型的tuple结构类型对象.[(),()...]
onedata = cursor.fetchone()
alldata = cursor.fetchall()

# 提交数据库操作[一般在更新数据库操作时需要注意执行]
conn.commit()

# 及时关闭数据库链接以及打开的游标[以防止在并发情况下系统打开连接数过多]
cursor.close()
conn.close()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;尝试用python脚本进行数据库操作&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat test_show_table.py
import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)
import pymysql

class mysqlObj:
    def __init__(self,host,dbname,user,passwd,port=3306):
        self.host = host
        self.dbname = dbname
        self.user = user
        self.passwd = passwd
        self.port = port
    def mysqlConIns(self):
        conn = pymysql.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.dbname, charset=&#39;utf8&#39;)
        return conn
    def querydata(self,sql,args=None):
        conn = self.mysqlConIns()
        cur = conn.cursor()
        cur.execute(sql,args)
        alldata = cur.fetchall()
        cur.close()
        for data in alldata:
            print(data)
        conn.close()


if __name__ == &#39;__main__&#39;:
    mysqlobj = mysqlObj(&#39;localhost&#39;,&#39;mysql&#39;,&#39;root&#39;,&#39;123456&#39;,32773)
    mysqlobj.querydata(&amp;quot;show tables;&amp;quot;)

# 对mysql库进行查看tables操作，返回的是一个tuple
$ python test_show_table.py
(u&#39;columns_priv&#39;,)
(u&#39;db&#39;,)
(u&#39;event&#39;,)
(u&#39;func&#39;,)
(u&#39;general_log&#39;,)
(u&#39;help_category&#39;,)
(u&#39;help_keyword&#39;,)
(u&#39;help_relation&#39;,)
(u&#39;help_topic&#39;,)
(u&#39;innodb_index_stats&#39;,)
(u&#39;innodb_table_stats&#39;,)
(u&#39;ndb_binlog_index&#39;,)
(u&#39;plugin&#39;,)
(u&#39;proc&#39;,)
(u&#39;procs_priv&#39;,)
(u&#39;proxies_priv&#39;,)
(u&#39;servers&#39;,)
(u&#39;slave_master_info&#39;,)
(u&#39;slave_relay_log_info&#39;,)
(u&#39;slave_worker_info&#39;,)
(u&#39;slow_log&#39;,)
(u&#39;tables_priv&#39;,)
(u&#39;time_zone&#39;,)
(u&#39;time_zone_leap_second&#39;,)
(u&#39;time_zone_name&#39;,)
(u&#39;time_zone_transition&#39;,)
(u&#39;time_zone_transition_type&#39;,)
(u&#39;user&#39;,)

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;mysql数据库常用的一些操作&#34;&gt;MySQL数据库常用的一些操作&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;注意:在之前我们创建的MySQL实例中仅是一个空的数据库，在实际使用之前，我们需要进行数据库的库表结构创建，以及相关的数据库授权，而这一部分操作通常会由专业的数据库管理员(DBA)进行操作和处理&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来对一个&lt;code&gt;website&lt;/code&gt;数据库和&lt;code&gt;use&lt;/code&gt;表进行操作:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mysql&amp;gt; create database website;
Query OK, 1 row affected (0.00 sec)
mysql&amp;gt; CREATE TABLE  IF NOT EXISTS useinfo (userid int(10) primary key not null auto_increment,username varchar(20) not null,usersite varchar(50),other varchar(50)) DEFAULT CHARSET=utf8;
Query OK, 0 rows affected (0.02 sec)
mysql&amp;gt; describe useinfo;
+----------+-------------+------+-----+---------+----------------+
| Field    | Type        | Null | Key | Default | Extra          |
+----------+-------------+------+-----+---------+----------------+
| userid   | int(10)     | NO   | PRI | NULL    | auto_increment |
| username | varchar(20) | NO   |     | NULL    |                |
| usersite | varchar(50) | YES  |     | NULL    |                |
| other    | varchar(50) | YES  |     | NULL    |                |
+----------+-------------+------+-----+---------+----------------+
4 rows in set (0.00 sec)

# 数据库授权[授权所有的主机可以以root用户,123456的密码去操作website库]
mysql&amp;gt; grant all on website.* to root@&#39;%&#39; identified by &amp;quot;123456&amp;quot;;
Query OK, 0 rows affected (0.00 sec)

&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;对指定数据库进行相关查询操作&#34;&gt;对指定数据库进行相关查询操作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 依然是上面那个test_show_table.py脚本,不过我们改变一下`__main__`
$ cat test_show_table.py
.....
if __name__ == &#39;__main__&#39;:
    mysqlobj = mysqlObj(&#39;localhost&#39;,&#39;website&#39;,&#39;root&#39;,&#39;123456&#39;,32773)
    args = [&amp;quot;show tables;&amp;quot;,&amp;quot;describe useinfo;&amp;quot;]
    for arg in args:
        mysqlobj.querydata(arg)

# 可以看到我们的website库下有useinfo一张表，并且该表包含userid,username,usersite,other4个字段
$ python test_show_table.py
(u&#39;useinfo&#39;,)
(u&#39;userid&#39;, u&#39;int(10)&#39;, u&#39;NO&#39;, u&#39;PRI&#39;, None, u&#39;auto_increment&#39;)
(u&#39;username&#39;, u&#39;varchar(20)&#39;, u&#39;NO&#39;, u&#39;&#39;, None, u&#39;&#39;)
(u&#39;usersite&#39;, u&#39;varchar(20)&#39;, u&#39;YES&#39;, u&#39;&#39;, None, u&#39;&#39;)
(u&#39;other&#39;, u&#39;varchar(20)&#39;, u&#39;YES&#39;, u&#39;&#39;, None, u&#39;&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;对mysql数据库进行插入操作&#34;&gt;对MySQL数据库进行插入操作&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;注意:插入操作分为单条记录插入和批量插入,一般数据库都支持批量插入方法,在pysql中为cursor.executemany(sql,args)&lt;/code&gt;
&lt;code&gt;为我们的mysqlObj类增加一个插入操作:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat test_show_table.py
....
....
    #注意插入数据时单条记录使用tuple()类型;批量插入数据时使用list()类型
    def changedata(self,sql,args=None):
        conn = self.mysqlConIns()
        cur = conn.cursor()
        try:
            #做一个粗暴的判断当args是list时就进行批量插入
            if isinstance(args,list):
                #executemany(sql,args)方法args支持tuple或者list类型
                cur.executemany(sql,args)
            else:
                #execute(sql,args)方法args支持string,tuple,list,dict
                cur.execute(sql,args)
            conn.commit()
        except Exception as e:
            conn.rollback()
            print(e)
        finally:
            cur.close()
            conn.close()
....
...
if __name__ == &#39;__main__&#39;:
    mysqlobj = mysqlObj(&#39;localhost&#39;,&#39;website&#39;,&#39;root&#39;,&#39;123456&#39;,32773)
    &#39;&#39;&#39;
    args = [&amp;quot;show tables;&amp;quot;,&amp;quot;describe useinfo;&amp;quot;]
    for arg in args:
        mysqlobj.querydata(arg)
    &#39;&#39;&#39;
    #插入一条数据
    sql = &amp;quot;insert into  useinfo (username) values(%s)&amp;quot;
    arg = &amp;quot;彪哥&amp;quot;
    mysqlobj.changedata(sql,arg)
    sql1 = &amp;quot;insert into  useinfo (username,usersite) values(%s,%s)&amp;quot;
    arg1 = (&amp;quot;xxbandy&amp;quot;,&amp;quot;http://xxbandy.github.io&amp;quot;)
    mysqlobj.changedata(sql1,arg1)
    #批量插入数据

    argslist = [(&amp;quot;彪哥&amp;quot;,&amp;quot;http://xxbandy.github.io&amp;quot;),(&amp;quot;bgbiao&amp;quot;,&amp;quot;https://www.jianshu.com/u/9c46ece5b7bd&amp;quot;)]
    mysqlobj.changedata(sql1,argslist)
    #查询数据
    mysqlobj.querydata(&amp;quot;select * from useinfo&amp;quot;)
	
		print(&amp;quot;updating the data&amp;quot;)
		#更新数据[需要注意的是指定了字段之后由于usersite是varchar类型，占位符必须是&amp;quot;%s&amp;quot;,如果是&#39;%s&#39;会有问题]
    data = &amp;quot;https://my.oschina.net/xxbAndy&amp;quot;
    mysqlobj.changedata(&#39;update useinfo set usersite=%s where userid = 1&#39;,data)
    mysqlobj.querydata(&amp;quot;select * from useinfo&amp;quot;)

# 插入数据并查看数据
$ python /tmp/abc.py
(1, u&#39;\u5f6a\u54e5&#39;, None, None)
(2, u&#39;xxbandy&#39;, u&#39;http://xxbandy.github.io&#39;, None)
(3, u&#39;\u5f6a\u54e5&#39;, u&#39;http://xxbandy.github.io&#39;, None)
(4, u&#39;bgbiao&#39;, u&#39;https://www.jianshu.com/u/9c46ece5b7bd&#39;, None)
updating the data
(1, u&#39;\u5f6a\u54e5&#39;, u&#39;https://my.oschina.net/xxbAndy&#39;, None)
(2, u&#39;xxbandy&#39;, u&#39;http://xxbandy.github.io&#39;, None)
(3, u&#39;\u5f6a\u54e5&#39;, u&#39;http://xxbandy.github.io&#39;, None)
(4, u&#39;bgbiao&#39;, u&#39;https://www.jianshu.com/u/9c46ece5b7bd&#39;, None)

# 数据库查询记录
mysql&amp;gt; select * from website.useinfo;
+--------+----------+----------------------------------------+-------+
| userid | username | usersite                               | other |
+--------+----------+----------------------------------------+-------+
|      1 | 彪哥   | https://my.oschina.net/xxbAndy         | NULL  |
|      2 | xxbandy  | http://xxbandy.github.io               | NULL  |
|      3 | 彪哥   | http://xxbandy.github.io               | NULL  |
|      4 | bgbiao   | https://www.jianshu.com/u/9c46ece5b7bd | NULL  |
+--------+----------+----------------------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;源码&#34;&gt;源码&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;import sys
reload(sys)
sys.setdefaultencoding(&#39;utf-8&#39;)
import pymysql

class mysqlObj:
    def __init__(self,host,dbname,user,passwd,port=3306):
        self.host = host
        self.dbname = dbname
        self.user = user
        self.passwd = passwd
        self.port = port
    def mysqlConIns(self):
        conn = pymysql.connect(host=self.host, port=self.port, user=self.user, passwd=self.passwd, db=self.dbname, charset=&#39;utf8&#39;)
        return conn
    def querydata(self,sql,args=None):
        conn = self.mysqlConIns()
        cur = conn.cursor()
        cur.execute(sql,args)
        alldata = cur.fetchall()
        cur.close()
        for data in alldata:
            print(data)
        conn.close()
    #注意插入数据时单条记录使用tuple()类型;批量插入数据时使用list()类型
    def changedata(self,sql,args=None):
        conn = self.mysqlConIns()
        cur = conn.cursor()
        try:
            #做一个粗暴的判断当args是list时就进行批量插入
            if isinstance(args,list):
                #executemany(sql,args)方法args支持tuple或者list类型
                cur.executemany(sql,args)
            else:
                #execute(sql,args)方法args支持string,tuple,list,dict
                cur.execute(sql,args)
            conn.commit()
        except Exception as e:
            conn.rollback()
            print(e)
        finally:
            cur.close()
            conn.close()



if __name__ == &#39;__main__&#39;:

    mysqlobj = mysqlObj(&#39;localhost&#39;,&#39;website&#39;,&#39;root&#39;,&#39;123456&#39;,32773)
    &#39;&#39;&#39;
    args = [&amp;quot;show tables;&amp;quot;,&amp;quot;describe useinfo;&amp;quot;]
    for arg in args:
        mysqlobj.querydata(arg)
    &#39;&#39;&#39;
    #插入一条数据
    sql = &amp;quot;insert into  useinfo (username) values(%s)&amp;quot;
    arg = &amp;quot;彪哥&amp;quot;
    mysqlobj.changedata(sql,arg)
    sql1 = &amp;quot;insert into  useinfo (username,usersite) values(%s,%s)&amp;quot;
    arg1 = (&amp;quot;xxbandy&amp;quot;,&amp;quot;http://xxbandy.github.io&amp;quot;)
    mysqlobj.changedata(sql1,arg1)
    #批量插入数据

    argslist = [(&amp;quot;彪哥&amp;quot;,&amp;quot;http://xxbandy.github.io&amp;quot;),(&amp;quot;bgbiao&amp;quot;,&amp;quot;https://www.jianshu.com/u/9c46ece5b7bd&amp;quot;)]
    mysqlobj.changedata(sql1,argslist)


    #查询数据
    mysqlobj.querydata(&amp;quot;select * from useinfo&amp;quot;)
    print(&amp;quot;updating the data&amp;quot;)
    #更新数据
    data = &amp;quot;https://my.oschina.net/xxbAndy&amp;quot;
    mysqlobj.changedata(&#39;&#39;&#39;update useinfo set usersite=%s where userid = 1&#39;&#39;&#39;,data)
    mysqlobj.querydata(&amp;quot;select * from useinfo&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>使用nvidia-smi来对Tesla-GPU进行故障排查</title>
      <link>https://bgbiao.top/post/troubleshooting-teslagpu-with-nvidia-smi/</link>
      <pubDate>Mon, 20 Aug 2018 14:34:43 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/troubleshooting-teslagpu-with-nvidia-smi/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景:生产环境中使用Tesla P40型号的进行线上模型训练，突然收到业务方反馈某一块卡好像坏了，无法使用。经了解后，发现业务方无法使用某一块卡进行运行程序，而其他GPU卡设备均正常。本篇文章记录如何排查并修复该问题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gpu卡异常现象&#34;&gt;GPU卡异常现象&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/issue_with_p40.png&#34; alt=&#34;gpu卡异常测试&#34; /&gt;&lt;br /&gt;
如上的的&lt;code&gt;bandwidthTest&lt;/code&gt;是nvidia-cuda官方提供的测试样例，具体可以查看&lt;a href=&#34;https://xxbandy.github.io/2017/10/26/GPU%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%8E%A9%E8%BD%ACDocker-%E4%B8%80/&#34;&gt;GPU环境的构建&lt;/a&gt;.当然用户也可以使用&lt;code&gt;tensorflow-gpu&lt;/code&gt;的如下代码来测试程序是否可以识别到GPU设备:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import tensorflow as tf 
import os
os.environ[&amp;quot;CUDA_VISIBLE_DEVICES&amp;quot;] = &amp;quot;3&amp;quot;
tf.test.gpu_device_name()
段错误(吐核)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;问题排查&#34;&gt;问题排查&lt;/h3&gt;

&lt;p&gt;由于问题出现原因仅为服务器的其中一块卡，因此我们可以使用&lt;code&gt;nvidia-smi&lt;/code&gt;命令对多卡之间的信息进行对比排查.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.使用&lt;code&gt;nvidia-smi -q -d PERFORMANCE&lt;/code&gt;查看GPU设备的性能&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## 经对比各个GPU卡设备性能够发现仅有id=3这块卡的`SW Power Cap`参数为active
# nvidia-smi -q -d PERFORMANCE -i 3
==============NVSMI LOG==============

Timestamp                           : Mon Aug 20 15:08:18 2018
Driver Version                      : 384.81

Attached GPUs                       : 8
GPU 00000000:11:00.0
    Performance State               : P8
    Clocks Throttle Reasons
        Idle                        : Not Active
        Applications Clocks Setting : Not Active
        SW Power Cap                : Active
        HW Slowdown                 : Not Active
        Sync Boost                  : Not Active
        SW Thermal Slowdown         : Not Active
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在性能参数中有&lt;code&gt;Active&lt;/code&gt;其实并不能说明很大的问题，但看到这里其实也可以发现该卡的确是比较慢一些了，详细可以看&lt;a href=&#34;https://xxbandy.github.io/2017/10/30/Manager-your-GPUs/&#34;&gt;manage-your-gpus&lt;/a&gt;中的&lt;code&gt;监控和管理GPU Boost&lt;/code&gt;部分.&lt;/p&gt;

&lt;p&gt;原文为:
&amp;gt; If any of the GPU clocks is running at a slower speed, one or more of the above Clocks Throttle Reasons will be marked as active. The most concerning condition would be if HW Slowdown or Unknown are active, as these would most likely indicate a power or cooling issue. The remaining conditions typically indicate that the card is idle or has been manually set into a slower mode by a system administrator.&lt;/p&gt;

&lt;p&gt;大概意思是只要GPU的时钟频率以一个比较低的速度运行的话，在&lt;code&gt;Clocks Throttle Reasons&lt;/code&gt;列就会有一个或多个被设置为&lt;code&gt;active&lt;/code&gt;状态。而如果&lt;code&gt;HW Slowdown&lt;/code&gt;和&lt;code&gt;Unknown&lt;/code&gt;只要不是&lt;code&gt;active&lt;/code&gt;就说明硬件其实还好啦，起码电源是没问题的。其他几个选项需要继续排查下是否为管理员手动设置的或GPU卡正在使用中。&lt;/p&gt;

&lt;p&gt;由刚开始的测试程序可以看出，我们&lt;code&gt;id=3&lt;/code&gt;的这块卡其实已经无法检测，那既没有人手动设置，也没有程序在使用该卡，说明该卡其实还是有些问题的。&lt;/p&gt;

&lt;p&gt;至于为什么会出现&lt;code&gt;SW Power Cap: Active&lt;/code&gt;,在&lt;a href=&#34;http://international.download.nvidia.com/tesla/pdf/gpu-boost-tesla-k40-app-note.pdf&#34;&gt;gpu-boost-tesla-k40&lt;/a&gt;中看到如下一句话:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;When the GPU is in a lower performance (idle) state, the GPU clock is fixed. However,
when the GPU is operating in a high performance state (P0), the highest GPU
performance is typically desired. NVIDIA GPU Boost maximizes the GPU performance
by automatically raising the GPU clock when there is thermal and power headroom
available. Likewise, if the power or thermal limit is reached, the GPU clock scales down
to the next available clock setting so that the board remains below the power and
thermal limit.
NVIDIA products that support NVIDIA GPU Boost have multiple high-performance
GPU clocks defined. That is, when the GPU is operating in its high performance mode
(P0 state; determined automatically by the driver software), it has an array of GPU
clocks available.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是在程序运行过程中可能会导致&lt;code&gt;SW Power Cap&lt;/code&gt;状态进行变化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.使用&lt;code&gt;nvidia-smi -q -d ecc&lt;/code&gt;查看GPU的ecc信息&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nvidia-smi -i 3 -q -d ecc

==============NVSMI LOG==============

Timestamp                           : Mon Aug 20 15:34:05 2018
Driver Version                      : 384.81

Attached GPUs                       : 8
GPU 00000000:11:00.0
    Ecc Mode
        Current                     : Enabled
        Pending                     : Enabled
    ECC Errors
        Volatile
            Single Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0
            Double Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0
        Aggregate
            Single Bit
                Device Memory       : 524
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 524
            Double Bit
                Device Memory       : 36
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 36
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现该卡&lt;code&gt;ECC Errors&lt;/code&gt;的&lt;code&gt;Aggregate&lt;/code&gt;有&lt;code&gt;Device Memory&lt;/code&gt;错误信息.&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;nvidia-smi&lt;/code&gt;有一个&lt;code&gt;nvidia-smi -r&lt;/code&gt;参数用来进行对GPU卡进行重置，相关说明如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -r    --gpu-reset           Trigger reset of the GPU.
                                Can be used to reset the GPU HW state in situations
                                that would otherwise require a machine reboot.
                                Typically useful if a double bit ECC error has
                                occurred.
                                Reset operations are not guarenteed to work in
                                all cases and should be used with caution.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说当&lt;code&gt;a double bit ECC error&lt;/code&gt;出现时，gpu卡的重置是很有效的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.尝试使用&lt;code&gt;nvidia-smi -r&lt;/code&gt;对异常的GPU卡进行恢复&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# nvidia-smi -r -i 3
Unable to reset GPU 00000000:11:00.0 because it&#39;s being used by some other process (e.g. CUDA application, graphics application like X server, monitoring application like other instance of nvidia-smi). Please first kill all processes using this GPU and all compute applications running in the system (even when they are running on other GPUs) and then try to reset the GPU again.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思是在对GPU卡进行重置之前，建议kill掉服务器上的所有使用GPU卡的程序，所以停止掉程序后继续执行。&lt;/p&gt;

&lt;h3 id=&#34;临时修复&#34;&gt;临时修复&lt;/h3&gt;

&lt;p&gt;在临时关闭服务器上其他使用GPU资源的程序后，再次对id=3的GPU卡进行重置操作.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ nvidia-smi -r -i 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;再次测试GPU卡检测程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; tf.test.gpu_device_name()
2018-08-20 14:52:27.958572: I tensorflow/core/common_runtime/gpu/gpu_device.cc:955] Found device 0 with properties:
name: Tesla P40
major: 6 minor: 1 memoryClockRate (GHz) 1.531
pciBusID 0000:11:00.0
Total memory: 22.38GiB
Free memory: 22.21GiB
2018-08-20 14:52:27.958641: I tensorflow/core/common_runtime/gpu/gpu_device.cc:976] DMA: 0
2018-08-20 14:52:27.958651: I tensorflow/core/common_runtime/gpu/gpu_device.cc:986] 0:   Y
2018-08-20 14:52:27.958668: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1045] Creating TensorFlow device (/gpu:0) -&amp;gt; (device: 0, name: Tesla P40, pci bus id: 0000:11:00.0)
u&#39;/gpu:0&#39;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，重置GPU后可以正常识别到GPU设备。&lt;/p&gt;

&lt;h3 id=&#34;善后处理&#34;&gt;善后处理&lt;/h3&gt;

&lt;p&gt;其实找了这么多，虽然临时将异常的GPU卡恢复使用了，但是对于底层具体的原因其实还有待排查，因为需要设计到cuda以及Tesla不同型号产品的配置以及参数优化调整。但为了便于问题的排查和修复以及对于业务使用的快速反应，我们需要尽快恢复资源使用。因此建议将&lt;code&gt;ECC Errors&lt;/code&gt;进行归零操作，以便后期问题的继续排查.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;将ECC Errors置零操作&lt;/strong&gt;
&lt;code&gt;CUDA_ERROR_ECC_UNCORRECTABLE&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# nvidia-smi -p 1 -i 3
Reset aggregate ECC errors to zero for GPU 00000000:11:00.0.
All done.

# nvidia-smi -i 3 -q -d ecc

==============NVSMI LOG==============

Timestamp                           : Mon Aug 20 15:50:22 2018
Driver Version                      : 384.81

Attached GPUs                       : 8
GPU 00000000:11:00.0
    Ecc Mode
        Current                     : Enabled
        Pending                     : Enabled
    ECC Errors
        Volatile
            Single Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0
            Double Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0
        Aggregate
            Single Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0
            Double Bit
                Device Memory       : 0
                Register File       : N/A
                L1 Cache            : N/A
                L2 Cache            : N/A
                Texture Memory      : N/A
                Texture Shared      : N/A
                CBU                 : N/A
                Total               : 0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;参考文章&#34;&gt;参考文章&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ibm.com/support/knowledgecenter/en/SSFHY8_5.5.0/com.ibm.cluster.essl.v5r5.essl100.doc/am5gr_nvidcap.htm&#34;&gt;GPU-Power-Cap&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;http://international.download.nvidia.com/tesla/pdf/gpu-boost-tesla-k40-app-note.pdf&#34;&gt;gpu-boost-tesla-k40&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang下的protobuf初体验</title>
      <link>https://bgbiao.top/post/golang%E4%B8%8B%E7%9A%84protobuf%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Tue, 03 Apr 2018 15:01:07 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/golang%E4%B8%8B%E7%9A%84protobuf%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      
        <description>&lt;h3 id=&#34;protpbuf简介&#34;&gt;protpbuf简介&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;protobuffer(以下简称PB)是google 的一种数据交换的格式，它独立于语言，独立于平台。&lt;br /&gt;
google 提供了多种语言的实现：Java、c#、c++、Go 和 Python，每一种实现都包含了相应语言的编译器以及库文件。由于它是一种二进制的格式，比使用 xml、json等 进行数据交换快许多。&lt;br /&gt;
可以把它用于分布式应用之间的数据通信或者异构环境下的&lt;code&gt;数据交换&lt;/code&gt;。&lt;br /&gt;
作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;准备工作&#34;&gt;准备工作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;准备golang的基础环境，GOPATH等等&lt;/li&gt;
&lt;li&gt;准备protobuf底层库环境(conda或者源码编译)&lt;/li&gt;
&lt;li&gt;准备protobuf相关包和插件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;准备基础环境&#34;&gt;准备基础环境&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;sh-4.2# go version
go version go1.8.3 linux/amd64
sh-4.2# go env
....
GOROOT=&amp;quot;/usr/lib/golang&amp;quot;
GOPATH=&amp;quot;/root/go&amp;quot;
....
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;准备protobuf底层库环境&#34;&gt;准备protobuf底层库环境&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# 因为工作原因会使用conda管理一些基础包，所以可以使用conda去安装基础模块

$ source /export/python2.7/setenv.sh
$ conda install libprotobuf -y
$ protoc --version
libprotoc 3.0.0

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;准备protobuf模块以及插件&#34;&gt;准备protobuf模块以及插件&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;# protoc-gen-go是用来将protobuf的的代码转换成go语言代码的一个插件
$ go get -u github.com/golang/protobuf/protoc-gen-go
# proto是protobuf在golang中的接口模块
$ go get -u github.com/golang/protobuf/proto
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用protobuf构造golang的模块代码&#34;&gt;使用protobuf构造golang的模块代码&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000007917576&#34;&gt;Protobuf语法&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 创建项目
$ mkdir -p &amp;quot;${GOPATH}/src/protobuf-study&amp;quot;

# 生成protobuf和相应的golang代码
$ mkdir -p &amp;quot;${GOPATH}/src/protobuf-study/protobuf&amp;quot; &amp;amp;&amp;amp; pushd &amp;quot;${GOPATH}/src/protobuf-study/goprotobuf&amp;quot;

# 定义protobuf消息格式
sh-4.2# cat test.proto
//这里的语法必须使用proto2,在proto3的版本中和optional参数冲突了
syntax = &amp;quot;proto2&amp;quot;;
//显式生命报名，在其他消息格式定义中可以使用package.message的方式来使用类型
//比如goprotobuf.HelloWorld
package goprotobuf;
//声明一个消息体描述一个请求或者响应的消息格式
message HelloWorld {
    required int32     id = 1;
    required string    name = 2;
    optional int32     opt = 3;
}

# 生成对应的golang模块代码(会将protobuf消息格式转换为对应golang结构体)
sh-4.2# protoc --go_out=./ test.proto
sh-4.2# ls
test.pb.go  test.proto

# 看一下生成的test.pd.go的核心代码
// 声明一个消息体描述一个请求或者响应的消息格式
type HelloWorld struct {
	Id               *int32  `protobuf:&amp;quot;varint,1,req,name=id&amp;quot; json:&amp;quot;id,omitempty&amp;quot;`
	Name             *string `protobuf:&amp;quot;bytes,2,req,name=name&amp;quot; json:&amp;quot;name,omitempty&amp;quot;`
	Opt              *int32  `protobuf:&amp;quot;varint,3,opt,name=opt&amp;quot; json:&amp;quot;opt,omitempty&amp;quot;`
	XXX_unrecognized []byte  `json:&amp;quot;-&amp;quot;`
}

func (m *HelloWorld) Reset()                    { *m = HelloWorld{} }
func (m *HelloWorld) String() string            { return proto.CompactTextString(m) }
func (*HelloWorld) ProtoMessage()               {}
func (*HelloWorld) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *HelloWorld) GetId() int32 {
	if m != nil &amp;amp;&amp;amp; m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *HelloWorld) GetName() string {
	if m != nil &amp;amp;&amp;amp; m.Name != nil {
		return *m.Name
	}
	return &amp;quot;&amp;quot;
}

func (m *HelloWorld) GetOpt() int32 {
	if m != nil &amp;amp;&amp;amp; m.Opt != nil {
		return *m.Opt
	}
	return 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-goprotobuf-包中定义的protobuf数据格式进行通信&#34;&gt;使用&lt;code&gt;goprotobuf&lt;/code&gt;包中定义的protobuf数据格式进行通信&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ pushd $GOPATH/src/protobuf-study

# 一个简单使用protobuf进行读写文件的例子
$ cat write.go
package main
import (
    protobuf &amp;quot;github.com/golang/protobuf/proto&amp;quot;
    &amp;quot;protobuf-study/goprotobuf&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;os&amp;quot;
)

func main() {
    //初始化protobuf数据格式
    msg := &amp;amp;goprotobuf.HelloWorld{
        Id:     protobuf.Int32(17),
        Name:   protobuf.String(&amp;quot;BGbiao&amp;quot;),
        Opt:    protobuf.Int32(18),

    }

    filename := &amp;quot;./protobuf-test.txt&amp;quot;
    fmt.Printf(&amp;quot;使用protobuf创建文件 %s\n&amp;quot;,filename)
    fObj,_ := os.Create(filename)
    defer fObj.Close()
    buffer,_ := protobuf.Marshal(msg)
    fObj.Write(buffer)

}

# 测试执行写文件程序
sh-4.2# go run write.go
使用protobuf创建文件 ./protobuf-test.txt
sh-4.2# cat -A protobuf-test.txt
^H^Q^R^FBGbiao^X^R
sh-4.2#

# 一个简单的通过之前定义的protobuf格式进行读取文件内容的例子
sh-4.2# cat read.go
package main
import (
    protobuf &amp;quot;github.com/golang/protobuf/proto&amp;quot;
    &amp;quot;protobuf-study/goprotobuf&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;io&amp;quot;
    &amp;quot;os&amp;quot;
)

func checkError(err error) {
    if err != nil {
        fmt.Println(err.Error())
        os.Exit(-1)
    }
}

func main() {
    filename := &amp;quot;protobuf-test.txt&amp;quot;
    file,fileErr := os.Open(filename)
    checkError(fileErr)

    defer file.Close()
    fs,fsErr := file.Stat()
    checkError(fsErr)
    buffer := make([]byte,fs.Size())
    //把file文件内容读取到buffer
    _,readErr := io.ReadFull(file,buffer)
    checkError(readErr)

    //初始化pb结构体对象并将buffer中的文件内容读取到pb结构体中
    msg := &amp;amp;goprotobuf.HelloWorld{}
    pbErr := protobuf.Unmarshal(buffer, msg)
    checkError(pbErr)
    fmt.Printf(&amp;quot;读取文件:%s \r\nname:%s\nid:%d\nopt:%d\n&amp;quot;,filename,msg.GetName(),msg.GetId(),msg.GetOpt())
}
sh-4.2# go run read.go
读取文件:protobuf-test.txt
name:BGbiao
id:17
opt:18
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;相关链接&#34;&gt;相关链接&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://segmentfault.com/a/1190000007917576&#34;&gt;Protobuf语法&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>NVIDIA-DIGITS测试使用</title>
      <link>https://bgbiao.top/post/nvidia-digits%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Tue, 02 Jan 2018 10:14:32 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/nvidia-digits%E6%B5%8B%E8%AF%95%E4%BD%BF%E7%94%A8/</guid>
      
        <description>&lt;h3 id=&#34;digits简介&#34;&gt;DIGITS简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/DIGITS&#34;&gt;DIGITS&lt;/a&gt;: Deep Learning GPU Training System1，是由英伟达（NVIDIA）公司开发的第一个交互式深度学习GPU训练系统。目的在于整合现有的Deep Learning开发工具，实现深度神经网络（Deep Neural Network，DNN）设计、训练和可视化等任务变得简单化。DIGITS是基于浏览器的接口，因而通过实时的网络行为的可视化，可以快速设计最优的DNN。DIGITS是开源软件，可在GitHub上找到，因而开发人员可以扩展和自定义DIGITS。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://devblogs.nvidia.com/parallelforall/digits-deep-learning-gpu-training-system/&#34;&gt;英文介绍&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;digits特性&#34;&gt;DIGITS特性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;提供了友好的用户界面，只需简单的点击即完成DNNs的训练。DIGITS是一个Web应用，用浏览器访问，上图是典型的工作流程图。&lt;/li&gt;
&lt;li&gt;DIGITS用户接口提供了DNN优化工具。主控制台列出了现有的数据库和机器上可用的先前训练好的网络模型以及正在进行的训练活动。&lt;/li&gt;
&lt;li&gt;DIGITS使可视化网络和快速对比精度变得简单。你选择一个模型，DIGITS显示训练状态和精度，并提供在网络训练时或训练完毕后加载和分类图像的选项。&lt;/li&gt;
&lt;li&gt;由于DIGITS运行在一个web服务器上，团队用户可以很方便地分享数据库和网络配置，以及测试和分享结果。&lt;/li&gt;
&lt;li&gt;DIGITS集成了流行的Caffe deep learning framework，并支持使用cudnn进行GPU加速。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;尝试使用DIGITS进行模型训练后，不得不说，这个平台功能做的真心不错。&lt;/p&gt;

&lt;h3 id=&#34;部署测试&#34;&gt;部署测试&lt;/h3&gt;

&lt;p&gt;官方给了基于&lt;code&gt;Ubuntu&lt;/code&gt;发行版的部署指南(估计是因为ubuntu上比较好处理python的各种依赖吧)，不过官方也构建的相关的Docker image来帮助用户进行部署。用户可以&lt;code&gt;docker pull nvidia/digits&lt;/code&gt;直接下载最新版本。&lt;/p&gt;

&lt;p&gt;容器镜像中使用5000端口来暴露web服务，因此需要将5000端口映射出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker run -itd --name digits -p 5000:5000 nvidia/digits:6.0
# docker logs digits 
  ___ ___ ___ ___ _____ ___
 |   \_ _/ __|_ _|_   _/ __|
 | |) | | (_ || |  | | \__ \
 |___/___\___|___| |_| |___/ 6.0.0

libdc1394 error: Failed to initialize libdc1394
/usr/local/lib/python2.7/dist-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment.
  warnings.warn(&#39;Matplotlib is building the font cache using fc-list. This may take a moment.&#39;)
2017-12-27 13:24:54 [INFO ] Loaded 0 jobs.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看日志如上环境即部署成功。&lt;/p&gt;

&lt;h3 id=&#34;环境测试&#34;&gt;环境测试&lt;/h3&gt;

&lt;p&gt;官方也给了一份测试数据以及文档来运行模型训练。
&lt;a href=&#34;https://github.com/NVIDIA/DIGITS/blob/master/docs/GettingStarted.md&#34;&gt;doc&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;下载模型数据&#34;&gt;下载模型数据&lt;/h4&gt;

&lt;p&gt;可以登录到&lt;code&gt;digits&lt;/code&gt;容器内部执行以下命令进行模型数据初始化。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python -m digits.download_data mnist ~/mnist
Downloading url=http://yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz ...
Downloading url=http://yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz ...
Downloading url=http://yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz ...
Downloading url=http://yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz ...
Uncompressing file=train-images-idx3-ubyte.gz ...
Uncompressing file=train-labels-idx1-ubyte.gz ...
Uncompressing file=t10k-images-idx3-ubyte.gz ...
Uncompressing file=t10k-labels-idx1-ubyte.gz ...
Reading labels from /home/username/mnist/train-labels.bin ...
Reading images from /home/username/mnist/train-images.bin ...
Reading labels from /home/username/mnist/test-labels.bin ...
Reading images from /home/username/mnist/test-images.bin ...
Dataset directory is created successfully at &#39;/home/username/mnist&#39;
Done after 16.722807169 seconds.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然如果容器内部无法访问外网，也可以将相关模型数据下载后进行解压。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
# ls dataset/
  t10k-images-idx3-ubyte.gz  t10k-labels-idx1-ubyte.gz  train-images-idx3-ubyte.gz  train-labels-idx1-ubyte.gz 
# docker cp dataset digits:/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，该模型文件好像不能直接解压。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# docker exec -it digits bash
root@aa3e7a2437af:/# cd dataset/
root@aa3e7a2437af:/dataset# ls
t10k-images-idx3-ubyte.gz  t10k-labels-idx1-ubyte.gz  train-images-idx3-ubyte.gz  train-labels-idx1-ubyte.gz
root@aa3e7a2437af:/dataset# python -m digits.download_data mnist .
Uncompressing file=train-images-idx3-ubyte.gz ...
Uncompressing file=train-labels-idx1-ubyte.gz ...
Uncompressing file=t10k-images-idx3-ubyte.gz ...
Uncompressing file=t10k-labels-idx1-ubyte.gz ...
Reading labels from ./train-labels.bin ...
Reading images from ./train-images.bin ...
Reading labels from ./test-labels.bin ...
Reading images from ./test-images.bin ...
Dataset directory is created successfully at &#39;.&#39;
Done after 18.2706720829 seconds.
root@aa3e7a2437af:/dataset#
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;使用webapp&#34;&gt;使用WebApp&lt;/h4&gt;

&lt;p&gt;使用浏览器访问容器宿主机的5000端口，即可看到首页数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/index.png&#34; alt=&#34;index&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;登录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击右上角的&lt;code&gt;login&lt;/code&gt;按钮进行登录。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;这里其实没有认证信息，用户随便输入就可以登录&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/login.png&#34; alt=&#34;login&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建DataSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;登录后点击&amp;rdquo;New Image Classification Dataset&amp;rdquo;
并进行相关设置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/dataset.png&#34; alt=&#34;dataset&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当job运行时，就可以在右侧看到运行的时间，以及结果。
&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/dataset1.png&#34; alt=&#34;dataset1&#34; /&gt;
&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/dataset2.png&#34; alt=&#34;dataset2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当运行完成之后，点击左上角的&lt;code&gt;DIGITS&lt;/code&gt;,可以看到创建的&lt;code&gt;dataset&lt;/code&gt;
&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/dataset-final.png&#34; alt=&#34;dataset-final&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练模型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;点击 &lt;code&gt;Models &amp;gt; New Model &amp;gt; Images &amp;gt; Classification&lt;/code&gt;.将引导你到&lt;code&gt;New Image Classification Model&lt;/code&gt; 页面。&lt;/p&gt;

&lt;p&gt;按照以下步骤进行操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;Select Dataset field&lt;/code&gt;选择 &amp;ldquo;testbiaoge&amp;rdquo; 数据集&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Standard Networks&lt;/code&gt;窗口选择&lt;code&gt;LeNet&lt;/code&gt;网络&lt;/li&gt;
&lt;li&gt;填写GPU卡数量以及模型名称&lt;/li&gt;
&lt;li&gt;点击&lt;code&gt;Create&lt;/code&gt;按钮进行创建&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/model.png&#34; alt=&#34;model-1&#34; /&gt;
&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/model2.png&#34; alt=&#34;model-2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在训练过程中用户可以看到悬链环境以及训练时间等相关信息。&lt;/p&gt;

&lt;p&gt;训练完成的状态：
&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/model-train.png&#34; alt=&#34;model-train&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了测试这个模型，可以拉到页面最底部&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;点击&lt;code&gt;Upload image&lt;/code&gt; 按钮选择一个文件，测试过程中选择&lt;code&gt;/dataset/test/2/00035.png&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;或者在网络上找一张图片，黏贴URL到&lt;code&gt;Image URL&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选中&lt;code&gt;Show visualizations and statistics&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;点击&lt;code&gt;Classify One&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在页面顶部，展示了五个分类以及相关的值。&lt;code&gt;DIGITS&lt;/code&gt;也提供了一些可视化以及网络中每个层的权重和激活统计信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/test-model-1.png&#34; alt=&#34;test-model&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://oyep1jupk.bkt.clouddn.com/test-model.png&#34; alt=&#34;test-model2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;查看最终任务运行的过程信息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2017-12-29 06:50:54 [20171229-065052-5cc9] [INFO ] Infer Model task started.
2017-12-29 06:50:54 [20171229-065052-5cc9] [INFO ] Task subprocess args: &amp;quot;/usr/bin/python /usr/local/lib/python2.7/dist-packages/digits/tools/inference.py /jobs/20171229-065052-5cc9/tmpctzfnI.txt /jobs/20171229-065052-5cc9 20171229-064432-4c8a --jobs_dir=/jobs --epoch=30.0 --layers=all --gpu=0&amp;quot;
2017-12-29 06:50:54 [20171229-065052-5cc9] [WARNING] Infer Model unrecognized output: libdc1394 error: Failed to initialize libdc1394



2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Infer Model task completed.
2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Job complete.
2017-12-29 06:52:43 [20171229-065052-5cc9] [INFO ] Job deleted.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，使用NVIDIA-DIGITS已经完成了一个模型训练。&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang中GBK和UTF-8格式互相转换</title>
      <link>https://bgbiao.top/post/golang%E4%B8%ADgbk%E5%92%8Cutf-8%E6%A0%BC%E5%BC%8F%E7%94%BB%E5%83%8F%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 24 Dec 2017 17:36:14 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/golang%E4%B8%ADgbk%E5%92%8Cutf-8%E6%A0%BC%E5%BC%8F%E7%94%BB%E5%83%8F%E8%BD%AC%E6%8D%A2/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 刚开始学习&lt;code&gt;Golang&lt;/code&gt;的时候，做一些简单数据处理发现总是会出现乱码，通常是因为字符集的问题，这里记录下如何在&lt;code&gt;GBK&lt;/code&gt;和&lt;code&gt;UTF-8&lt;/code&gt;之间进行格式转换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;直接上代码&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @File Name: gb2312-utf8.go
 * @Author:
 * @Email:
 * @Create Date: 2017-12-18 14:12:25
 * @Last Modified: 2017-12-18 14:12:00
 * @Description:
 */
package main
import (
    &amp;quot;bytes&amp;quot;
    &amp;quot;golang.org/x/text/encoding/simplifiedchinese&amp;quot;
    &amp;quot;golang.org/x/text/transform&amp;quot;
    &amp;quot;io/ioutil&amp;quot;
    &amp;quot;fmt&amp;quot;
)

func GbkToUtf8(s []byte) ([]byte, error) {
    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewDecoder())
    d, e := ioutil.ReadAll(reader)
    if e != nil {
        return nil, e
    }
    return d, nil
}

func Utf8ToGbk(s []byte) ([]byte, error) {
    reader := transform.NewReader(bytes.NewReader(s), simplifiedchinese.GBK.NewEncoder())
    d, e := ioutil.ReadAll(reader)
    if e != nil {
        return nil, e
    }
    return d, nil
}

func main() {

    s := &amp;quot;GBK 与 UTF-8 编码转换测试&amp;quot;
    gbk, err := Utf8ToGbk([]byte(s))
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(string(gbk))
    }

    utf8, err := GbkToUtf8(gbk)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(string(utf8))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;$ go run gbktoutf-8.go
GBK �� UTF-8 ����ת������
GBK 与 UTF-8 编码转换测试
&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
  </channel>
</rss>
