<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BGBiao的Ops人生</title>
    <link>https://bgbiao.github.io/</link>
    <description>Recent content on BGBiao的Ops人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 20 Oct 2019 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://bgbiao.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang中的单元测试、基准测试、覆盖测试</title>
      <link>https://bgbiao.github.io/post/go-unit-test/</link>
      <pubDate>Sun, 20 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.github.io/post/go-unit-test/</guid>
      
        <description>&lt;h2 id=&#34;单元测试-基准测试-覆盖测试&#34;&gt;单元测试、基准测试、覆盖测试&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;背景: 之前很长一段时间再写Golang程序时，不会有意识去写单元测试，直到后来写了独立项目后，慢慢才发现给一个功能编写对应的单元测试是多么高效和方便，接下来就再一起复习下Golang中的测试.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;UnitTest(单元测试)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;单元测试是程序开发者适用一段代码来验证另外一段代码写的是否符合预期的一种相对高效的自我测试方法。&lt;/p&gt;

&lt;p&gt;还记得最早开始搞运维时，写的程序基本上是通过&lt;code&gt;main&lt;/code&gt;程序去调用具体的功能函数，然后通过具体的输出来主观验证结果是否符合预期，这种方式对于搞正统的软件开发者而言会感觉很傻，但这对于运维领域来说却很实用，很有效，因为通常运维工作中需要的一些开发都不会是逻辑较为复杂的程序，所以没有必要专门去写测试程序去测试另外一个程序是否符合预期。&lt;/p&gt;

&lt;p&gt;但是随着工作内容和运维需求的变化，不得不使用一些正规软件工程领域的相关方法来进行测试，因为对于程序开发来说，经过长期的积累和方法总结，单元测试是一种比较好的开发程序验证方式，而且能够提高程序开发的质量。而在&lt;code&gt;Golang&lt;/code&gt;语言中内置了一系列的测试框架，加下来就主要讲讲&lt;code&gt;UnitTest&lt;/code&gt;单元测试的相关知识点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UnitTest的编写&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在Golang中，对于单元测试程序来说通常会有一些重要约束，主要如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;单元测试文件名必须为&lt;code&gt;xxx_test.go&lt;/code&gt;(其中xxx为业务逻辑程序)&lt;/li&gt;
&lt;li&gt;单元测试的函数名必须为&lt;code&gt;Testxxx&lt;/code&gt;(xxx可用来识别业务逻辑函数)&lt;/li&gt;
&lt;li&gt;单元测试函数参数必须为&lt;code&gt;t *testing.T&lt;/code&gt;(测试框架强要求)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试程序和被测试程序文件在一个包&lt;code&gt;package&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 示例文件
# 假设我们为某段业务逻辑专门写了一个package(用来初始化一个矩形，并计算体积)，此时看到到整体结构如下
$ tree -L 2 ./unittest
./unittest
├── area.go
└── area_test.go

# 业务逻辑代码(业务逻辑需要和单元测试在一个package下)
$ cat ./unittest/area.go
package unittest

type box struct {
length  int
width   int
height  int
name    string
}

// 初始化一个结构体指针对象，后面使用结构体指针方法来设置和获取对象属性
func Newbox() (*box) {
return &amp;amp;box{}
}

// 给结构体对象设置具体的属性(名称，规格大小)
// 注意: 在如下几个方法中，方法接受者为指针类型，而方法参数为值类型，因此在赋值时可能有人产生疑惑，这里其实是Golang底层做了优化(v.name = name 等同于(*v).name = name)
func (v *box) SetName(name string) {
v.name = name
}
func (v *box) SetSize(l,w,h int) {
v.length = l
v.width = w
v.height = h
}

// 获取对象的一些属性(名称和体积)
func (v *box) GetName() (string) {
return v.name
}
func (v *box) GetVolume() (int) {
return (v.length)*(v.width)*(v.height)
}

# 对应业务逻辑的单元测试逻辑
$ cat unittest/area_test.go
package unittest
// 必须导入testing模块，并且方法的接受者为(t *testing.T)
import (
&amp;quot;fmt&amp;quot;
&amp;quot;testing&amp;quot;
)
// 测试1: 测试名称是否符合预期
func TestSetSomething(t *testing.T) {
box := Newbox()
box.SetName(&amp;quot;bgbiao&amp;quot;)
if box.GetName() == &amp;quot;bgbiao&amp;quot; {
    fmt.Println(&amp;quot;the rectangular name&#39;s result is ok&amp;quot;)
}
}
// 测试2: 测试计算出来的体积是否符合预期
func TestGetSomething(t *testing.T) {
box := Newbox()
box.SetSize(3,4,5)
if box.GetVolume() == 60 {
    fmt.Println(&amp;quot;the rectangular volume&#39;s result is ok&amp;quot;)
}
}

# 运行单元测试程序
# 可以看到我们编写的两个单元测试都经过预期测试
$ cd unittest
$ go test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
ok  	_/User/BGBiao/unittest	0.005s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;单元测试的运行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过上面那个测试示例，我们都知道了可以使用&lt;code&gt;go test&lt;/code&gt;来对Golang代码进行测试，接下来具体讲解一些&lt;code&gt;go test&lt;/code&gt;的其他用法(其实上面说的那些规则也可以在&lt;code&gt;go help test&lt;/code&gt;帮助文档中找到)&lt;/p&gt;

&lt;p&gt;这里主要总结下几个常用的参数:
- -args: 指定一些测试时的参数(可以指定超时时间,cpu绑定,压测等等(go test包含单元测试，压力测试等))
- - -test.v: 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例
- - -test.run pattern: 只跑哪些单元测试用例
- - -test.bench patten: 只跑那些性能测试用例
- - -test.benchmem : 是否在性能测试的时候输出内存情况
- - -test.benchtime t : 性能测试运行的时间，默认是1s
- - -test.cpuprofile cpu.out : 是否输出cpu性能分析文件
- - -test.memprofile mem.out : 是否输出内存性能分析文件
- - -test.blockprofile block.out : 是否输出内部goroutine阻塞的性能分析文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c: 编译测试文件到pkg.test,但是不会运行测试程序&lt;/li&gt;
&lt;li&gt;-exec xprog: 使用xprog参数来运行编译的测试文件(参数类似go run后的参数)&lt;/li&gt;
&lt;li&gt;-i: 安装测试程序中的依赖包，但是不运行测试程序&lt;/li&gt;
&lt;li&gt;-json: 以json格式输出测试结果&lt;/li&gt;
&lt;li&gt;-o file: 指定测试程序编译后生成的文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;单元测试中常用的命令参数:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 对当前目录下的全部单元测试程序进行运行测试(也就是所有的xxx_test.go文件中的所有function都会运行)
$ go test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
ok  	_/Users/BGBiao/unittest	0.005s

# 查看详细的单元测试结果
# (go test -v 等同于go test -args -test.v)
$ go test -v
=== RUN   TestSetSomething
the rectangular name&#39;s result is ok
--- PASS: TestSetSomething (0.00s)
=== RUN   TestGetSomething
the rectangular volume&#39;s result is ok
--- PASS: TestGetSomething (0.00s)
PASS
ok  	_/Users/BGBiao/unittest	0.005s

# 指定单元测试function来进行测试(-run参数可以指定正则匹配模式-run=&amp;quot;test1|test2&amp;quot;)
# go test -v -run functionname 
$ go test -v -test.run TestGetSomething
=== RUN   TestGetSomething
the rectangular volume&#39;s result is ok
--- PASS: TestGetSomething (0.00s)
PASS
ok  	_/Users/BGBiao/unittest	0.005s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;单元测试注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在单元测试时，一个比较重要的事情就是如何构造测试数据，因为通常我们能够想到的测试数据都是在预期之中的，有些核心逻辑的测试数据往往不能考虑到，因此构造测试数据时可考虑如下几个方面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 正常输入: 正常的可预测的测试用例&lt;/li&gt;
&lt;li&gt;2. 边界输入: 极端情况下的输入来测试容错性&lt;/li&gt;
&lt;li&gt;3. 非法输入: 输入异常数据类型，整个逻辑是否能够正常处理或者捕获&lt;/li&gt;
&lt;li&gt;4. 白盒覆盖: 需要设计的测试用例能够覆盖所有代码(语句覆盖、条件覆盖、分支覆盖、分支/条件覆盖、条件组合覆盖)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在写项目时，对于基础的工具层&lt;code&gt;util&lt;/code&gt;的逻辑代码，一定要进行全方位，多场景的进行测试，否则当项目大起来后到处引用可能会造成较大麻烦;其次，我们的代码逻辑通常是更新迭代的，单元测试代码也应该进行定期更新.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;华丽的分割线&#34;&gt;华丽的分割线&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Golang的测试断言工具&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在&lt;code&gt;testing&lt;/code&gt;包中包含了一些常用的断言工具&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func TestPrint(t *testing.T) {
    // 输出测试日志
    t.Logf()
    // 标记错误，但仍然执行后面的语句
    t.Fail()
    // 获取是否当前用例是执行错误的
    t.Failed()
    // 错误输出，等于 t.Logf 再执行 t.Fail()
    t.Errorf(&amp;quot;%s&amp;quot;, &amp;quot;run ErrorF&amp;quot;)
    // 标记函数错误，并中断后面的执行
    t.FailNow()
    // 致命错误输出，等同于调用了 t.Logf 然后调用 t.FailNow()
    t.Fatalf(&amp;quot;%s&amp;quot;, &amp;quot;run Fatelf&amp;quot;)
    // 测试用例的名字
    t.Name()
    //运行子测试用例
    t.Run()
    // 跳过后面的内容，后面将不再运行
    t.SkipNow()
    // 告知当前的测试是否已被忽略
    t.Skipped()
    // 并行测试
    t.Parallel()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;测试覆盖率统计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;Golang内置工具包中也提供了测试覆盖率相关的工具，&lt;code&gt;go test&lt;/code&gt;常用参数如下:
- &lt;code&gt;-cover&lt;/code&gt;: 是否开启覆盖测试率统计的开关.(当有&lt;code&gt;-covermode&lt;/code&gt;、&lt;code&gt;-coverpkg&lt;/code&gt;、&lt;code&gt;-coverprofile&lt;/code&gt;参数时会自动打开)
- &lt;code&gt;-covermode&lt;/code&gt;: 设置覆盖测试率模式(可选值:set,count,atomic). set(默认)仅统计语法块是否覆盖;count 会统计语法块覆盖了多少次;atomic 用于多线程测试中统计语法块覆盖了多少次
- &lt;code&gt;-coverpkg&lt;/code&gt;: 指定覆盖率统计package的范围(默认只统计有执行了测试的packages)
- &lt;code&gt;-timeout&lt;/code&gt;: 指定单个测试用例的超时时间，默认10分钟
- &lt;code&gt;-coverprofile&lt;/code&gt;: 指定覆盖率profile文件的输出地址&lt;/p&gt;

&lt;p&gt;&lt;code&gt;第三方的测试覆盖统计&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://goconvey.co/&#34;&gt;goconvey&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/smartystreets/goconvey&#34;&gt;goconvey&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;https://codecov.io/&#34;&gt;codecov&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 使用golang内置的工具来执行覆盖测试，执行之后生成.test的执行文件，执行后会执行所有单元测试代码，然后输出覆盖率的报告
$ go test -c -covermode=count -coverpkg ./
➜  unittest git:(master) ✗ ls
area.go       area_test.go  unittest.test
➜  unittest git:(master) ✗ ./unittest.test
the rectangular name&#39;s result is ok
the rectangular volume&#39;s result is ok
PASS
coverage: 100.0% of statements in ./
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;统计单元测试的覆盖率，也就是白盒测试的覆盖率.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;覆盖率测试报告&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 将测试覆盖率结果写入一个数据文件
$ go test -coverpkg=./ -coverprofile=coverage.data -timeout=5s

# 将覆盖率报告数据文件转化成对应的人类可识别模式(go tool cover可查看覆盖率相关的工具)
$  go tool cover -func=coverage.data -o coverage.txt
➜  unittest git:(master) ✗ cat coverage.txt
/Users/BGBiao/unittest/area.go:19:	Newbox		100.0%
/Users/BGBiao/unittest/area.go:23:	SetName		100.0%
/Users/BGBiao/unittest/area.go:27:	SetSize		100.0%
/Users/BGBiao/unittest/area.go:33:	GetName		100.0%
/Users/BGBiao/unittest/area.go:37:	GetVolume	100.0%
total:										(statements)	100.0%

# 转化成html格式(会在本地生成html文件)
$ go tool cover -html=coverage.data -o coverage.html

# 直接以html形式展示覆盖测试率报告
$ go tool cover -html=coverage.data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8tw12ghvej317l0u0jvu.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基准测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基准测试是测量一个程序在固定工作负载下的性能。在Golang中，基准测试函数和普通的单元测试函数写法类似，同样需要遵循以下规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.函数以&lt;code&gt;Benchmark&lt;/code&gt;开头&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;2.函数参数为&lt;code&gt;b *testing.B&lt;/code&gt; (区别于单元测试的&lt;code&gt;t *testing.T&lt;/code&gt;)&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: &lt;code&gt;*testing.B&lt;/code&gt;参数提供了一些额外的性能测量相关的方法，同时还提供了一个随机整数&lt;code&gt;N&lt;/code&gt;，用于限定执行的循环次数。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 编写benchmark函数
func Benchmark_GetSomething(b *testing.B) {
    box := Newbox()
    volume := 0
    for i := 0; i &amp;lt; b.N; i++ {
        box.SetSize(10,1111,2222)
        volume = box.GetVolume()
    }
    b.Log(volume)
}

# 运行测试(运行所有的基准测试，-bench可以指定函数名，-benchmem可以指定分配内存的次数和字节数)
# 和单元测试不同的是，我们需要使用-bench来手工指定需运行的基准测试函数(.表示全部的基准测试函数)
# 如下输出结果表示:GOMAXPROCS为4核心,每次调用GetSomething函数平均花费0.35ns(调用了2000000000次)
$ go test -v -run=&amp;quot;none&amp;quot; -bench=Benchmark_GetSomething -benchmem
goos: darwin
goarch: amd64
Benchmark_GetSomething-4   	2000000000	         0.35 ns/op	       0 B/op	       0 allocs/op
--- BENCH: Benchmark_GetSomething-4
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
PASS
ok  	_/Users/BGBiao/unittest	0.749s

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;性能分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 当我们的程序在运行过程中可能会消耗非常多的资源(通常是程序性价比较低时，比如处理一个很小的数据，却占用了几个G的内存，并且CPU长期处于高负荷状态)，此时我们就需要通过一些技术手段来分析程序性能损耗点，以此来提高程序的性价比。&lt;/p&gt;

&lt;p&gt;Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。基本上常用的为&lt;code&gt;MEM分析&lt;/code&gt;、&lt;code&gt;CPU分析&lt;/code&gt;以及&lt;code&gt;block分析&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;MEM分析: 主要是堆分析，可以标识出最耗内存的逻辑，内置库会会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;CPU分析: 可以标识最耗CPU时间的函数,每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行.&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Block分析: 记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁; 当goroutine被这些操作阻塞时，剖析库都会记录相应的事件.&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 剖析对于长期运行的程序尤其有用，因此可以通过调用Go的&lt;code&gt;runtime API&lt;/code&gt;来启用运行时剖析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 通过不同的参数来获取指定性能分析数据
$ go test -cpuprofile=cpu.out
$ go test -blockprofile=block.out
$ go test -memprofile=mem.out
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一旦我们通过上述内置工具获取到相关的分析数据，我们就可以使用&lt;code&gt;pprof&lt;/code&gt;来分析数据，使用&lt;code&gt;go help pprof&lt;/code&gt;可以查看更多帮助信息，最常用的即: 生成这个概要文件的可执行程序和对应的剖析数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 获取CPU基准测试数据
$ go test  -run=&amp;quot;none&amp;quot; -bench=Benchmark_GetSomething -cpuprofile=cpu.log
goos: darwin
goarch: amd64
Benchmark_GetSomething-4   	2000000000	         0.36 ns/op
--- BENCH: Benchmark_GetSomething-4
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
    area_test.go:40: 24686420
PASS
ok  	_/Users/BGBiao/unittest	0.944s
➜  unittest git:(master) ✗ ls
area.go       area_test.go  cpu.log       unittest.test

# 之后会生成测试程序和cpu分析数据(unittest.test和cpu.log) 
# 使用pprof工具分析相关数据(-text用于指定输出格式;-nodecount=10限制只输出前10行结果)
$ go tool pprof -text -nodecount=10 ./unittest.test cpu.log
File: unittest.test
Type: cpu
Time: Nov 11, 2019 at 12:12pm (CST)
Duration: 938ms, Total samples = 680ms (72.49%)
Showing nodes accounting for 680ms, 100% of 680ms total
      flat  flat%   sum%        cum   cum%
     510ms 75.00% 75.00%      680ms   100%  _/Users/BGBiao/unittest.Benchmark_GetSomething
     170ms 25.00%   100%      170ms 25.00%  _/Users/BGBiao/unittest.(*box).GetVolume
         0     0%   100%      680ms   100%  testing.(*B).launch
         0     0%   100%      680ms   100%  testing.(*B).runN

# web可视化分析(会弹出web页面,可查看程序每个逻辑的cpu使用)
$ go tool pprof -http=:8080 -nodecount=10 ./unittest.test cpu.log

# 对应的，我们也可以使用-memprofile参数来获取内存分析数据，来查看处理逻辑对内存的消耗状况
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8tz9u4xz2j30u00xxdjd.jpg&#34; alt=&#34;cpu性能分析&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006y8mN6ly1g8u1yeltk4j305p0ptgmk.jpg&#34; alt=&#34;mem分配&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例程序&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://johng.cn/go-test-profile-and-cover/&#34;&gt;Go性能测试、单元测试以及代码覆盖率&lt;/a&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang中的异常处理</title>
      <link>https://bgbiao.github.io/post/golang-expect/</link>
      <pubDate>Wed, 06 Mar 2019 16:01:23 +0800</pubDate>
      
      <guid>https://bgbiao.github.io/post/golang-expect/</guid>
      
        <description>&lt;h2 id=&#34;golang的异常处理和单元测试&#34;&gt;Golang的异常处理和单元测试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;1.Golang语言中没有其他语言中的&lt;code&gt;try...catch...&lt;/code&gt;语句来捕获异常和异常恢复&lt;/li&gt;
&lt;li&gt;2.在Golang中我们通常会使用&lt;code&gt;panic&lt;/code&gt;关键字来抛出异常，在&lt;code&gt;defer&lt;/code&gt;中使用&lt;code&gt;recover&lt;/code&gt;来捕获异常进行具体逻辑处理&lt;/li&gt;
&lt;li&gt;3.Golang中我们通常会在函数或方法中返回&lt;code&gt;error&lt;/code&gt;结构对象来判断是否有异常出现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意事项&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.利用&lt;code&gt;recover&lt;/code&gt;和&lt;code&gt;panic&lt;/code&gt;指令，&lt;code&gt;defer&lt;/code&gt;必须放在panic之前定义(&lt;code&gt;panic会终止其后要执行的代码&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;2.&lt;code&gt;recover&lt;/code&gt;只有在&lt;code&gt;defer&lt;/code&gt;调用的函数中才有效，否则&lt;code&gt;recover&lt;/code&gt;无法捕获到&lt;code&gt;panic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;3.&lt;code&gt;recover&lt;/code&gt;处理异常后，业务逻辑会跑到&lt;code&gt;defer&lt;/code&gt;之后的处理片段中&lt;/li&gt;
&lt;li&gt;4.多个&lt;code&gt;defer&lt;/code&gt;会形成&lt;code&gt;defer栈&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5.panic会等到整个&lt;code&gt;goroutine&lt;/code&gt;退出才会报告错误&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;常规使用&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;panic&lt;/code&gt;以及&lt;code&gt;recover&lt;/code&gt;参数类型为空接口(可存储任何类型对象)&lt;code&gt;interface{}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
func panic(v interface{})
func recover() interface{}
执行顺序:panic()-&amp;gt;带recover的defer
输出结果:
oh my god!panic.
解释:
defer中的recover成功捕获到了panic的异常
*/

package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
defer func() {
    if err := recover(); err != nil {
        fmt.Println(err)    
    }
}()
panic(&amp;quot;oh my god!panic.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;延迟调用中引发的错误，可被后续延迟调用捕获(&lt;code&gt;仅最后一个错误被捕获&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
执行顺序:panic()-&amp;gt;带panic的defer匿名函数-&amp;gt;带recover()的defer匿名函数
输出结果:
catch the panic
解释:
defer中的recover仅能捕获最后一个错误
package main
import (
&amp;quot;fmt&amp;quot;
)
func main() {
defer func() {
    if err := recover();err != nil {
        fmt.Println(&amp;quot;catch the panic&amp;quot;)
    }
}()
defer func() {
    panic(&amp;quot;oh my god! panic.&amp;quot;)
}()

panic(&amp;quot;something panic!&amp;quot;)

}

&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;捕获函数&lt;code&gt;recover()&lt;/code&gt;只有在&lt;code&gt;defer&lt;/code&gt;调用内直接调用才会终止，否则返回&lt;code&gt;nil&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
代码执行顺序:panic-&amp;gt;在匿名函数中嵌套recover的defer函数-&amp;gt;带fmt的defer-&amp;gt;带recover的defer-&amp;gt;在匿名函数中调用recover的defer
输出结果:
defer inner
&amp;lt;nil&amp;gt;
defer recover panic error
解释: 多个defer之间形成defer栈，最底部的defer优先执行;第三个defer打印了recover()的零值`nil`，仅有第一个defer成功捕获了最底部的panic(&amp;quot;panic error&amp;quot;)
*/
package main
import &amp;quot;fmt&amp;quot;
func main() {
defer func() {
    fmt.Println(&amp;quot;defer recover&amp;quot;,recover())
}()
defer recover()
defer fmt.Println(recover())
defer func() {
    func(){
        fmt.Println(&amp;quot;defer inner&amp;quot;)
        recover()
    }()
}()
panic(&amp;quot;panic error&amp;quot;)
}      
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将代码块放置在匿名函数中可实现在函数逻辑中进行异常恢复，而不影响主函数&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
代码执行顺序:匿名函数中的panic语句-&amp;gt;匿名函数中i自加运算-&amp;gt;匿名函数中的fmt-&amp;gt;匿名函数中的defer-&amp;gt;主函数中的fmt
输出结果:
i is: 2
解释:panic会终止其之后的执行，因此优先执行匿名函数中的panic之后便被defer中的recover捕获，将i赋值为2，其后匿名函数退出开始继续执行主函数中的fmt.Println语句
*/
package main
import &amp;quot;fmt&amp;quot;
func main() {
test()
}
func test() {
var i int
func() {
    defer func(){
        if err := recover();err != nil {
            i = 2
        }
    }()
    panic(&amp;quot;something panic!&amp;quot;)
    i += 8
    fmt.Println(&amp;quot;no panic, i is:&amp;quot;,i)
}()
fmt.Println(&amp;quot;i is:&amp;quot;,i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;goroutine中的recover&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;如果一个没有&lt;code&gt;recover&lt;/code&gt;的&lt;code&gt;goroutine&lt;/code&gt;发生了panic，那么整个进程都会挂掉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*
sync.WaitGroup用来等待一组goroutine的结束,Add方法用来设置等待的goroutine数量,Done方法表示一个goroutine运行结束,使用Wait方法将全部的goroutine阻塞住,直到全部goroutine执行完毕

代码执行顺序:goroutine中的逻辑-&amp;gt;wg.Wait()-&amp;gt;fmt.Println
输出结果:
panic recover assignment to entry in nil map
donw
解释:
在goroutine中我们声明了一个info的map[string]string类型，我们都知道在map,slice,channel都是引用类型，需要使用make函数进行初始化操作之后进行赋值。而这里直接使用info[&amp;quot;name&amp;quot;] = &amp;quot;BGBiao&amp;quot;进行赋值导致panic，fmt.Println函数就会被终止执行，从而执行带recover的defer，之后执行带wg.Done()的defer并退出goroutine执行主程序逻辑
*/
package main
import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;sync&amp;quot;
)
func main() {
    var wg sync.WaitGroup
    wg.Add(4)
    go func() {
        defer wg.Done()
        defer func() {
            if err := recover();err != nil {
                fmt.Println(&amp;quot;panic recover&amp;quot;,err)
            }
        }()
        var info map[string]string
        info[&amp;quot;name&amp;quot;] = &amp;quot;BGBiao&amp;quot;
        fmt.Println(info)
    }()
    wg.Wait()
    fmt.Println(&amp;quot;done&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;</description>
      
    </item>
    
    <item>
      <title>关于BGBiao</title>
      <link>https://bgbiao.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://bgbiao.github.io/about/</guid>
      
        <description>&lt;p&gt;非专业出身的专业SRE，专治各种疑难杂症。&lt;/p&gt;

&lt;p&gt;毕业的前四年在&lt;a href=&#34;https://jddglobal.com/&#34;&gt;京东数字科技&lt;/a&gt;担任一线运维工作，目前在一家创业公司担任SRE，主要负责内部DevOps体系建设以及一些基础运维工作。&lt;/p&gt;

&lt;p&gt;对应用运维，SRE，DevOps，Kubernetes，Cloud Native，大数据以及Golang相关技术比较感兴趣。&lt;/p&gt;

&lt;p&gt;喜欢交朋友，也喜欢不断学习和分享技术文章，可以在以下途径联系到我，感兴趣的话，不妨一起交流交流.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://my.oschina.net/xxbAndy&#34;&gt;开源中国&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/u/9c46ece5b7bd&#34;&gt;简书&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/BGBiao/&#34;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://bgbiao.github.io/images/Golang运维者.jpg&#34; alt=&#34;欢迎关注我的公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
