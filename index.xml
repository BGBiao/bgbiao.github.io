<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BGBiao的SRE人生</title>
    <link>https://bgbiao.top/</link>
    <description>Recent content on BGBiao的SRE人生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 04 May 2020 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://bgbiao.top/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kafka常用运维操作</title>
      <link>https://bgbiao.top/post/kafka%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/kafka%E5%B8%B8%E7%94%A8%E8%BF%90%E7%BB%B4%E6%93%8D%E4%BD%9C/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言: 在kafka的集群运维操作过程中，我们需要通过一些工具来实现集群的高可用以及负载的平均操作，而对于kafka集群的SRE来说，需要掌握好如下几点，才能更好的维护和保证kafka集群服务的稳定性，可靠性和整体性能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;要想kafka跑的好，如下几点要知晓。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Graceful shutdown&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建议开启如下参数:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;controlled.shutdown.enable=true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 只有在broker上承载的分区都具有副本时(副本大于1，且副本存活)，controller节点才会成功关闭&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Balancing leadership&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每当Broker停止或崩溃时，该broker的分区的领导权就转移到其他副本。&lt;/p&gt;

&lt;p&gt;这意味着，默认情况下，当broker重新启动时，它将只是所有分区的关注者，这意味着它不会用于客户端读写，这对于整个集群来说吞吐会受到1/N的降低(N表示集群节点数)&lt;/p&gt;

&lt;p&gt;为了避免这种不平衡，kafka提供了一种优先副本的概念&lt;code&gt;preferred replicas&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;如果一个分区的副本列表是1、5、9，那么节点1比节点5或节点9更适合作为leader，因为它位于副本列表的前面。&lt;/p&gt;

&lt;p&gt;可以使用如下命令来恢复已恢复副本的领导权:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 老版本工具
bin/kafka-preferred-replica-election.sh --zookeeper zk_host:port/chroot

# 新版本工具&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当然每次在服务器启动后执行该操作，可能很无聊，因此可以设置如下参数来自动执行:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;auto.leader.rebalance.enable=true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Balancing Replicas Across Racks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;机架层面的副本均衡。&lt;/p&gt;

&lt;p&gt;机架感知特性将相同分区的副本分散到不同的机架上，这扩展了Kafka为broker失败提供的覆盖机架失败的保证，如果机架上的所有broker同时失败，就限制了数据丢失的风险。&lt;/p&gt;

&lt;p&gt;该特性还可以应用于其他broker分组，如EC2中的可用性区域。&lt;/p&gt;

&lt;p&gt;您可以通过向broker配置添加属性来指定broker属于特定的机架：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;broker.rack=my-rack-id&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当创建、修改或重新分发一个主题时，将遵循机架约束，确保副本尽可能多地跨越多个机架(一个分区将跨越最小(#机架，复制因子)不同的机架)。&lt;/p&gt;

&lt;p&gt;用于将副本副本分配给broker的算法，会确保每个broker的leader数量是恒定的，而不管broker是如何分布在机架上的。这确保了平衡的吞吐量。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 明智的做法是为每个机架配置相同数量的broker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mirroring data between clusters&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将在Kafka集群之间复制数据的过程称为“镜像”，以避免与单个集群中节点之间的复制混淆。&lt;/p&gt;

&lt;p&gt;Kafka附带一个用于在Kafka集群之间镜像数据的工具，即&lt;code&gt;MirrorMaker&lt;/code&gt;，该工具可以从源集群进行消费，并生产到目标集群。&lt;/p&gt;

&lt;p&gt;常用的场景就是在另外一个数据中心提供副本。&lt;/p&gt;

&lt;p&gt;您可以运行许多这样的镜像进程来提高吞吐量和容错能力。&lt;/p&gt;

&lt;p&gt;使用mirrormaker进行迁移topic到另外的集群:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;bin/kafka-mirror-maker.sh
      --consumer.config consumer.properties
      --producer.config producer.properties --whitelist my-topic&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要注意，我们必须使用&lt;code&gt;--whitelist&lt;/code&gt;参数指定topic，该参数支持java的正则表达式结构，比如&lt;code&gt;--whitelist &#39;A|B&#39;&lt;/code&gt;，或者&lt;code&gt;--whitelist &#39;*&#39;&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;通常在使用kafka-mirror-maker时，建议配合&lt;code&gt;auto.create.topics.enable=true&lt;/code&gt;使用，可以大批量的进行topic迁移。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Checking consumer position&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;检查消费者的位移，有时候了解消费者当前的位置时很有必要的。&lt;/p&gt;

&lt;p&gt;kafka有一个工具，它将显示所有消费者在一个消费者组中的位置，以及他们与日志结束的距离&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 在my-group的消费者上消费my-topic的主题
# 可以查看整个消费者组的消费情况
$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Managing Consumer Groups&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ConsumerGroupCommand工具可以&lt;code&gt;list, describe, or delete&lt;/code&gt;一个消费组，消费者组可以手动删除，也可以在该组最后提交的偏移量过期时自动删除。&lt;/p&gt;

&lt;p&gt;只有在组中没有任何活动成员时，手动删除才有效。&lt;/p&gt;

&lt;p&gt;如下命令可以列出所有主题的所有消费者组:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --list&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;查看指定消费者组&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当然可用试用一些额外的参数来查看更多的消费者信息：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;members: 查看消费者组中活跃的消费者&lt;/li&gt;
&lt;li&gt;&amp;ndash;members &amp;ndash;verbose: 该参数还可以查看分配给每个成员的分区&lt;/li&gt;
&lt;li&gt;&amp;ndash;offsets: 该参数实际上可以被&lt;code&gt;--describe&lt;/code&gt;参数中的内容覆盖掉&lt;/li&gt;
&lt;li&gt;&amp;ndash;state: 该参数可以提供组级别的信息&lt;/li&gt;
&lt;li&gt;&amp;ndash;delete: 该参数可以手动删除一个或多个消费者组&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-reset-offsets: 该参数用于重置消费者组的偏移量，此选项在同一时间支持一个消费者组，同时需要使用&lt;code&gt;--all-topics或--topic&lt;/code&gt;指定范围&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 查看消费者组成员
$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group --members

CONSUMER-ID                                    HOST            CLIENT-ID       #PARTITIONS
consumer1-3fc8d6f1-581a-4472-bdf3-3515b4aee8c1 /127.0.0.1      consumer1       2
consumer4-117fe4d3-c6c1-4178-8ee9-eb4a3954bee0 /127.0.0.1      consumer4       1
consumer2-e76ea8c3-5d30-4299-9005-47eb41f3d3c4 /127.0.0.1      consumer2       3
consumer3-ecea43e4-1f01-479f-8349-f9130b75d8ee /127.0.0.1      consumer3       0

# 查看消费者组成员详细信息(分区)
$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group --members --verbose

CONSUMER-ID                                    HOST            CLIENT-ID       #PARTITIONS     ASSIGNMENT
consumer1-3fc8d6f1-581a-4472-bdf3-3515b4aee8c1 /127.0.0.1      consumer1       2               topic1(0), topic2(0)
consumer4-117fe4d3-c6c1-4178-8ee9-eb4a3954bee0 /127.0.0.1      consumer4       1               topic3(2)
consumer2-e76ea8c3-5d30-4299-9005-47eb41f3d3c4 /127.0.0.1      consumer2       3               topic2(1), topic3(0,1)
consumer3-ecea43e4-1f01-479f-8349-f9130b75d8ee /127.0.0.1      consumer3       0               -

# --state参数

$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group my-group --state

COORDINATOR (ID)          ASSIGNMENT-STRATEGY       STATE                #MEMBERS
localhost:9092 (0)        range                     Stable               4

# 删除消费者组
$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --delete --group my-group --group my-other-group

Deletion of requested consumer groups (&amp;#39;my-group&amp;#39;, &amp;#39;my-other-group&amp;#39;) was successful.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; &lt;code&gt;--reset-offsets&lt;/code&gt;选项支持如下三个执行选项:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;显示要重置的偏移量&lt;/li&gt;
&lt;li&gt;&amp;ndash;execute: 执行&lt;code&gt;--reset-offsets&lt;/code&gt;进程&lt;/li&gt;
&lt;li&gt;&amp;ndash;export: 以csv格式导出执行结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;--reset-offsets&lt;/code&gt;参数还有如下方案可供选择:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;to-datetime: 重置offset到另外一个offset (format:YYYY-MM-DDTHH:mm:SS.sss)&lt;/li&gt;
&lt;li&gt;&amp;ndash;to-earliest: 重置offset到最早的offset&lt;/li&gt;
&lt;li&gt;&amp;ndash;to-latest: 重置为最新的offset&lt;/li&gt;
&lt;li&gt;&amp;ndash;shift-by: 重置offset为n&lt;/li&gt;
&lt;li&gt;&amp;ndash;from-file: 重置到csv中定义的offset&lt;/li&gt;
&lt;li&gt;&amp;ndash;to-current: 重置offset到当前&lt;/li&gt;
&lt;li&gt;&amp;ndash;by-duration: 重置offset为当前时间( Format: &amp;lsquo;PnDTnHnMnS&amp;rsquo;)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;to-offset: 重置offset为指定的值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 设置消费者组的offset为最新
$ bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --reset-offsets --group consumergroup1 --topic topic1 --to-latest

TOPIC                          PARTITION  NEW-OFFSET
topic1                         0          0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你还是使用老的&lt;code&gt;high-level&lt;/code&gt;消费者，并且将组的元数据存储在zk中(&lt;code&gt;offsets.storage=zookeeper&lt;/code&gt;)，可以使用&lt;code&gt;--zookeeper&lt;/code&gt;来代替&lt;code&gt;bootstrap-server&lt;/code&gt;参数:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;bin/kafka-consumer-groups.sh --zookeeper localhost:2181 --list&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Expanding your cluster&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;集群的扩展.&lt;/p&gt;

&lt;p&gt;将服务器添加到Kafka集群很容易，只需为它们分配一个惟一的brokerid，并在新服务器上启动Kafka.&lt;/p&gt;

&lt;p&gt;然而，这些新服务器不会自动分配任何数据分区，因此，除非将分区移动到它们，否则在创建新主题之前，它们不会做任何工作。&lt;/p&gt;

&lt;p&gt;因此，通常在向集群中添加机器时，您会希望将一些现有数据迁移到这些机器上。&lt;/p&gt;

&lt;p&gt;迁移数据的过程是手动启动的，但是完全自动化。&lt;/p&gt;

&lt;p&gt;实际上，Kafka将添加新服务器作为它正在迁移的分区的追随者，并允许它完全复制该分区中的现有数据。&lt;/p&gt;

&lt;p&gt;当新服务器完全复制了该分区的内容并加入同步副本时，现有副本中的一个将删除其分区的数据。&lt;/p&gt;

&lt;p&gt;可以使用分区重新分配工具在broker之间移动分区。&lt;/p&gt;

&lt;p&gt;理想的分区分布应该确保所有broker之间的数据负载和分区大小是一致的。&lt;/p&gt;

&lt;p&gt;分区重新分配工具不具备自动研究Kafka集群中的数据分布并移动分区以获得均匀的负载分布的能力，因此，管理员必须确定应该移动哪些主题或分区。&lt;/p&gt;

&lt;p&gt;分区迁移工具可以运行在三种互斥模式下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--generate&lt;/code&gt;: 给定主题列表和broker列表，该工具生成一个候选重新分配，将指定主题的所有分区移动到新的broker，该参数仅帮助管理员方便的来生成给定主题和目标broker列表的分区重新分配计划&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--execute&lt;/code&gt;: 该工具根据用户提供的重新分配计划开始重新分配分区(使用&lt;code&gt;--reassignment-json-file&lt;/code&gt;指定生成的迁移配置)，- &lt;code&gt;--verify&lt;/code&gt;: 该工具将验证列出的所有分区的重新分配状态，可以是成功完成、失败或正在进行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;1.自动迁移数据到新的服务器&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分区重新分配工具可用于将某些主题从当前broker集移到新添加的broker。 这在扩展现有集群时通常很有用，因为与一次移动一个分区相比，将整个主题移至新的broker集更容易。 用于执行此操作时，用户应提供应移至新的一组broker的主题列表和新broker的目标列表。 然后，该工具将给定主题列表中的所有分区平均分配到新的一组broker中。 在此过程中，主题的复制因子保持不变。 有效地，将输入主题列表的所有分区的副本从旧的broker集移至新添加的broker。&lt;/p&gt;

&lt;p&gt;如下示例(topic:foo1和foo2的全部分区移动到broker 5和6上，迁移完成后，该topic的全部分区将在Broker5和6上):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ cat topics-to-move.json
{&amp;#34;topics&amp;#34;: [{&amp;#34;topic&amp;#34;: &amp;#34;foo1&amp;#34;},
            {&amp;#34;topic&amp;#34;: &amp;#34;foo2&amp;#34;}],
&amp;#34;version&amp;#34;:1
}

# 准备好json文件之后，使用分区重新分配工具生成一个候选分配
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --topics-to-move-json-file topics-to-move.json --broker-list &amp;#34;5,6&amp;#34; --generate
Current partition replica assignment

{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[1,2]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3,4]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[1,2]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3,4]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]}]
}

Proposed partition reassignment configuration

{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[5,6]}]
}

# 该工具生成一个将移动所有分区的候选分配(分配到哪些broker上)，此时分区移动还没有开始，它只告诉您当前的分配和建议的新分配。
# 应该保存当前的赋值，以防您想要回滚到它.
# 使用生成的迁移计划进行迁移
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --execute
Current partition replica assignment

{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[1,2]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3,4]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[1,2]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3,4]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]}]
}

Save this to use as the --reassignment-json-file option during rollback
Successfully started reassignment of partitions
{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[5,6]}]
}

# 最后使用--verify选项验证迁移状态
# 注意:使用相同的迁移计划任务expand-cluster-reassignment.json
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file expand-cluster-reassignment.json --verify
Status of partition reassignment:
Reassignment of partition [foo1,0] completed successfully
Reassignment of partition [foo1,1] is in progress
Reassignment of partition [foo1,2] is in progress
Reassignment of partition [foo2,0] completed successfully
Reassignment of partition [foo2,1] completed successfully
Reassignment of partition [foo2,2] completed successfully&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;2.自定义分区分配和迁移&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;分区重分配工具还可以用于有选择地将分区的副本移动到一组特定的broker。&lt;/p&gt;

&lt;p&gt;当我们以这种方式使用时，假设用户知道重新分配计划，并且不需要该工具来生成候选的重新分配，即直接使用用户的分配策略进行数据迁移。&lt;/p&gt;

&lt;p&gt;示例: 迁移topic&lt;code&gt;foo1&lt;/code&gt;的partition-0到broker5和6，partition-1到broker2和3&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 自定义迁移计划
$ cat custom-reassignment.json
{&amp;#34;version&amp;#34;:1,&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},{&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]}]}

# 使用--execute选项执行上述的迁移计划
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file custom-reassignment.json --execute
Current partition replica assignment

{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[1,2]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[3,4]}]
}

Save this to use as the --reassignment-json-file option during rollback
Successfully started reassignment of partitions
{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo1&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6]},
              {&amp;#34;topic&amp;#34;:&amp;#34;foo2&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2,3]}]
}

# --verify来验证迁移状态

$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file custom-reassignment.json --verify
Status of partition reassignment:
Reassignment of partition [foo1,0] completed successfully
Reassignment of partition [foo2,1] completed successfully&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Decommissioning brokers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分区重新分配工具还不能自动生成用于退役broker的重新分配计划，因此，管理员必须制定一个重新分配计划，将托管在代理上的所有分区的副本迁移到代理的其余部分。&lt;/p&gt;

&lt;p&gt;这可能比较繁琐，因为重新分配需要确保所有副本不会从已退役的代理移动到另一个代理。为了简化这个过程，我们计划在将来为退役代理添加工具支持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Increasing replication factor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;增加现有分区的复制因子很容易，只需在定制的重新分配json文件中指定额外的副本，并使用—execute选项来增加指定分区的复制因子。&lt;/p&gt;

&lt;p&gt;示例: 将主题foo的partition-0的副本从1增加到3。在增加复制因子之前，代理5上只存在分区的副本，作为增加复制因子的一部分，我们将在代理6和代理7上添加更多的副本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 自定义迁移配置
$ cat increase-replication-factor.json
{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6,7]}]}

# 执行
bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file increase-replication-factor.json --execute
Current partition replica assignment

{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5]}]}

Save this to use as the --reassignment-json-file option during rollback
Successfully started reassignment of partitions
{&amp;#34;version&amp;#34;:1,
&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;foo&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[5,6,7]}]}

# 验证
bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --reassignment-json-file increase-replication-factor.json --verify
Status of partition reassignment:
Reassignment of partition [foo,0] completed successfully

# 查看副本数
$ bin/kafka-topics.sh --bootstrap-server localhost:9092 --topic foo --describe
Topic:foo   PartitionCount:1    ReplicationFactor:3 Configs:
  Topic: foo    Partition: 0    Leader: 5   Replicas: 5,6,7 Isr: 5,6,7&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Limiting Bandwidth Usage during Data Migration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kafka允许您对复制流量施加限制，设置用于将副本从一台机器移动到另一台机器的带宽上限。&lt;/p&gt;

&lt;p&gt;这在重新平衡集群、引导新代理或添加或删除代理时非常有用，因为它限制了这些数据密集型操作对用户的影响&lt;/p&gt;

&lt;p&gt;最简单的方式就是在使用&lt;code&gt;kafka-reassign-partitions.sh&lt;/code&gt;脚本时，使用限流功能，不过&lt;code&gt;kafka-configs.sh&lt;/code&gt;脚本也具有该功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 限制在执行重平衡时，迁移速度不能超过50MB/s.
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181 --execute --reassignment-json-file bigger-cluster.json —throttle 50000000

# 当然，如果要改变速率的限制，可以重新运行
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181  --execute --reassignment-json-file bigger-cluster.json --throttle 700000000
  There is an existing assignment running.
  The throttle limit was set to 700000000 B/s

# 一旦完成重平衡后，就可以再次验证
# 需要注意:当冲平衡完成后，使用--verify验证时需要删除限流，否则会影响正常复制
$ bin/kafka-reassign-partitions.sh --zookeeper localhost:2181  --verify --reassignment-json-file bigger-cluster.json
Status of partition reassignment:
Reassignment of partition [my-topic,1] completed successfully
Reassignment of partition [mytopic,0] completed successfully
Throttle was removed.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;查看broker的限流配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ bin/kafka-configs.sh --describe --zookeeper localhost:2181 --entity-type brokers
Configs for brokers &amp;#39;2&amp;#39; are leader.replication.throttled.rate=700000000,follower.replication.throttled.rate=700000000
Configs for brokers &amp;#39;1&amp;#39; are leader.replication.throttled.rate=700000000,follower.replication.throttled.rate=700000000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这显示了应用于复制协议的leader和follower端上的节流。默认情况下，两边分配相同的节流吞吐量值。&lt;/p&gt;

&lt;p&gt;查看限流的副本:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ bin/kafka-configs.sh --describe --zookeeper localhost:2181 --entity-type topics
Configs for topic &amp;#39;my-topic&amp;#39; are leader.replication.throttled.replicas=1:102,0:101,
    follower.replication.throttled.replicas=1:101,0:102&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Setting quotas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配额设置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 为user=user1, client-id=clientA配置自定义配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type users --entity-name user1 --entity-type clients --entity-name clientA
Updated config for entity: user-principal &amp;#39;user1&amp;#39;, client-id &amp;#39;clientA&amp;#39;.

# 为user=user1配置配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type users --entity-name user1
Updated config for entity: user-principal &amp;#39;user1&amp;#39;.

# 为client-id=clientA配置配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type clients --entity-name clientA
Updated config for entity: client-id &amp;#39;clientA&amp;#39;.

# 为user=userA配置默认的配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type users --entity-name user1 --entity-type clients --entity-default
Updated config for entity: user-principal &amp;#39;user1&amp;#39;, default client-id.

# 为user配置默认配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type users --entity-default
Updated config for entity: default user-principal.

# 为client-id配置默认配额
$  bin/kafka-configs.sh  --zookeeper localhost:2181 --alter --add-config &amp;#39;producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&amp;#39; --entity-type clients --entity-default
Updated config for entity: default client-id.

# 查看配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type users --entity-name user1 --entity-type clients --entity-name clientA
Configs for user-principal &amp;#39;user1&amp;#39;, client-id &amp;#39;clientA&amp;#39; are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200

$ bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type users --entity-name user1
Configs for user-principal &amp;#39;user1&amp;#39; are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200

$ bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type clients --entity-name clientA
Configs for client-id &amp;#39;clientA&amp;#39; are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200

# 如果不指定entity name ，将显示所有的entity-type的配额
$ bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type users
Configs for user-principal &amp;#39;user1&amp;#39; are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200
Configs for default user-principal are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200

$ bin/kafka-configs.sh  --zookeeper localhost:2181 --describe --entity-type users --entity-type clients
Configs for user-principal &amp;#39;user1&amp;#39;, default client-id are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200
Configs for user-principal &amp;#39;user1&amp;#39;, client-id &amp;#39;clientA&amp;#39; are producer_byte_rate=1024,consumer_byte_rate=2048,request_percentage=200&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: 在broker的配置中增加如下配置，会默认为全部的生产者和消费者进行配额限制.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 生产者和消费者10MB/s
quota.producer.default=10485760
quota.consumer.default=10485760&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#operations&#34;&gt;kafka-operations&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>kafka生产规划和运维</title>
      <link>https://bgbiao.top/post/kafka%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E7%BB%B4/</link>
      <pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/kafka%E7%94%9F%E4%BA%A7%E8%A7%84%E5%88%92%E5%92%8C%E8%BF%90%E7%BB%B4/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;前言: 通常对于初创企业或者初创业务团队来说，对于开源组件的使用都会显的比较随意，而这种情况会随着业务量级的增长或时间的推移导致开源服务的滥用，进而造成的结果就是服务整体的稳定性和可靠性相对较差，且是边际效应递减的，如果此时不对整体业务以及开源服务进行规划和改造，那么风险和成本将是同比增长的。在我过去的工作经历中，经历过类似服务的有&lt;code&gt;Redis集群&lt;/code&gt;，&lt;code&gt;ElasticSearch&lt;/code&gt;集群，虽然整体改造后并不一定将成本降到最低，但是可以将服务的可用性和可靠性提高很多，而且根据业务场景以及使用方式来规划集群后会使得整体的边际成本呈递减状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;笔者目前所处的团队所管理的kafka集群也处于该种状态，集群当前规模大约为20+ECS，总数据量大约400T，其中承接的Topic服务主要分为&lt;code&gt;日志收集&lt;/code&gt;、&lt;code&gt;数据管道&lt;/code&gt;、&lt;code&gt;流式计算&lt;/code&gt;、&lt;code&gt;业务事件存储&lt;/code&gt;几种大场景，我们需要知道，以上几种使用场景对于kafka集群的的&lt;code&gt;可用性&lt;/code&gt;，&lt;code&gt;可靠性&lt;/code&gt;，&lt;code&gt;数据一致性&lt;/code&gt;要求其实是不同的，如果将所有场景耦合到同一个集群，在数据量较大的情况下，任何的小异常点都可能造成整体服务受到影响，并且整个集群的恢复周期会很长，如果业务没有及时的降级策略很可能影响核心业务的处理。&lt;/p&gt;

&lt;p&gt;鉴于以前对开源分布式服务的规划和改造经验，本篇文章将根据官方文档以及经验来分享一些关于Kafka生产集群规划和运维管理相关的知识.&lt;/p&gt;

&lt;h2 id=&#34;一-kafka集群运维和规划&#34;&gt;一、Kafka集群运维和规划&lt;/h2&gt;

&lt;p&gt;其实任何开源的分布式系统在开始规划时，就需要考虑到业务场景，以及生产环境的周边可观测系统，比如如下几个方面:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;规划和部署生产级别的集群(包含官方最佳实践以及一些针对不停场景推荐的配置项变更)&lt;/li&gt;
&lt;li&gt;执行一些部署后的操作(比如滚动重启集群，集群备份，数据迁移等等)&lt;/li&gt;
&lt;li&gt;集群的可观测性(监控重要统计数据，理解kafka内部行为的具体含义以及是否需要报警通知)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;二-集群规划&#34;&gt;二、集群规划&lt;/h2&gt;

&lt;p&gt;本节主要介绍，kafka集群在生产环境部署前的一些规划，包含硬件配置选择，网络以及文件系统和其他考虑的选型.&lt;/p&gt;

&lt;h3 id=&#34;1-硬件和os&#34;&gt;1.硬件和OS&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;通常对于分布式的开源服务来将对于硬件本身没有太高的要求，但当需要承载一定量级的业务时，我们需要考虑一些硬件是否能够支撑对应的业务场景，并且通常来讲针对不同的业务场景选择不同的硬件(如果可选择)，也许会适当降低资源成本。&lt;/p&gt;

&lt;h4 id=&#34;1-0-os&#34;&gt;1.0 OS&lt;/h4&gt;

&lt;p&gt;一般来说，对于运行Linux中的kafka集群不需要过多的OS以及kernel参数调整，但如下几种情况可以根据具体情况进行参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;文件描述符(fd)&lt;/code&gt;: broker节点上fd限制可以参考&lt;code&gt;(number_of_partitions)*(partition_size/segment_size)&lt;/code&gt;公式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;套接字缓冲区(socket buffer)&lt;/code&gt;: 该参数可以增加多数据中心之间的数据传输(一般异地集群备份建议调整以增加吞吐)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最大内存映射区域数(vm.max_map_count)&lt;/code&gt;: 当kafka broker节点拥有太多分区时应该密切关注系统级别的该参数，默认为65535。每一个日志段，分配的分区，都需要一对&lt;code&gt;index/timeindex&lt;/code&gt;文件，而每个文件都会消耗一个内存区域(一个日志段使用2个内存映射区域)，因此一个分区至少需要2个内存区域，一个broker上拥有50000分区时，将会消耗100000个内存区域，此时默认的参数就会导致broker 以&lt;code&gt;OutOfMemoryError&lt;/code&gt;方式crash掉。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;每个分区的日志段的数量取决于段(segment)的大小，负载，以及保留策略&lt;/p&gt;

&lt;p&gt;kafka使用大量的文件以及socket和客户端进行通讯，我们都知道，在Linux下，一切皆文件，因此系统需要设置更多的可用文件描述符&amp;gt;。&lt;/p&gt;

&lt;p&gt;在大多数的默认系统配置中，单个进程可用使用1024个文件描述符，对于kafka来说太小了，建议调整到至少&lt;code&gt;100000&lt;/code&gt;，但是通常和操作
系统以及发行版本有关系，需要根据具体的OS进行调整。&lt;/p&gt;

&lt;p&gt;可用通过计算Kafka数据目录中的&lt;code&gt;.index&lt;/code&gt;文件来计算当前的mmap编号。&lt;code&gt;.index&lt;/code&gt;文件大多数代表了内存映射文件。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 1.统计.index文件个数
$ find . -name &amp;#39;*index&amp;#39; | wc -l

# 2.为每个session设置vm.max_map_count参数，这将计算当前内存映射文件的数量，mmap限制的最小值就是打开文件的ulimit限制
# 该值要远大于index的数量
$ sysctl -w vm.max_map_count=262144

# 3.持久化mmap参数
$ echo &amp;#39;vm.max_map_count=262144&amp;#39; &amp;gt;&amp;gt; /etc/sysctl.conf
$ sysctl -p&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;1-1-内存&#34;&gt;1.1 内存&lt;/h4&gt;

&lt;p&gt;Kafka严重依赖文件系统来存储和缓存消息。&lt;/p&gt;

&lt;p&gt;所有数据都会立即写入文件系统上的持久日志中，而不必刷新到磁盘。实际上，这仅意味着将其转移到内核的页面缓存&lt;code&gt;pagecache&lt;/code&gt;中。 当回收内存时，操作系统会将可用内存转移到磁盘缓存中，而对性能的影响很小。&lt;/p&gt;

&lt;p&gt;同时，Kafka非常小心地使用堆空间&lt;code&gt;heap space&lt;/code&gt;，不需要将堆大小设置为超过6 GB，这样将会在32G内存的机器上缓存28-30G的数据到文件系统。&lt;/p&gt;

&lt;p&gt;因此，生产集群需要足够的内存来缓存活动的reader和writer。在Confluent的使用建议中，提出了对内存需求的粗略估计方式，比如需要缓冲30s，那么内存需求大概为&lt;code&gt;write_throughput * 30&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通常来讲&lt;code&gt;64G&lt;/code&gt;内存配置的机器是一个不错的选择.&lt;/p&gt;

&lt;h4 id=&#34;1-2-cpu&#34;&gt;1.2 CPU&lt;/h4&gt;

&lt;p&gt;大多数的kafka集群对于cpu的要求不是那么高，因此对于CPU的配置没有像其他资源那么重要(但是通常同等资源都是由一定比例配比的)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 如果开启了SSL，那么可能对集群的整体性能有一定影响，且对cpu有一定要求，具体需要考虑到cpu的类型以及具体的JVM实现细节(通常来讲内部服务均不会开启SSL，因为管理成本很高，且性能上略有损失，安全上可以通过整体的IT安全进行要求和管控)&lt;/p&gt;

&lt;p&gt;通常情况下建议使用较新的多核处理器，通用集群可以设置为&lt;code&gt;24&lt;/code&gt;核心。&lt;/p&gt;

&lt;p&gt;如果需要在更快的CPU或更多的内核之间进行选择，请选择更多的内核，因为多核提供的额外并发性将远远超过稍快的时钟速度。&lt;/p&gt;

&lt;h4 id=&#34;1-3-disk&#34;&gt;1.3 Disk&lt;/h4&gt;

&lt;p&gt;生产集群建议使用多块磁盘来最大化整体的吞吐，不要与应用程序日志或其他OS文件系统活动共享用于Kafka数据的相同驱动器，以确保良好的延迟。&lt;/p&gt;

&lt;p&gt;在官方的最佳实践中建议，可以将&lt;code&gt;多块磁盘构建成RAID&lt;/code&gt;，或者直接将独立的&lt;code&gt;多块磁盘&lt;/code&gt;作为kafka的数据存储，也就是JBOD方案(Just Bunch Of Disks)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;备注:&lt;/code&gt;如果软RAID的话其实会在存储方面增加一层数据均衡，增加了集群的复杂度，因此一般可用选择后者，而且RAID主要用于提供冗余，对于开源分布式服务来讲，在软件层面上基本都会保证数据的冗余。&lt;/p&gt;

&lt;p&gt;不过在实际的场景中，具体选择使用多块盘做RAID还是直接使用多块盘挂载，以下有几种场景可以考虑:&lt;/p&gt;

&lt;p&gt;如果配置多个数据目录，则Broker将在路径中放置一个新分区，该分区中当前存储的分区数最少。每个分区将完全位于数据目录之一中，如果&lt;code&gt;分区之间的数据不平衡，就会导致磁盘之间的负载不平衡&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;RAID在平衡磁盘之间的负载方面做得更好，它能在较低的水平上平衡负载。RAID的主要缺点是减少了可用的磁盘空间(RAID0除外)，好处是可以容忍磁盘故障(RAID1，RAID5等)。&lt;/p&gt;

&lt;p&gt;在生产中强烈不建议使用RAID 5 or RAID 6 ,会严重影响到写吞吐的性能，并且在磁盘故障时会有重建阵列的I/O成本(&lt;code&gt;RAID0下也存在重建I/O的成本&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;如果额外的成本可以接受，建议使用RAID10(容量减半，多一份冗余)，否则，建议Kafka服务器配置多个日志目录，每个目录都安装在单独的驱动器上。&lt;/p&gt;

&lt;p&gt;linked使用8x7200转的sata磁盘，一般来说，磁盘吞吐量是性能瓶颈，磁盘越多越好。&lt;/p&gt;

&lt;p&gt;kafka官方文档中其实建议使用多个驱动器以获得良好的吞吐量，因为每个路径都独立挂载在不同的磁盘上，这使得多块物理磁盘磁头同时执行物理I/O写操作，可以极大地加速Kafka消息生产的速度。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 通常在使用本地盘时，容量可能会比较大，当磁盘容量超过2T时，Linux下默认的MBR分区就不能满足容量的要求了，此时需要在分区时进行GPT分区，否则等线上业务真正上线后会发现超过2T的空间就被浪费了。&lt;/p&gt;

&lt;p&gt;另外一个问题就是，磁盘容量规划的问题，虽然kafka默认为全部的日志数据设置了7天保留时间，但是往往在海量的数据消费场景中，单天的数据量也可能达到好几个T，这就导致了需要提前对业务的场景和使用方式进行提前规划，并提前计算最少的存储量。&lt;/p&gt;

&lt;p&gt;但一般对于磁盘空间的规划可以根据消息量大概估算，比如一天7亿条消息，单条1kb，消息副本为3(可保证2节点同时挂)，那么大概的存储空间为&lt;code&gt;7亿*3*1KB/1000/1000=2100G&lt;/code&gt;，也就是这种规模下的数据，一天产生2T的数据，实际使用数据为700G，1400G数据为冗余数据，此时我们在规划磁盘容量时就需要考虑到单天数据量的大小，以及数据的保留时间。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 如果客户端开启了消息压缩，整体的数据能再相对小一些，可以根据具体情况来考虑&lt;/p&gt;

&lt;h4 id=&#34;1-4-network&#34;&gt;1.4 Network&lt;/h4&gt;

&lt;p&gt;在分布式系统中，快速可靠的网络是性能的一个重要组成部分(&lt;code&gt;因此通常分布式系统中建议在同机房&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;低延迟确保节点可以轻松通信，而高带宽有助于集群节点之前的副本移动和恢复(&lt;code&gt;往往在kafka集群中优先瓶颈点都是带宽&lt;/code&gt;)。&lt;/p&gt;

&lt;p&gt;目前大多数的数据中心基本都是千兆(1 GbE)或万兆网络(10 GbE)，对于大多数集群通常都是足够的。&lt;/p&gt;

&lt;p&gt;应该尽量避免集群跨越多个数据中心，即使数据中心在很近的距离同地区，也要避免跨越巨大地理距离的集群。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;备注:&lt;/code&gt;实际上在分布式系统中分区是肯定会发生的，通过避免跨机房部署能够降低分区的概率&lt;/p&gt;

&lt;p&gt;Kafka集群假设所有节点都是相等的，较大的延迟可能会加剧分布式系统中的问题，并使调试和解决变得更加困难。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 如果业务上需要异地进行数据读写，推荐的方法是在每个数据中心中部署一个本地Kafka集群，每个数据中心中的应用程序实例只与它们的本地集群交互，并在集群之间进行镜像(kafka提供了mirror-maker工具)。&lt;/p&gt;

&lt;h4 id=&#34;1-5-filesystem&#34;&gt;1.5 Filesystem&lt;/h4&gt;

&lt;p&gt;现在操作系统中，大部分的系统应该都使用了&lt;code&gt;Ext4&lt;/code&gt;或&lt;code&gt;XFS&lt;/code&gt;系统，官方也推荐使用这两种文件系统，但是对于具体的文件系统的选择，官方提供了如下几种场景和需要注意的点。&lt;/p&gt;

&lt;p&gt;使用各种文件系统创建和挂载选项，在具有大量消息负载的集群上执行了比较测试，XFS带来了更好的本地时间(最好的EXT4配置是160ms vs. 250ms+)，以及更低的平均等待时间。XFS性能在磁盘性能方面的可变性也较小。&lt;/p&gt;

&lt;p&gt;不论是使用哪种文件系统，推荐修改默认的挂载参数:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;noatime&lt;/code&gt;: 此选项禁止在读取文件时更新文件的atime(最后访问时间)属性,这可以消除大量的文件系统写操作，特别是在引导消费者的情况下,Kafka完全不依赖于atime属性，所以禁用它是安全的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ cat /etc/fstab
UUID=&amp;#34;4231b126-7e67-45c4-b8bf-554006291d35&amp;#34;  /export1    xfs    defaults,noatime         0 2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;XFS文件系统挂载参数优化:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;largeio&lt;/code&gt;: 这会影响stat调用报告的首选I/O大小，尽管这可以在较大的磁盘写入上实现更高的性能，但实际上对性能的影响很小或没有影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nobarrier&lt;/code&gt;: 于具有电池后备缓存的基础设备，此选项可以通过禁用定期写刷新来提供更高的性能。 但是，如果基础设备的行为良&amp;gt;好，它将向文件系统报告它不需要刷新，并且此选项将无效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EXT文件系统挂载参数优化:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在ext4文件系统下，要获得最佳性能，则需要调整几个参数。这些选项在故障情况下通常是不安全的，并且将导致更多的数据丢失和损坏，对于单个broker故障，可以擦除磁盘并从群集重建副本，在多数情况下，多broker异常意味着潜在的文件系统损坏，无法轻易恢复。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data=writeback&lt;/code&gt;: Ext4默认为data = ordered，这使某些写入操作具有很强的顺序，在Kafka场景下其实不需要该参数，此设置消除了排序约束，并且似乎大大减少了延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Disabling journaling&lt;/code&gt;: 日志记录是一个折衷:它使服务器崩溃后重新引导更快，但它引入了大量额外的锁定，增加了写入性能的差异&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commit=num_secs&lt;/code&gt;: 这调整了ext4提交到其元数据日志的频率。 将此值设置为较低的值可以减少崩溃期间未刷新数据的丢失。 将此值设置为较高的值将提高吞吐量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nobh&lt;/code&gt;: 此设置控制在使用data=writeback模式时附加的排序保证，可以提高吞吐量和延迟&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delalloc&lt;/code&gt;: 延迟分配意味着文件系统避免在物理写入发生之前分配任何块，此功能非常适合吞吐量&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-6-application-vs-os-flush-management&#34;&gt;1.6 Application vs. OS Flush Management&lt;/h4&gt;

&lt;p&gt;Kafka始终会立即将所有数据写入文件系统，并支持配置刷新策略的功能，该策略控制何时使用刷新将数据从OS缓存中强制出到磁盘上。&lt;/p&gt;

&lt;p&gt;可以控制此刷新策略，以在一段时间后或在写入一定数量的消息之后将数据强制到磁盘。 在此配置中有几种选择。&lt;/p&gt;

&lt;p&gt;Kafka必须最终调用fsync才能知道数据已刷新。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;当从崩溃中恢复任何未知的日志段时，Kafka将通过检查其消息的CRC来检查每条消息的完整性，并在启动时执行的恢复过程中重建附带的偏移索引文件&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;请注意，Kafka中的持久性不需要将数据同步到磁盘，因为发生故障的节点将始终从其副本中恢复。&lt;/p&gt;

&lt;p&gt;我们建议使用默认刷新设置，该设置将完全禁用应用程序的fsync。&lt;/p&gt;

&lt;p&gt;这意味着依靠操作系统和Kafka自己的后台刷新来完成后台刷新。&lt;/p&gt;

&lt;p&gt;这为所有用途提供了最佳的解决方案：无需调节配置，提高吞吐量和延迟，并提供完全恢复保证。&lt;/p&gt;

&lt;p&gt;通常，我们认为&lt;code&gt;复制&lt;/code&gt;提供的保证要强于&lt;code&gt;同步到本地磁盘&lt;/code&gt;，但是偏执狂仍然更愿意同时拥有两者，并且仍然支持应用程序级fsync策略。&lt;/p&gt;

&lt;p&gt;使用应用程序级刷新设置的缺点是，其磁盘使用模式效率较低（它给操作系统减少了重新排序写操作的余地），并且由于大多数Linux文件系统中的fsync阻止了文件写入，因此它会引入延迟。 后台刷新进行更精细的页面级锁定。&lt;/p&gt;

&lt;h4 id=&#34;1-7-理解linux操作系统的flush行为&#34;&gt;1.7 理解Linux操作系统的Flush行为&lt;/h4&gt;

&lt;p&gt;在Linux中，写入文件系统的数据将保留在页面缓存中，直到必须将其写出到磁盘为止（由于应用程序级fsync或操作系统自身的刷新策略）。&lt;/p&gt;

&lt;p&gt;数据刷新是通过一组称为pdflush的后台线程完成的（或在2.6.32版的内核“冲洗线程”中）。&lt;/p&gt;

&lt;p&gt;Pdflush具有可配置的策略，该策略控制可以在缓存中维护多少脏数据以及必须将多脏数据写回到磁盘的时间.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://web.archive.org/web/20160518040713/http://www.westnet.com/~gsmith/content/linux-pdflush.htm&#34;&gt;pdflush刷新策略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当Pdflush无法跟上写入数据的速度时，它将最终导致写入过程阻塞写入中的延迟，从而减慢数据的累积。&lt;/p&gt;

&lt;p&gt;与进程内缓存相比，使用pagecache存储将写入磁盘的数据有几个优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I/O调度将连续的小写批量写到更大的物理写中，从而提高吞吐量&lt;/li&gt;
&lt;li&gt;I/O调度尝试重新排序写操作，以最小化磁盘头的移动，从而提高吞吐量&lt;/li&gt;
&lt;li&gt;它会自动使用机器上所有的空闲内存&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-节点配置&#34;&gt;2.节点配置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;1.避免使用太小的节点配置，因为这样整个集群的节点数可能会特别多，在这种机器上运行kafka将会有更多的开销&lt;/li&gt;
&lt;li&gt;2.避免使用太高配计算机，因为它们经常导致资源使用不平衡，比如内存优先不够了，但cpu还剩余很多。如果在每个高配机器上运行多个broker节点，将会增加整体的复杂度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-jvm配置&#34;&gt;3.JVM配置&lt;/h3&gt;

&lt;p&gt;在当前大多数Java类应用下，基本都在使用JDK8(建议使用最新的jdk8)，在此环境下默认使用的是&lt;code&gt;G1&lt;/code&gt;的垃圾回收器，因此一般情况下仅需要修改如下参数即可:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MaxGCPauseMillis&lt;/code&gt;: 指定每次垃圾回收默认的停顿时间，默认值200ms&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InitiatingHeapOccupancyPercent&lt;/code&gt;: G1 启动新一轮垃圾回收之前可以使用的堆内存百分比，默认值是45&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;官方推荐的GC参数如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;-Xms6g -Xmx6g -XX:MetaspaceSize=96m -XX:+UseG1GC -XX:MaxGCPauseMillis=20
       -XX:InitiatingHeapOccupancyPercent=35 -XX:G1HeapRegionSize=16M
       -XX:MinMetaspaceFreeRatio=50 -XX:MaxMetaspaceFreeRatio=80&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;作为参考，LinkedIn最繁忙的集群当前是如下情况:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;60 brokers&lt;/li&gt;
&lt;li&gt;50k partitions (replication factor 2)&lt;/li&gt;
&lt;li&gt;800k messages/sec in&lt;/li&gt;
&lt;li&gt;300 MBps inbound, 1 GBps + outbound&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的GC调优看起来比较激进，但集群中的所有broker都会有90%的gc中止时间，大概21ms，它们做不到每秒一个young GC&lt;/p&gt;

&lt;h3 id=&#34;4-kafka核心配置&#34;&gt;4.kafka核心配置&lt;/h3&gt;

&lt;p&gt;Kafka默认设置在大多数情况下都能工作，特别是与性能相关的设置和选项，但是考虑到集群的规划以及场景用途，有一些补充的配置参数可以对生产环境进行调优。&lt;/p&gt;

&lt;p&gt;通常配置上来讲会分为&lt;code&gt;broker端配置&lt;/code&gt;、&lt;code&gt;produser端配置&lt;/code&gt;、&lt;code&gt;consumer端配置&lt;/code&gt;，由于各个业务方当前均使用开源客户端，因此对于客户端的配置无法做到严格管控(如果有内部的sdk封装可能会比较好)。&lt;/p&gt;

&lt;h4 id=&#34;4-1-重要的客户端配置&#34;&gt;4.1 重要的客户端配置&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;acks&lt;/code&gt;: 消息一致性保证(0:投递即成功,1:副本同步即成功,all/-1:全部ISR同步即成功)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compression&lt;/code&gt;: 压缩类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;batch size&lt;/code&gt;: 批处理大小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 对于消费者来说，最重要的参数为&lt;code&gt;fetch size&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;鉴于集群的整体可用性可靠性其实很大一部分和客户端的使用方式有关，后面会列举一些常见的生产者和消费者端的核心参数&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#configuration&#34;&gt;kafka详细参数列表&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;4-2-broker核心配置&#34;&gt;4.2 broker核心配置&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;zookeeper.connect&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;zk连接串，建议写全部的zk节点地址。&lt;/p&gt;

&lt;p&gt;brokers链接的zk集群地址，该值默认采用&lt;code&gt;host:ip/path&lt;/code&gt;来指定一个zk中的znode节点，通常情况下用来隔离环境. kafka的zk路径中使
用了&lt;code&gt;chroot&lt;/code&gt;环境，如果不指定使用默认的&lt;code&gt;/&lt;/code&gt;来作为存储路径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;broker.id&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker唯一标识，该值可以任意设定(int类型)。默认&lt;code&gt;reserved.broker.max&lt;/code&gt;开始，每次+1&lt;/p&gt;

&lt;p&gt;在分布式集群中，可以手动指定每个broker的节点信息，同时也可以使用如下方式来自动生成每个broker的id&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;#broker.id
broker.id.generation.enable=true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;log.dirs&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;kafka存储的日志消息都是保存在该参数指定的日志路径下，该值可以指定多个磁盘路径，通常我们会绑定到多个磁盘上。比如&lt;code&gt;log.dirs=/exoprt/kafka1,/export/kafka2,/export/kafka3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对应的另外一个默认参数为&lt;code&gt;log.dir&lt;/code&gt;，默认值为&lt;code&gt;/tmp/kafka-logs&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;listeners&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker监听列表，默认将为&lt;code&gt;PLAINTEXT://myhost:9092&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;advertised.listeners&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监听器发布到zk集群中的地址，供客户端使用，默认采用&lt;code&gt;listeners&lt;/code&gt;参数值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;num.recovery.threads.per.data.dir&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;每个数据目录用于在启动时进行日志恢复和在关闭时进行刷新的线程数，默认值为: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;对于如下几种情况，kafka会使用&lt;code&gt;可配置的线程池&lt;/code&gt;来处理日志片段.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务器正常启动: 用于打开每个分区的日志片段&lt;/li&gt;
&lt;li&gt;服务器崩溃后重启: 用于检查和截断每个分区的日志片段&lt;/li&gt;
&lt;li&gt;服务器正常关闭: 用于关闭日志片段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，每个日志目录采用一个线程，因为这些线程仅有在启动和关闭时才用到，所以可以适当设置大一点，并不会影响到整体服务的性能，特别是对于包含大量分区的服务器来说，一旦发生崩愤，在进行恢复时使用井行操作可能会省下数小时的时间。&lt;/p&gt;

&lt;p&gt;需要注意的是，该值是每个日志目录的线程数，因此总线程数需要考虑到&lt;code&gt;log.dirs&lt;/code&gt;的配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;备注&lt;/code&gt;: 这也是在使用RAID和JBOD两种磁盘方案的另外一个考虑点&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;delete.topic.enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是否允许删除topic，默认为: &lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果为false，通过管理工具删除topic仅为标记删除，此时使用&lt;code&gt;describe&lt;/code&gt;命令可以查看到topic的详情信息，但是无法写入，可以通过删除&lt;code&gt;zk&lt;/code&gt;中的节点来删除&lt;/p&gt;

&lt;p&gt;&lt;code&gt;备注&lt;/code&gt;: 生产环境建议设置为&lt;code&gt;false&lt;/code&gt;，由集群管理员定期统一的进行删除和管理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;auto.create.topics.enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;默认情况下，kafka会使用如下三种方式创建topic:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当一个生产者开始往主题写入消息时&lt;/li&gt;
&lt;li&gt;当一个消费者开始从主题读取消息时&lt;/li&gt;
&lt;li&gt;当任意一个客户端向主题发送元数据请求时&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;推荐是设置成&lt;code&gt;false&lt;/code&gt;，不允许客户端直接创建topic，否则topic会无法管理。默认值为&lt;code&gt;true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;auto.leader.rebalance.enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是否开启&lt;code&gt;leader&lt;/code&gt;自动平衡，默认值为&lt;code&gt;true&lt;/code&gt;。后台会有线程进行定期检查leader的分布情况&lt;/p&gt;

&lt;p&gt;kafka中有一个被称为优先副本（preferred replicas）的概念(通常分区会有主分区和副本分区的概念，主分区先写入，然后push到其他副本分区)。&lt;/p&gt;

&lt;p&gt;如果一个分区有3个副本，且这3个副本的优先级别分别为0,1,2，根据优先副本的概念，0会作为leader 。&lt;/p&gt;

&lt;p&gt;当0节点的broker挂掉时，会启动1这个节点broker当做leader。&lt;/p&gt;

&lt;p&gt;当0节点的broker再次启动后，会自动恢复为此partition的leader。不会导致负载不均衡和资源浪费，这就是leader的均衡机制(前提是第一次partition在分配的时候，它本身就是一个相对平均的分配)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;auto.leader.rebalance.enable=true
# 对应影响的其他两个参数
# leader.imbalance.per.broker.percentage : 每个broker允许leader不平衡比例(如果每个broker上超过了这个值，controller将会&amp;gt;执行分区再平衡)，默认值10.
# leader.imbalance.check.interval.seconds: 主分区再平衡的频率，默认值为300s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;num.partitions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;自动创建topic的默认分区数，默认为1，通常生产集群不建议打开topic自动创建，一方面是不便于管理和追溯，另外一方面因为自动创建默认分区时1，且无法动态变更，造成的风险可能会比较大。&lt;/p&gt;

&lt;p&gt;多分区的topic有这更好的数据平衡能力，并且可以帮助消费者进行并行化消费。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 对于有key的数据，避免改变分区的数量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default.replication.factor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;适用于自动创建的主题的默认复制因子，推荐至少设置为2，默认为1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;min.insync.replicas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当使用&lt;code&gt;required.acks=-1(all)&lt;/code&gt;提交到生产请求所需的ISR中的最小副本数，默认为1，建议在数据一致性要求较高的topic中设置至少为2&lt;/p&gt;

&lt;p&gt;指定&lt;code&gt;ISR&lt;/code&gt;的最小数量。当producer设置&lt;code&gt;ack=all(-1)&lt;/code&gt;时，该值指定的副本必须全部写成功，才认为消息写入成功，否则生产者将抛异常(&lt;code&gt;either NotEnoughReplicas or NotEnoughReplicasAfterAppend&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: &lt;code&gt;min.insync.replicas&lt;/code&gt;参数和生产者&lt;code&gt;ack&lt;/code&gt;参数一起使用，可以加强整个消息的持久性&lt;/p&gt;

&lt;p&gt;示例:(3副本的topic,可以设置该值为2,同时生产者ack设置为all，这将确保大多数副本没有收到写操作时，生产者直接异常)&lt;/p&gt;

&lt;p&gt;默认值为:&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unclean.leader.election.enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;是否启用不在ISR集中的副本以选作领导者，即使这样做可能会导致数据丢失。该参数可以提高整体Topic的可用性，但是可能会造成数据的整体不一致性(部分数据的丢失)。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#topicconfigs&#34;&gt;kafka可用性和可靠性保证&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;默认值为:&lt;code&gt;false&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为false，就只从ISR中获取leader保证了数据的可靠性，但是partition就失效了，&lt;code&gt;true&lt;/code&gt;则从replica中获取，则可用性增强，但是数&amp;gt;据可能存在丢失情况&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;  该参数实际上在设置的时候也有一定的争议性，比如，我们知道副本是有&lt;code&gt;ISR&lt;/code&gt;的，即正在同步的副本，如果当前的broker宕&amp;gt;机导致需要选举leader partition，此时如果ISR内除了leader之外还有其他副本(但谁又能保证一定有呢)，那直接从ISR中选举leader&amp;gt;即可，如果没有的话，当&lt;code&gt;auto.leader.rebalance.enable=true&lt;/code&gt;时，就会去其他存活的副本中选举leader，此时可以增强整体的可用性，但是如果存活的副本不在ISR中，即意味着数据可能有一定的丢失了。但是如果该参数为false的话，ISR中没有，就直接异常了，为了保证数据的一致性。&lt;/p&gt;

&lt;p&gt;该参数的存在其实是在可用性和可靠性之间做了一个权衡，为true时保证了可用性AP，为false时保证了一致性CP&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数据一致性保证&lt;/code&gt;: ISR就保存了kafka认为可靠的副本，它们具备这样的条件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;落后leader的消息条数在一定阈值内&lt;/li&gt;
&lt;li&gt;或者落后在一定时间内；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;num.replica.fetchers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数指定了fetch线程的数量(从源broker中复制消息的fetch线程)，默认值: &lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其实可以适当的调整大一些，可以增强副本之前的同步效率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;num.io.threads&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker处理请求的 IO 线程数，需要考虑到磁盘的IO状况。默认值为:&lt;code&gt;8&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;num.network.threads&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定broker用来接收来自网络的请求和发送网络的响应的线程数，默认值为: &lt;code&gt;3&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;background.threads&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;后台任务处理线程数(例如过期消息删除等)。默认值为:&lt;code&gt;10&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;socket相关&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;socket.send.buffer.bytes: (socket发送缓冲区:SO_SNDBUFF) 默认值:&lt;code&gt;102400&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;socket.receive.buffer.bytes: (socket接收缓冲区:SO_RCVBUFF) 默认值:&lt;code&gt;102400&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;socket.request.max.bytes: (请求最大值，message.max.bytes要小于该值较好) 默认值:&lt;code&gt;104857600&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;message.max.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该值表示kafka允许的最大的batch大小(不是单个message的大小)，默认值为&lt;code&gt;1000012&lt;/code&gt;，即1Mb.&lt;/p&gt;

&lt;p&gt;在最新的消息格式版本中，为了提高效率，一般消息的提交都是采用batch的方式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在以前的消息格式版本中，未压缩的记录不会分组成批，在这种情况下，此限制仅适用于单个记录。&lt;/p&gt;

&lt;p&gt;在每个topic级别可以使用&lt;code&gt;max.message.bytes&lt;/code&gt;设置&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;log相关(具体到topic级别)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;log.segment.bytes: 单个日志段(segment)的大小，默认为&lt;code&gt;1073741824&lt;/code&gt;,即1GB&lt;/li&gt;
&lt;li&gt;log.segment.delete.delay.ms: 日志段从文件系统中删除前等待的时间，默认为&lt;code&gt;60000&lt;/code&gt;，即1min&lt;/li&gt;
&lt;li&gt;log.cleanup.policy: 保留窗口之外的日志清理策略可同时指定多个策略如: [&lt;code&gt;delete&lt;/code&gt;,compact]&lt;/li&gt;
&lt;li&gt;log.cleaner.enable: 启用日志清除器进程，和&lt;code&gt;cleanup.policy = compact&lt;/code&gt;参数结合使用，默认为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.cleaner.threads: 日志清理的后台线程数量，默认为&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.cleaner.delete.retention.ms: 删除的日志保留的时间，默认为&lt;code&gt;86400000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.retention.bytes: 删除日志前，日志最大的大小，超过该值即删除，默认&lt;code&gt;-1&lt;/code&gt;，作用在每个partition，会影响整个topic的容量&lt;/li&gt;
&lt;li&gt;log.retention.minutes(hours|ms): 日志保留时间，如果没指定，默认使用hours参数&lt;/li&gt;
&lt;li&gt;log.retention.check.interval.ms: 日志清理器检查日志是否符合删除条件的频率，默认为&lt;code&gt;300000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.flush.interval.messages: 将消息刷新到磁盘之前在日志分区上累积的消息数，默认为&lt;code&gt;9223372036854775807&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.flush.interval.ms: 主题中的消息在刷新到磁盘之前保存在内存中的最大时间，默认为&lt;code&gt;null&lt;/code&gt;(log.flush.scheduler.interval.ms参数的值)&lt;/li&gt;
&lt;li&gt;log.flush.scheduler.interval.ms: 日志刷新器检查是否需要将日志刷新到磁盘的频率，默认&lt;code&gt;9223372036854775807&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.flush.offset.checkpoint.interval.ms: 更新最后一次刷新的持久记录(被作为恢复点)的频率，默认为&lt;code&gt;60000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.flush.start.offset.checkpoint.interval.ms: 更新日志起始偏移量的持久记录的频率，默认&lt;code&gt;60000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;log.roll.hours: 新日志段(segment)被创建前的最大时间，默认&lt;code&gt;168&lt;/code&gt;，如果没设置优先使用&lt;code&gt;log.roll.ms&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;offsets相关&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;offsets.commit.required.acks: offset提交之前是否需要ack确认,默认值:&lt;code&gt;-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.commit.timeout.ms: 当偏移量注意&lt;code&gt;_offset&lt;/code&gt;的所有副本接收到提交或超时达到该时间时，offset提交将延迟. 默认值:&lt;code&gt;5000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.load.buffer.size: 偏移量加载到缓存中时从偏移量段读取的批处理大小. 默认值:&lt;code&gt;5242880&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.retention.check.interval.ms: 历史offset检查的频率，默认值:&lt;code&gt;600000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.retention.minutes: 在消费者组的消费者全部异常之后，offset保留的时间，默认值:&lt;code&gt;10080&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.topic.compression.codec: 偏移量主题的压缩解码器，默认:&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;offsets.topic.num.partitions: offset提交主题的分区数量，默认:&lt;code&gt;50&lt;/code&gt;(&lt;code&gt;注意:&lt;/code&gt;集群部署后不要改变)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;offsets.topic.replication.factor&lt;/code&gt;: offset提交主题的副本数，默认:&lt;code&gt;3&lt;/code&gt; (在集群大小满足此复制因子要求之前，内部主题创建将&amp;gt;失败,该主题非常重要，需要要求强一致性)&lt;/li&gt;
&lt;li&gt;offsets.topic.segment.bytes: offset提交主题的段大小，设置相对较小，以便更快地实现日志压缩和缓存负载，默认值:&lt;code&gt;104857600&lt;/code&gt;，即1Mb&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;queue相关&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;queued.max.requests: 在网络阻塞线程前，数据平面允许的排队请求数，默认值:&lt;code&gt;500&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;replica相关&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;replica.fetch.min.bytes:每个fetch响应所需的最小字节数，默认值:&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replica.fetch.wait.max.ms: 由follow副本发起的每个fetch请求的最大等待时间，该值应小于&lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;，以避免
为低吞吐量的主题频繁地收缩ISR，默认值:&lt;code&gt;500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replica.lag.time.max.ms: follow副本在该时间内没有和leader副本同步，或没有发送任何同步请求，将会被leader副本从ISR中删&amp;gt;除. 默认值:&lt;code&gt;10000&lt;/code&gt;，即10s&lt;/li&gt;
&lt;li&gt;replica.socket.receive.buffer.bytes: 副本接收请求的网络缓冲区，默认值:&lt;code&gt;65535&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replica.socket.timeout.ms: 网络请求的超时时间，默认值:&lt;code&gt;30000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replica.fetch.backoff.ms: 发生获取分区错误时要休眠的时间，参数不是很重要，默认值:&lt;code&gt;1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;replica.fetch.max.bytes: 尝试为每个分区获取的消息字节数，参数不是很重要，默认值:&lt;code&gt;1048576&lt;/code&gt;,即1M&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;broker.rack&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker所在的机架，用来感知机架的变化，通常多个分区不会放在同一个机架上&lt;/p&gt;

&lt;p&gt;示例: &lt;code&gt;RACK1&lt;/code&gt;, &lt;code&gt;us-east-1d&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;controller控制器相关&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;controlled.shutdown.enable&lt;/code&gt;: 启用控制器关闭，默认:&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;controlled.shutdown.max.retries: 控制器会因为各种原因而宕机，该值表示控制器的重试次数，默认:&lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;controlled.shutdown.retry.backoff.ms: 在每次重试之前，系统从前一次故障(控制器fail over或副本延迟)的状态中恢复过来的时
间，默认:&lt;code&gt;5000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;controller.socket.timeout.ms&lt;/code&gt;: 控制器到broker角色转换的socket超时时间，默认:&lt;code&gt;30000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;group相关(消费组)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;group.max.size: 消费组中最大消费者数量&lt;/li&gt;
&lt;li&gt;group.initial.rebalance.delay.ms:注册消费者允许的最小会话超时，默认:&lt;code&gt;6000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 很多参数是有不同级别的生效范围的，比如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read-only&lt;/code&gt;: 仅在broker重启后才能生效&lt;/li&gt;
&lt;li&gt;&lt;code&gt;per-broker&lt;/code&gt;: 可以为每个broker动态更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cluster-wide&lt;/code&gt;: 可作为集群范围内的值动态更新，也可以在每个broker上更新进行测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#brokerconfigs&#34;&gt;broker配置作用范围&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例配置&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# ZooKeeper地址
zookeeper.connect=[list of ZooKeeper servers]

# kafka log相关配置
num.partitions=8
default.replication.factor=3
log.dirs=[List of directories. Kafka should have its own dedicated disk(s) or SSD(s).]

# 其他配置核心配置
broker.id=[An integer. Start with 0 and increment by 1 for each new broker.]
listeners=[list of listeners]
auto.create.topics.enable=false
min.insync.replicas=2
queued.max.requests=[number of concurrent requests]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在kafka集群中，当broker集群参数确定后，还有一些针对topic的参数是可以进行动态调整的，以提高kafka服务的灵活性。&lt;/p&gt;

&lt;h4 id=&#34;4-3-topic级别的动态参数调整&#34;&gt;4.3 Topic级别的动态参数调整&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#topicconfigs&#34;&gt;Topic级别的配置&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: 如下topic的参数可以在使用过程中进行动态调整，使用&lt;code&gt;kafka-topic.sh&lt;/code&gt;工具中的&lt;code&gt;alter&lt;/code&gt;参数来直接修改topic相关的参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cleanup.policy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个字符串是“删除”或“压缩”或两者兼而有之. 默认值: &lt;code&gt;[compact, delete]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;compression.type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;日志压缩类型，默认值为&lt;code&gt;producer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;delete.retention.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于日志压缩主题的删除保留时间。默认值:&lt;code&gt;86400000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.message.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定每个topic可发送的最大消息(batch size)字节数.(区别于全局的&lt;code&gt;message.max.bytes&lt;/code&gt;参数)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;num.partitions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定创建topic的默认分区数量，该值默认为1，建议根据具体的情况进行设定，越多的分区对于海量数据来说可以提高吞吐，但是对于&amp;gt;少量数据来说，也可能增加网络消耗&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;分区数一旦指定，只能增加，不能减少&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;default.replication.factor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定kafka副本数，默认每个主题分区均有一个副本，当该副本所在主机异常，可能造成数据的丢失，建议在适当场景将副本至少设置成
2个，以尽快保证数据的一致性。默认值:&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;自动创建主题的副本因子&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;retention.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;kafka的log保留时间，也可以使用&lt;code&gt;log.retention.hours&lt;/code&gt;参数来配置保留时间，默认168小时，即一周。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;retention.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定log保留的大小，作用在每一个partition上，加入一个topic有3个partition，设置了&lt;code&gt;log.retention.bytes&lt;/code&gt;为1GB，则表示整个topic仅可以存储3GB的数据，超过该容量的数据会被进行自动删除。&lt;/p&gt;

&lt;p&gt;此时，临时增加该topic的容量的方法就是调整该参数，或调整topic的partition个数。&lt;/p&gt;

&lt;p&gt;-1表示不限制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;segment.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定每个日志段的大小，通常在消息到达broker时，会被追加到分区的当前日志段上(segment)，当日志段大小超过该参数指定的值(默认1GB)，当前日志段就会被关闭，一个新的日志段被打开。&lt;/p&gt;

&lt;p&gt;如果一个日志片段被关闭，就开始等待过期，该值不建议设置太小。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;segment.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面会指定日志段的分割，该参数会指定历史的日志段的过期时间。该参数会和&lt;code&gt;log.retention.bytes&lt;/code&gt;一起校验，谁先满足就生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message.max.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该值用来限制单个消息的大小，默认值为&lt;code&gt;1000 000&lt;/code&gt;即&lt;code&gt;1MB&lt;/code&gt;，如果超过该大小，broker不会接受，而且会抛出相关异常&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;该参数指的是消息被压缩后的大小，通常生产中的消息生产会使用gzip或snappy来进行压缩&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;消息的大小对于性能有比较显著的影响，越大负责处理网络连接和请求的线程就需要花越多的时间来处理这些请求，还会增加磁
盘写入块的大小，从而影响 IO 吞吐量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;file.delete.delay.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在从文件系统中删除一个文件前的等待时间&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flush.messages&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数允许我们指定一个间隔来强制同步数据到本地磁盘，比如设置为1，表示每条消息后都会执行同步磁盘，如果设置为5表示，每5个消息同步一次。&lt;/p&gt;

&lt;p&gt;一般情况下，管法定不建议修改该参数，可以使用副本机制来保证持久性和开启操作系统的后台flush功能，会更加有效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;flush.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同上，但是指定的是时间间隔。比如设置1000，表示1000ms后执行一次同步操作.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;follower.replication.throttled.replicas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对日志复制的副本列表应该被在follow侧进行限流。&lt;/p&gt;

&lt;p&gt;副本列表应该为&lt;code&gt;[PartitionId]:[BrokerId],[PartitionId]:[BrokerId]&lt;/code&gt;格式，或者使用通配符&lt;code&gt;*&lt;/code&gt;来表示给topic的所有副本进行限流。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;leader.replication.throttled.replicas&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同上，在leader侧进行限流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.interval.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用来控制多久kafka会增加一个index实体数据到它的offset的index上。默认设置确保我们大约每4096字节索引一条消息。索引越多，读取越接近日志中的确切位置，但索引越大。通常不需要修改该参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.message.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;被kafka允许的最大记录的batch size。&lt;/p&gt;

&lt;p&gt;如果增加了该值，并且有消费者版本老于&lt;code&gt;0.10.2&lt;/code&gt;，消费者的&lt;code&gt;fetch size&lt;/code&gt;也必须增加，这样就能获取到该批次大小的数据。&lt;/p&gt;

&lt;p&gt;在高版本的消息格式(message format)中，为了效率，记录总是会被分组成batch；而在之前的消息格式版本中，未被压缩的消息不会被分组成batch，在这种情况下，该参数仅在单条记录上生效。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message.downconversion.enable&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此配置用于控制是否启用消息格式的向下兼容以满足消费者请求。&lt;/p&gt;

&lt;p&gt;当设置成&lt;code&gt;false&lt;/code&gt;，对于希望使用较旧消息格式的消费者来说，broker将不会执行向下转换。来自旧客户端的消费者请求，broker将会返回&lt;code&gt;UNSUPPORTED_VERSION&lt;/code&gt;错误码。&lt;/p&gt;

&lt;p&gt;此配置不适用于可能需要复制到follower的消息格式转换。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message.format.version&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定消息格式版本，broker将使用&lt;code&gt;append&lt;/code&gt;方式追加message到log里。该值必须是一个可用的ApiVersion，比如&lt;code&gt;0.8.2, 0.9.0.0, 0.10.0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过设置特定的消息格式版本，用户可以验证已存在磁盘上的消息是否小于或者等于指定的版本。&lt;/p&gt;

&lt;p&gt;错误地设置此值将导致使用较旧版本的使用者中断，因为他们将收到他们不理解的格式的消息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message.timestamp.difference.max.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker接收到消息的时间戳和在消息体内部的时间戳的最大时间差距。如果&lt;code&gt;message.timestamp.type=CreateTime&lt;/code&gt;，当时间戳的差值大于该值，一个message将被拒绝。如果&lt;code&gt;message.timestamp.type=LogAppendTime&lt;/code&gt;，该参数将被忽略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;message.timestamp.type&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定message中时间戳的类型。&lt;code&gt;CreateTime&lt;/code&gt;或&lt;code&gt;LogAppendTime&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;min.cleanable.dirty.ratio&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用于控制，日志压缩器(log compactor)将尝试清除日志的频率。默认情况下，我们将避免清除已压缩超过50％的日志的日志。这个比率限制了最大空间浪费(日志中的重复,50%或50%以上的日志重复)。&lt;/p&gt;

&lt;p&gt;比率越高，意味着越少，更有效的清理，但是也意味着更多的日志空间浪费。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;min.compaction.lag.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一条消息保持未压缩的最小时间。仅适用于正在压缩的日志。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;4-3-producer核心参数&#34;&gt;4.3 Producer核心参数&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;bootstrap.servers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定broker地址&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;key.serializer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;broker 需要接收到序列化之后的&lt;code&gt;k/v&lt;/code&gt;值，所以生产者需要将序列化后的值发送过来。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt;该类表示把键对象序列化为字节数组&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ByteArraySerializer: 默认的序列化方式&lt;/li&gt;
&lt;li&gt;StringSerializer:&lt;/li&gt;
&lt;li&gt;IntegerSerializer:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;value.serializer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定序列化后的value，需要实现&lt;code&gt;org.apache.kafka.common.serialization.Serializer&lt;/code&gt;接口&lt;/p&gt;

&lt;p&gt;&lt;code&gt;org.apache.kafka.common.serialization.StringSerializer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;compression.type&lt;/strong&gt;
指定消息压缩类型:gzip,snappy等，&lt;/p&gt;

&lt;p&gt;broker端也有该参数，默认值为:&lt;code&gt;producer&lt;/code&gt;，表示遵循生产者的压缩方式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;生产者使用何种压缩方式，消费者将必须使用该方式进行解压缩&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;acks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用来声明要有多少个分区副本接收消息后，生产者才认为消息写入成功，也就是数据一致性衡量，该参数对消息的丢失的影响较&amp;gt;大. 默认值为:&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;acks=0&lt;/code&gt;: 表示生产者不知道消息是否被broker成功接收被处理，反正自己发出去了就认为是成功了，该种清理增加了吞吐，但是也&amp;gt;增加的数据丢失的风险，因为程序的稳定性，网络的稳定性都可能会影响到消息的生产&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acks=1&lt;/code&gt;: 只要集群中leader接收到消息并成功处理，就返回给生产者写入成功的消息。该种情况，如果发送过程中网络出现问题或&amp;gt;者kafka集群异常导致leader没工作而导致消息写入失败，生产者会受到写入失败相关的异常，此时生产者可进行重试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acks=all/-1&lt;/code&gt;: 表示所有参与复制的节点都收到消息时，生产者才会接收到来自服务器端写入成功的消息，该种情况下，整体的消息
确认延迟会更高一些，但是数据的一致性也更强一些&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 消息的发送其实也分&lt;code&gt;sync&lt;/code&gt;和&lt;code&gt;async&lt;/code&gt;，即同步和异步，kafka为了保证消息高效传输会决定是同步发送还是异步发送。如果让&amp;gt;客户端等待服务器的响应(通过调用get()方法)也会增加延迟，如果采用客户端回调方式，延迟问题可能会有好转。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;buffer.memory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用来设置生产者内存缓冲区的大小，生产者会用它来缓冲要发送到服务器的消息，以此来提供消息传递的效率。默认值:&lt;code&gt;33554432&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，此时&lt;code&gt;send()&lt;/code&gt;方法就会阻塞或者直接异常，取
决于&lt;code&gt;block.on.buffer.null&lt;/code&gt;参数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;retries&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生产者从服务器收到的错误有可能是临时性的错误，比如暂时找不到&lt;code&gt;leader&lt;/code&gt;或者当前partition正在迁移无法找到相关的partition，&amp;gt;这种情况下，该参数可以决定生产者的行为，如果重试次数超过之后，生产者就会放弃重试，并返回错误。&lt;/p&gt;

&lt;p&gt;默认情况下，生产者在每次重试之间等待100ms，这个等待参数可以通过&lt;code&gt;retry.backoff.ms&lt;/code&gt;来修改&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;batch.size&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定每次提交的batch大小，默认值:&lt;code&gt;16384&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当有多个消息需要被发送&lt;code&gt;同一个分区&lt;/code&gt;(如何决定是发送到同一个分区?)时，生产者会把他们发送到同一个批次里.&lt;/p&gt;

&lt;p&gt;该参数用来指定一个批次提交的大小，当达到该batch的大小，所有的消息会被统一发送至broker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;client.id&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用来指定客户端的id，不过可以不用指定，注册后为每个客户端生成64为的id&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.in.flight.requests.per.connection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此参数指定了生产者在收到服务器响应之前可以发送多少消息，它的值越高，就会占用越多的内存，不过也会提高吞吐量&lt;/p&gt;

&lt;p&gt;把它设为1 可以保证消息是&lt;code&gt;按照发送的顺序&lt;/code&gt;写入服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;timeout相关参数&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;request.timeout.ms&lt;/code&gt;: 生产者在发送数据时等待服务器返回的响应时间，默认值:&lt;code&gt;30000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;metadata.fetch.timeout.ms&lt;/code&gt;: 指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeout.ms&lt;/code&gt;: 指定了 broker 等待同步副本返回消息确认的时间，与 asks 的配置相匹配&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;max.block.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此参数指定了在调用 send() 方法或使用 partitionFor() 方法获取元数据时生产者的阻塞时间.&lt;/p&gt;

&lt;p&gt;当生产者的发送缓冲区已捕，或者没有可用的元数据时，这些方法就会阻塞，阻塞时间超过该参数值时，生产者抛出异常&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.request.size&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该参数用于控制生产者发送的&lt;code&gt;请求大小&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息的总大小&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;receive.buffer.bytes和send.buffer.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了保证可靠的消息传输，这两个参数分别指定了 TCP Socket &lt;code&gt;接收和发送数据包的缓冲区&lt;/code&gt;的大小，默认为-1，表示使用操作系统的&amp;gt;默认值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 如果生产者或消费者与broker所处的数据中心不同，该值可以适当调大&lt;/p&gt;

&lt;h4 id=&#34;4-4-consumer核心参数&#34;&gt;4.4 Consumer核心参数&lt;/h4&gt;

&lt;p&gt;在消费者组中的消费者重平衡期间，消费者无法读取消息，造成整个消费者组在重平衡的期间都不可用&lt;/p&gt;

&lt;p&gt;消费者通过向组织协调者（Kafka Broker）发送心跳来维护自己是消费者组的一员并确认其拥有的分区。&lt;/p&gt;

&lt;p&gt;对于不同步的消费群体来说，其组织协调者可以是不同的。&lt;/p&gt;

&lt;p&gt;只要消费者定期发送心跳，就会认为消费者是存活的并处理其分区中的消息。当消费者检索记录或者提交它所消费的记录时就会发送心&amp;gt;跳。&lt;/p&gt;

&lt;p&gt;如果一段时间，消费者不发送心跳了，会话（Session）就会过期，组织协调者就会认为这个 Consumer 已经死亡，就会触发一次重平衡
。&lt;/p&gt;

&lt;p&gt;如果消费者宕机并且停止发送消息，组织协调者会等待几秒钟，确认它死亡了才会触发重平衡.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在这段时间里，组里的消费者将不处理消息(STW)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;_consumer_offset&lt;/code&gt;主题就主要是用来记录相关消费者的偏移量以及消费者分区分配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fetch.min.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定了消费者从服务器获取记录的最小字节数，默认:&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;broker 在收到消费者的数据请求时，如果可用的数据量小于 fetch.min.bytes 指定的大小，那么它会等到有足够的可用数据时才把它&amp;gt;返回给消费者。&lt;/p&gt;

&lt;p&gt;这样可以降低消费者和 broker 的工作负载，因为它们在主题使用频率不是很高的时候就不用来回处理消息。&lt;/p&gt;

&lt;p&gt;如果没有很多可用数据，但消费者的 CPU 使用率很高，那么就需要把该属性的值设得比默认值大。&lt;/p&gt;

&lt;p&gt;如果消费者的数量比较多，把该属性的值调大可以降低 broker 的工作负载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;fetch.max.wait.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面参数用来控制每次fetch时的最小数据量，但也不能一直等待数据的容量满足要求，因此还有另外一个参数，即&lt;code&gt;fetch.max.wait.ms&lt;/code&gt;，指定多长时间还没满足数据容量就进行fetch数据，默认是&lt;code&gt;500ms&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.partition.fetch.bytes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定了服务器从每个分区里返回给消费者的&lt;code&gt;最大字节数&lt;/code&gt;，默认值为&lt;code&gt;1MB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;即&lt;code&gt;KafkaConsumer.poll()&lt;/code&gt;方法从每个分区返回的记录最多不超过该值指定的大小。&lt;/p&gt;

&lt;p&gt;加入一个20分区的主题，拥有5个消费者，那么每个消费者必须至少&lt;code&gt;4MB&lt;/code&gt;的内存来接收消息(每个消费者消费4个分区，每个分区返回消&amp;gt;费者的最大字节数1MB)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 该参数的设置要适当的设置大一些，防止单个消费者异常后，整体内存受限。&lt;/p&gt;

&lt;p&gt;至少，该参数的值要大于&lt;code&gt;max.message.size&lt;/code&gt;(broker接收消息的最大字节数)，否则消费者无法读取这些消息，导致消费者一直重试并&amp;gt;挂起。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;session.timeout.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定了消费者在被认为死亡之前可以与服务器断开连接的时间，默认是 3s，在这个时间内没有发送心跳就会直接认为消费者死亡，此时
协调器就会进行触发consumer rebalance.&lt;/p&gt;

&lt;p&gt;此参数与&lt;code&gt;heartbeat.interval.ms&lt;/code&gt;(poll() 方法向群组协调器发送心跳的频率)强相关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;auto.offset.reset&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下的该如何处理，默认值为&lt;code&gt;latest&lt;/code&gt;，意思是在偏移量无效的情况下&amp;gt;，默认从最新的记录下开始读取数据。可选值为&lt;code&gt;earliest&lt;/code&gt;，表示从最开始位置进行读取.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;enable.auto.commit&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;指定了消费者是否自动提交偏移量，默认值是 true，对应&lt;code&gt;auto.commit.interval.ms&lt;/code&gt;参数来保证每次提交偏移量的频率&lt;/p&gt;

&lt;p&gt;为了避免数据重复和丢失，消费者可以设置为false，由自己决定自己的消费位置(客户端保证数据消费的一致性)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;partition.assignment.strategy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PartitionAssignor&lt;/code&gt;(分区分配器)会根据给定的消费者和主题，决定哪些分区应该被分配到哪个消费者，默认有两个策略:&lt;code&gt;Range&lt;/code&gt;和&lt;code&gt;RoundRobin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;max.poll.records&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用于控制&lt;code&gt;单次调用call()&lt;/code&gt; 方法能够返回的记录数量，可以帮你控制在轮询中需要处理的数据量.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;heartbeat.interval.ms&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在消费组中，消费者心跳到消费者协调器的频率，默认值:&lt;code&gt;3000ms&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;三-集群管理&#34;&gt;三、集群管理&lt;/h2&gt;

&lt;p&gt;任何一款优秀的开源软件，都会提供比较丰富的集群管理工具来帮助使用者(管理员和实际使用者)来对集群进行操作，记下来从三个角度来大概讲解集群管理相关的操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;官方提供的操作脚本&lt;/li&gt;
&lt;li&gt;kafka-manager&lt;/li&gt;
&lt;li&gt;kafkacat&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-官方工具&#34;&gt;1. 官方工具&lt;/h3&gt;

&lt;p&gt;在kafka的发行包中，默认包含了如下管理工具脚本:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ ls
connect-distributed.sh        kafka-delete-records.sh              kafka-server-stop.sh
connect-mirror-maker.sh       kafka-dump-log.sh                    kafka-streams-application-reset.sh
connect-standalone.sh         kafka-leader-election.sh             kafka-topics.sh
kafka-acls.sh                 kafka-log-dirs.sh                    kafka-verifiable-consumer.sh
kafka-broker-api-versions.sh  kafka-mirror-maker.sh                kafka-verifiable-producer.sh
kafka-configs.sh              kafka-preferred-replica-election.sh  trogdor.sh
kafka-console-consumer.sh     kafka-producer-perf-test.sh          windows
kafka-console-producer.sh     kafka-reassign-partitions.sh         zookeeper-security-migration.sh
kafka-consumer-groups.sh      kafka-replica-verification.sh        zookeeper-server-start.sh
kafka-consumer-perf-test.sh   kafka-run-class.sh                   zookeeper-server-stop.sh
kafka-delegation-tokens.sh    kafka-server-start.sh                zookeeper-shell.sh&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里主要介绍几个常用的工具脚本:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运维管理类&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kafka-topics.sh&lt;/code&gt;: 用来创建，删除，查看，改变一个topic参数的工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-reassign-partitions.sh&lt;/code&gt;: 用来对partition进行重新分配(管理员会较多使用)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-log-dirs.sh&lt;/code&gt;: 用来查看指定broker下日志目录的使用空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-leader-election.sh&lt;/code&gt;: 用于一组Topic分区的leader重新分配，可以支持优先副本和非同步副本(不在ISR中)，老版本中的kafka-preferred-replica-election.sh脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-replica-verification.sh&lt;/code&gt;: 该工具可以用来检查topic的一组副本的数据是否一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-broker-api-versions.sh&lt;/code&gt;: 用来查看指定broker当前支持的各个接口的版本(kafka高版本已经保证了向下兼容)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-configs.sh&lt;/code&gt;: 用来操作和查看topic, client, user or broker的实体配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;kafka操作类&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kafka-console-consumer.sh&lt;/code&gt;: 通过终端来启动消费者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-console-producer.sh&lt;/code&gt;: 通过终端来启动生产者&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-consumer-groups.sh&lt;/code&gt;: 用来查看，删除或者重置消费者组offset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-consumer-perf-test.sh&lt;/code&gt;: 用来进行消费者压力测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-producer-perf-test.sh&lt;/code&gt;: 用来进行生产者压力测试&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-delete-records.sh&lt;/code&gt;: 删除指定分区的记录，直到指定的offset&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-mirror-maker.sh&lt;/code&gt;: 用于多集群之间同步topic数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-server-start.sh&lt;/code&gt;: broker启动脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-server-stop.sh&lt;/code&gt;: broker关闭脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kafka-streams-application-reset.sh&lt;/code&gt;: 流式应用工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zookeeper-shell.sh&lt;/code&gt;: kafka工具中也默认提供了zookeeper管理工具(不太好用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-1-kafka-configs-sh&#34;&gt;1.1 kafka-configs.sh&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;topic创建&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--create&lt;/code&gt;: 创建topic&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--topic&lt;/code&gt;: 指定topic名称&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--partitions&lt;/code&gt;: 指定分区数量&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--replication-factor&lt;/code&gt;: 指定副本数量(仅在创建时可用)&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--config&lt;/code&gt;: 指定topic级别的参数(动态参数，可修改)&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--replica-assignment&lt;/code&gt;: 手动指定partition到broker的分配&lt;part1_replica1:part1_replica2,part2_replica1:part2_replica2&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 创建topic
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --create --topic bgbiao.top
Created topic bgbiao.top.

# 查看默认创建topic的参数详情(由broker配置决定)
# 默认3个分区，1个副本
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 1	Leader: 2	Replicas: 2	Isr: 2
	Topic: bgbiao.top	Partition: 2	Leader: 3	Replicas: 3	Isr: 3

# 指定参数创建topic
# 指定分区为5，副本为3，topic数据保留2分钟
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --create --topic bgbiao.top-1 --partitions 5 --replication-factor 3 --config retention.ms=120000

# 分区，副本和指定参数都改变了
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top-1
Topic: bgbiao.top-1	PartitionCount: 5	ReplicationFactor: 3	Configs: min.insync.replicas=1,segment.bytes=1073741824,retention.ms=120000
	Topic: bgbiao.top-1	Partition: 0	Leader: 2	Replicas: 2,3,1	Isr: 2,3,1
	Topic: bgbiao.top-1	Partition: 1	Leader: 3	Replicas: 3,1,2	Isr: 3,1,2
	Topic: bgbiao.top-1	Partition: 2	Leader: 1	Replicas: 1,2,3	Isr: 1,2,3
	Topic: bgbiao.top-1	Partition: 3	Leader: 2	Replicas: 2,1,3	Isr: 2,1,3
	Topic: bgbiao.top-1	Partition: 4	Leader: 3	Replicas: 3,2,1	Isr: 3,2,1&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;topic更改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; topic的分区(partitions)可以根据需要进行调整(只能调整大，不能调整小)，而且在调整分区的过程中，对于一个有&lt;code&gt;key&lt;/code&gt;的主题来说，一条消息的分区逻辑和顺序性可能会受到影响。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 副本数一旦topic创建之后，就不能再修改了，除非进行重分配(副本数不能超过broker数量哦)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--alter&lt;/code&gt;: 修改分区数量，replica分配，或者topic的动态配置项(结合&amp;ndash;topic参数)&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--partitions&lt;/code&gt;: 修改指定Topic的分区数量&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--replica-assignment&lt;/code&gt;: 手动指定part到broker的分配&lt;a href=&#34;p1-r1:p1-r2,p2-r1:p2-r2&#34;&gt;p1-r1:p1-r2,p2-r1:p2-r2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--config&lt;/code&gt;: 修改topic的指定参数(动态参数调整:key=value)&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--delete-config&lt;/code&gt;: 删除topipc的指定参数()&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 通常情况下&lt;code&gt;--replica-assignment&lt;/code&gt;参数需要和&lt;code&gt;--partitions&lt;/code&gt;一同使用才可以指定分区下的副本到broker节点上的分配，相当于手动扩容迁移&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 上面我们刚开始创建的bgbiao.top的topic是1个分区1个副本，这里采用alter参数进行修改基本配置
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --alter  --topic bgbiao.top --replica-assignment 1,2,3,1,2 --partitions 5

# 因为bgbiao.top 这个topic再创建时只有一个replication，因此--replica-assignment参数只能指定副本分配在那个broker上，无法指定多个副本的关系
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 5	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 1	Leader: 2	Replicas: 2	Isr: 2
	Topic: bgbiao.top	Partition: 2	Leader: 3	Replicas: 3	Isr: 3
	Topic: bgbiao.top	Partition: 3	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 4	Leader: 2	Replicas: 2	Isr: 2

 &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;topic相关信息查看&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--list&lt;/code&gt;: 列出topic&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--describe&lt;/code&gt;: 查看topic详情信息&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--topic&lt;/code&gt;: 指定topic查看详情信息&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--exclude-internal&lt;/code&gt;: 排除内部topic(consumer_offset_topic)&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--unavailable-partitions&lt;/code&gt;: 仅显示leader不可用的分区(在集群异常时快速排查受影响的分区)&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--under-min-isr-partitions&lt;/code&gt;: 仅显示isr小于配置的min-isr-partitions的分区&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--under-replicated-partitions&lt;/code&gt;: 仅显示不同步的分区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在低版本的kafka中使用&amp;ndash;zookeeper来链接集群，高版本中基本都通过&amp;ndash;bootstrap-server指定broker来连接集群&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 列出集群topic
# --list参数列出可用的topic
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --list
__consumer_offsets
....
....

# 也可以使用--topic指定topic
# 如果指定topic不存在，将返回空
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --list --topic __consumer_offsets
__consumer_offsets

# 列出topic详情信息
# --describe参数(同时可以使用--topic指定topic查看)
# --exclude-internal参数可以排除内部的topic(__consumer_offsets)
# --unavailable-partitions参数可以列出leader不可用的topic，在集群故障时快速查看受影响的topic
# 
# 可以查看某个topic的分区和副本分布，以及topic级别的相关配置
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic __consumer_offsets
Topic: __consumer_offsets	PartitionCount: 50	ReplicationFactor: 1	Configs: compression.type=producer,min.insync.replicas=1,cleanup.policy=compact,segment.bytes=104857600
	Topic: __consumer_offsets	Partition: 0	Leader: 3	Replicas: 3	Isr: 3
	Topic: __consumer_offsets	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
....
....

# 查看集群leader不可用的分区
# 可以发现leader都为-1，是因为副本和isr的id是4，而broker4其实已经光荣阵亡了
$ /opt/app/kafka_2.11-1.0.1/bin/kafka-topics.sh --zookeeper 172.16.217.38:2181/log-kafka --describe --unavailable-partitions
...
	Topic: realtime_kafka.post_alg_real	Partition: 2	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 11	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 20	Leader: -1	Replicas: 4	Isr: 4
	Topic: realtime_kafka.post_alg_real	Partition: 29	Leader: -1	Replicas: 4	Isr: 4
	Topic: rm-bp1d3u2p9v3l4da7c632	Partition: 1	Leader: -1	Replicas: 4	Isr: 4
	Topic: rm-bp1udb05091x11q5x	Partition: 1	Leader: -1	Replicas: 4	Isr: 4

# 查看副本不同步的分区详情
# 可以发现副本中有不同步的情况，是因为有副本所在的节点已经挂了，通常有一部分是因为资源或者网络原因未同步，还有就是如上述broker阵亡的情况
# 如果说--unavailable-partitions可以直接查看到受影响的topic，那么--under-replicated-partitions就可以查看可用性受影响的topic，因为当副本为2时，此时broker4阵亡的前提下，topic下的分区是无法保证高可用的
$ /opt/app/kafka_2.11-1.0.1/bin/kafka-topics.sh --zookeeper 172.16.217.38:2181/log-kafka --describe --under-replicated-partitions
...
...
	Topic: androidregister	Partition: 1	Leader: 2	Replicas: 4,2	Isr: 2
	Topic: eventjsonlog	Partition: 11	Leader: 2	Replicas: 4,2	Isr: 2
	Topic: eventjsonlog	Partition: 27	Leader: 2	Replicas: 2,4	Isr: 2
	Topic: eventjsonlog	Partition: 38	Leader: 13	Replicas: 13,4	Isr: 13
	Topic: eventjsonlog	Partition: 44	Leader: 10	Replicas: 4,10	Isr: 10
	Topic: eventjsonlog	Partition: 52	Leader: 12	Replicas: 12,4	Isr: 12
	Topic: eventjsonlog	Partition: 59	Leader: 11	Replicas: 4,11	Isr: 11
	Topic: eventlog	Partition: 8	Leader: 16	Replicas: 16,4	Isr: 16
	Topic: eventlog	Partition: 23	Leader: 3	Replicas: 4,3	Isr: 3
	Topic: eventlog	Partition: 38	Leader: 13	Replicas: 13,4	Isr: 13
	Topic: eventlog	Partition: 44	Leader: 10	Replicas: 4,10	Isr: 10
	Topic: eventlog	Partition: 52	Leader: 12	Replicas: 12,4	Isr: 12
	Topic: eventlog	Partition: 59	Leader: 11	Replicas: 4,11	Isr: 11
	Topic: pusheventlog	Partition: 9	Leader: 1	Replicas: 1,4	Isr: 1
	Topic: pusheventlog	Partition: 12	Leader: 7	Replicas: 4,7	Isr: 7&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删除&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--delete&lt;/code&gt;: 指定topic删除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在删除Topic时会受&lt;code&gt;delete.topic.enable&lt;/code&gt;参数的影响，如果为true，则topic直接删除，如果为false，删除仅是标记删除，即在topic的config中增加一个删除标记&lt;code&gt;MarkedForDeletion:true&lt;/code&gt;，待broker重启后完全删除(也可通过zk中的数据删除)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 如果delete.topic.enable=true，则直接删除掉
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --delete   --topic bgbiao.top&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;topic真正的元数据结构: &lt;code&gt;/brokers/topics/topic-name&lt;/code&gt;,删除这个即删除&lt;/li&gt;
&lt;li&gt;标记删除的topic元数据: &lt;code&gt;/admin/delete_topics/topic-name&lt;/code&gt;,删除这个才算数据清理完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-2-kafka-reassign-partitions-sh&#34;&gt;1.2 kafka-reassign-partitions.sh&lt;/h4&gt;

&lt;p&gt;该脚本用于在副本之间移动topic的分区，也就是对副本进行重新分配，也是SRE在日常操作中会比较常用的脚本，需要注意的是，在做迁移时需要注意到当前集群的整体情况，毕竟在移动副本时，需要设计到新副本的数据同步，也会占用一定资源。&lt;/p&gt;

&lt;p&gt;通常，将服务器添加到Kafka集群很容易，只需为它们分配一个惟一的brokerid，并在新服务器上启动Kafka。然而，这些新服务器不会自动分配任何数据分区，因此，除非将分区移动到它们，否则在创建新主题之前，它们不会做任何工作。因此，向集群中添加机器时，您会希望将一些现有数据迁移到这些机器上。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--broker-list&lt;/code&gt;: 指定分区需要重新分配到的broker节点，如果&lt;code&gt;--topics-to-move-json-file&lt;/code&gt;参数被指定用来生成重分配配置时，必须制定该参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--topics-to-move-json-file&lt;/code&gt;: 生成一个移动指定topic的分区到指定broker(&lt;code&gt;--broker-list&lt;/code&gt;)的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--generate&lt;/code&gt;: 生成候选分区分配的配置，该参数仅会生成候选的分配方案，不会进行执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--reassignment-json-file&lt;/code&gt;: 分区手动分配的配置参数，该参数可由&lt;code&gt;generate&lt;/code&gt;参数生成，通常一般会进行微调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--replica-alter-log-dirs-throttle&lt;/code&gt;: 在相同的broker上日志目录之间的副本移动将被限流为该值bytes/sec，限流应该至少设置为1 KB/s，默认是-1表示不限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--throttle&lt;/code&gt;: broker之间的分区移动可以使用该值进行限流(bytes/sec)，同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--execute&lt;/code&gt;: 通过指定&lt;code&gt;--reassignment-json-file&lt;/code&gt;参数来执行重新分配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--verify&lt;/code&gt;: 如果一个重分配完成了，可以指定&lt;code&gt;--reassignment-json-file&lt;/code&gt;参数来查看重分配的进度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;topics-to-move-json-file文件示例&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{&amp;#34;topics&amp;#34;:
[{&amp;#34;topic&amp;#34;: &amp;#34;foo&amp;#34;},{&amp;#34;topic&amp;#34;: &amp;#34;foo1&amp;#34;}],
&amp;#34;version&amp;#34;:1
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;reassignment-json-file文件示例&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 注意:log_dirs是可选参数，需要指定绝对路径，也可以指定为any，当指定后需要和replicas的长度相等
  {&amp;#34;partitions&amp;#34;:
  	[{&amp;#34;topic&amp;#34;: &amp;#34;foo&amp;#34;,
  	  &amp;#34;partition&amp;#34;: 1,
  	  &amp;#34;replicas&amp;#34;: [1,2,3],
  	  &amp;#34;log_dirs&amp;#34;: [&amp;#34;dir1&amp;#34;,&amp;#34;dir2&amp;#34;,&amp;#34;dir3&amp;#34;]
    }],
  &amp;#34;version&amp;#34;:1
  }&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;分区重分配示例:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 查看当前topic详情
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 1	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 3	Replicas: 3	Isr: 3
	Topic: bgbiao.top	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 2	Leader: 2	Replicas: 2	Isr: 2

# 1.编辑move.json配置
$ cat move.json
{&amp;#34;topics&amp;#34;: [{&amp;#34;topic&amp;#34;: &amp;#34;bgbiao.top&amp;#34;}],
&amp;#34;version&amp;#34;:1
}

# 2.生成迁移配置
# 指定正确的zookeeper地址来获取分区的分布状态以及待迁移的状态
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --topics-to-move-json-file move.json --broker-list &amp;#34;1,2,3&amp;#34; --generate
Current partition replica assignment
{&amp;#34;version&amp;#34;:1,&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[2],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[1],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]}]}

Proposed partition reassignment configuration
{&amp;#34;version&amp;#34;:1,&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[1],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[3],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[2],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]}]}

# 编辑迁移配置
# 当前分区状态为:bgbiao.top-2的副本在broker2,bgbiao.top-1的副本在broker1,bgbiao.top-0的副本在broker3
# 迁移后的分区状态:bgbiao.top-2的副本在broker3,bgbiao.top-1的副本在broker2,bgbiao.top-0的副本在broker1
# 然后将期望的迁移配置保存下来做相关修改即可.
# 我们是想给某个分区增加副本，因此可以修改成如下配置
$ cat assignment.json
{
    &amp;#34;partitions&amp;#34;: [
        {
            &amp;#34;partition&amp;#34;: 0,
            &amp;#34;replicas&amp;#34;: [
                3,1,2
            ],
            &amp;#34;topic&amp;#34;: &amp;#34;bgbiao.top&amp;#34;
        }
    ],
    &amp;#34;version&amp;#34;: 1
}

# 3.根据上述的迁移配置执行迁移
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --reassignment-json-file ./assignment.json --execute
Current partition replica assignment

{&amp;#34;version&amp;#34;:1,&amp;#34;partitions&amp;#34;:[{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:2,&amp;#34;replicas&amp;#34;:[2],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:1,&amp;#34;replicas&amp;#34;:[1],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]},{&amp;#34;topic&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;partition&amp;#34;:0,&amp;#34;replicas&amp;#34;:[3],&amp;#34;log_dirs&amp;#34;:[&amp;#34;any&amp;#34;]}]}

Save this to use as the --reassignment-json-file option during rollback
Successfully started reassignment of partitions.

# 4.查看上述迁移的进度(将--execute参数改为--verify参数)
$ sh /opt/app/kafka/bin/kafka-reassign-partitions.sh --zookeeper 172.29.203.62:2181 --reassignment-json-file ./assignment.json --verify
Status of partition reassignment:
Reassignment of partition bgbiao.top-0 completed successfully

# 再次查看topix详情
# 如期望，partition-1增加了两个副本,该副本的整体可用性提高了3倍
$ sh /opt/app/kafka/bin/kafka-topics.sh --bootstrap-server 172.29.203.62:9092 --describe --topic bgbiao.top
Topic: bgbiao.top	PartitionCount: 3	ReplicationFactor: 3	Configs: min.insync.replicas=1,segment.bytes=1073741824
	Topic: bgbiao.top	Partition: 0	Leader: 3	Replicas: 3,1,2	Isr: 3,1,2
	Topic: bgbiao.top	Partition: 1	Leader: 1	Replicas: 1	Isr: 1
	Topic: bgbiao.top	Partition: 2	Leader: 2	Replicas: 2	Isr: 2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 该工具可以让集群部分节点故障后，及时将新部分的partition进行调整，以恢复partition的高可用性。同时能够让集群在扩展后，快速将已有topic的数据均衡的分布在新节点上，以实现整体负载的均衡。&lt;/p&gt;

&lt;h4 id=&#34;1-3-kafka-log-dirs-sh&#34;&gt;1.3 kafka-log-dirs.sh&lt;/h4&gt;

&lt;p&gt;该脚本参数用于查看kafka各个broker节点以及topic的磁盘使用率情况&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--describe&lt;/code&gt;: 查看topic和broker的磁盘使用情况&lt;/li&gt;
&lt;li&gt;- &lt;code&gt;--broker-list&lt;/code&gt;: 指定查看的broker列表&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;--topic-list&lt;/code&gt;: 指定需要查看的topic列表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 当指定topic后会从全部的broker中进行查找
$ sh /opt/app/kafka/bin/kafka-log-dirs.sh --bootstrap-server 172.29.203.62:9092 --describe --topic-list myapp-yum-log,myapp
Querying brokers for log directories information
Received log directory information from brokers 1,2,3
{&amp;#34;version&amp;#34;:1,&amp;#34;brokers&amp;#34;:[{&amp;#34;broker&amp;#34;:1,&amp;#34;logDirs&amp;#34;:[{&amp;#34;logDir&amp;#34;:&amp;#34;/opt/data/kafka/kafka-logs&amp;#34;,&amp;#34;error&amp;#34;:null,&amp;#34;partitions&amp;#34;:[{&amp;#34;partition&amp;#34;:&amp;#34;myapp-yum-log-2&amp;#34;,&amp;#34;size&amp;#34;:13291235,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false},{&amp;#34;partition&amp;#34;:&amp;#34;myapp-0&amp;#34;,&amp;#34;size&amp;#34;:0,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false}]}]},{&amp;#34;broker&amp;#34;:2,&amp;#34;logDirs&amp;#34;:[{&amp;#34;logDir&amp;#34;:&amp;#34;/opt/data/kafka/kafka-logs&amp;#34;,&amp;#34;error&amp;#34;:null,&amp;#34;partitions&amp;#34;:[{&amp;#34;partition&amp;#34;:&amp;#34;myapp-1&amp;#34;,&amp;#34;size&amp;#34;:0,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false},{&amp;#34;partition&amp;#34;:&amp;#34;myapp-yum-log-0&amp;#34;,&amp;#34;size&amp;#34;:13258726,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false}]}]},{&amp;#34;broker&amp;#34;:3,&amp;#34;logDirs&amp;#34;:[{&amp;#34;logDir&amp;#34;:&amp;#34;/opt/data/kafka/kafka-logs&amp;#34;,&amp;#34;error&amp;#34;:null,&amp;#34;partitions&amp;#34;:[{&amp;#34;partition&amp;#34;:&amp;#34;myapp-2&amp;#34;,&amp;#34;size&amp;#34;:0,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false},{&amp;#34;partition&amp;#34;:&amp;#34;myapp-yum-log-1&amp;#34;,&amp;#34;size&amp;#34;:13264869,&amp;#34;offsetLag&amp;#34;:0,&amp;#34;isFuture&amp;#34;:false}]}]}]}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;结果是json串，可以看到&lt;code&gt;myapp-yum-log-2&lt;/code&gt;在broker-1上占用了&lt;code&gt;13291235&lt;/code&gt;字节，也就是&lt;code&gt;12M&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;2-kafka-manager&#34;&gt;2. kafka-manager&lt;/h3&gt;

&lt;h2 id=&#34;四-集群监控&#34;&gt;四、集群监控&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://kafka.apache.org/24/documentation.html#monitoring&#34;&gt;kafka-doc-monitor&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gdra6n69uhj30f00kkgot.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>你还记得你JVM的的初始堆大小吗</title>
      <link>https://bgbiao.top/post/jvm%E7%9A%84%E5%88%9D%E5%A7%8B%E5%A0%86/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/jvm%E7%9A%84%E5%88%9D%E5%A7%8B%E5%A0%86/</guid>
      
        <description>&lt;p&gt;通常对于很多java应用来说，当打成jar包后会下意识的使用&lt;code&gt;java -jar xxx.jar&lt;/code&gt;来运行应用，而不是根据自己业务或实际debug的一些需求来增加一些JVM的辅助参数，这样导致的问题就是，后续出了问题之后不容易进行管理以及相关故障追踪和排查。&lt;/p&gt;

&lt;p&gt;那么问题来了，当你在&lt;code&gt;jar -jar&lt;/code&gt;的时候，默认的JVM堆内存是多少呢?&lt;/p&gt;

&lt;p&gt;其实，JVM在不同架构(配置)的OS下回体现出不同的JVM配置，比如在一个&lt;code&gt;8c16g&lt;/code&gt;的ECS上，默认的Heap值如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ java -XX:+PrintFlagsFinal -version | grep HeapSize
    uintx ErgoHeapSizeLimit                         = 0                                   {product}
    uintx HeapSizePerGCThread                       = 87241520                            {product}
    uintx InitialHeapSize                          := 264241152                           {product}
    uintx LargePageHeapSizeThreshold                = 134217728                           {product}
    uintx MaxHeapSize                              := 4206886912                          {product}
java version &amp;#34;1.8.0_141&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由上述的输出可知，初始的堆内存为&lt;code&gt;264241152/1024/1024=252M&lt;/code&gt;，而堆内存最大为&lt;code&gt;4206886912/1024/1024/1024=3G&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个时候可能就会有一个问题就是，该ECS上跑多少个&lt;code&gt;java -jar xxx.jar&lt;/code&gt;这类的服务会比较好呢？如果按照每个服务都能使用3G的堆内存来算，该机器上做多跑4个这类的服务是一个比较合理的规划，但是考虑实际的业务使用需求，单纯这样考虑可能会有点唐突了，因此还是建议每个应用在部署时指定一些基础的参数，比如初始堆和最大堆，并且这两个参数一般建议设置成一致，以免在运行过程中堆的扩容造成的损耗。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gdra6n69uhj30f00kkgot.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>分布式对象存储Minio的可观测性方案</title>
      <link>https://bgbiao.top/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8minio%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8minio%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E6%96%B9%E6%A1%88/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;背景: 对于初创企业来说，在很长一段时间一些基础的开源服务基本都是&amp;rdquo;裸奔&amp;rdquo;上线的，除了一些传统的主机级别的监控之外，很难有一些额外的性能指标来描述该服务的整体性能情况。因此，在我们的&lt;a href=&#34;https://bgbiao.top/post/minio%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/&#34;&gt;Minio对象存储服务&lt;/a&gt;上线到最近一直也是裸奔的，虽然暂时也没出现过故障，但是作为一名专业搞笑的SRE来讲，服务的可观测性一定得跟上，不然后期铁锅是妥妥的背定了，这篇文章就主要介绍下&lt;code&gt;Minio&lt;/code&gt;的可观测性方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;开源组件的可观测性现状&#34;&gt;开源组件的可观测性现状&lt;/h3&gt;

&lt;p&gt;在开头提到了，初创企业的开源服务初期大多都是裸奔上线的，出现这种情况我认为一般分为内因和外因:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内因是开源的基础中间件性能指标通常很多，不容易抽象，因此这些服务的性能指标数据通常可以通过内部的api或cli来获取，不太容易直接和开源的监控系统进行集成;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;外因是对于初创企业来说，人力有限并且对于众多开源组件的理解不够深入导致前面说的&amp;rdquo;裸奔&amp;rdquo;上线的现象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过随着以&lt;code&gt;Kubernetes&lt;/code&gt;，&lt;code&gt;Prometheus&lt;/code&gt;为代表的CloudNative理念不断发展，越来越多的开源中间件也支持了兼容&lt;code&gt;Prometheus Metrics&lt;/code&gt;格式的性能指标，这对于初创企业的技术团队来说可谓是一个福音。&lt;/p&gt;

&lt;p&gt;截止目前，我们所熟知的很多开源软件已经内置了兼容&lt;code&gt;Prometheus Metrics&lt;/code&gt;的API接口，不再需要第三方的&lt;code&gt;exporter&lt;/code&gt;来导出一些性能指标数据。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[内置Metrics接口的开源软件](https://prometheus.io/docs/instrumenting/exporters/#software-exposing-prometheus-metrics)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.ceph.com/docs/master/mgr/prometheus/&#34;&gt;Ceph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-metrics&#34;&gt;Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.envoyproxy.io/docs/envoy/latest/operations/admin.html#get--stats?format=prometheus&#34;&gt;Envoy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/coreos/etcd&#34;&gt;Etcd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/apache/flink&#34;&gt;Flink&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.grafana.org/administration/metrics/&#34;&gt;Grafana&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Kong/kong-plugin-prometheus&#34;&gt;Kong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kubernetes/kubernetes&#34;&gt;Kubernetes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/BuoyantIO/linkerd&#34;&gt;Linkerd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/minio/minio&#34;&gt;Minio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rabbitmq.com/prometheus.html&#34;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/influxdata/telegraf/tree/master/plugins/outputs/prometheus_client&#34;&gt;Telegraf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/containous/traefik&#34;&gt;Traefik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/openzipkin/zipkin/tree/master/zipkin-server#metrics&#34;&gt;Zipkin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;minio集群的可观测性&#34;&gt;Minio集群的可观测性&lt;/h3&gt;

&lt;p&gt;得益于&lt;code&gt;Minio&lt;/code&gt;的云原生化，这款分布式的对象存储服务天然的支持了&lt;code&gt;Prometheus Metrics&lt;/code&gt;格式的指标数据以及服务端点(API)，因此，如果想要在已有的Minio集群中增加性能指标的监控，将是一件很容易的事情。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.min.io/docs/how-to-monitor-minio-using-prometheus.html&#34;&gt;使用Prometheus监控Minio服务&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Minio服务通过内置的服务端点暴露监控数据，用来监控服务整体的健康状态以及性能指标:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Healthcheck 探针: 提供两个服务探活接口，一个用于检测服务是否启动，另外一个用于检测服务是否可以正常对外提供服务(服务就绪)&lt;/li&gt;
&lt;li&gt;- 探活接口: &lt;code&gt;/minio/health/live&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;- 就绪接口: &lt;code&gt;/minio/health/ready&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Prometheus 探针: 提供了prometheus metrics格式的性能指标数据&lt;/li&gt;
&lt;li&gt;- Metrics接口: &lt;code&gt;/minio/prometheus/metrics&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; Healthcheck相关的探针默认是非认证的接口，服务启动后可直接访问; Prometheus探针的接口默认是基于&lt;code&gt;JWT认证&lt;/code&gt;的接口，需要额外设置来访问其Metrics数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Minio的Metrics数据暴露&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;管理员可通过下述方式获取Metrics端点的jwt token:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 获取token
$ mc admin prometheus generate  minio
scrape_configs:
- job_name: minio-job
  bearer_token: eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJleHAiOjQ3NDAwMzM4MjAsImlzcyI6InByb21ldGhldXMiLCJzdWIiOiJNaW5pb1NvdWwifQ.1QiANgXVCpAPWCdF9EejhH608rZbdCRcHe3RtalC2XnScWtYMk_OG0ih-Z3t4ADb1cnYREdTrQwWscFw6Xvk3Q
  metrics_path: /minio/prometheus/metrics
  scheme: http
  static_configs:
  - targets: [minio.bgbiao.top]

# 在配置prometheus的scrape时配置如上相关参数&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通常对于内部系统间的调用来说，权限可能没那么重要，可以增加如下环境变量来开启metrics的非认证方式:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;MINIO_PROMETHEUS_AUTH_TYPE=&amp;#34;public&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;此时，直接访问接口可以获取到如下的Metrics数据:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ curl -s  minio.bgbiao.top/minio/prometheus/metrics | head -10
# HELP disk_storage_available Total available space left on the disk
# TYPE disk_storage_available gauge
disk_storage_available{disk=&amp;#34;/data/minio&amp;#34;} 2.78376280064e+11
# HELP disk_storage_total Total space on the disk
# TYPE disk_storage_total gauge
disk_storage_total{disk=&amp;#34;/data/minio&amp;#34;} 3.00809048064e+11
# HELP disk_storage_used Total disk storage used on the disk
# TYPE disk_storage_used gauge
disk_storage_used{disk=&amp;#34;/data/minio&amp;#34;} 2.2432768e+10
# HELP go_gc_duration_seconds A summary of the GC invocation durations.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;minio-metrics相关定义&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;标准的运行时指标使用以&lt;code&gt;go_&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;进程级别的指标以&lt;code&gt;process_&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;prometheus暴露的指标&lt;code&gt;promhttp_&lt;/code&gt;开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disk_storage_used&lt;/code&gt;: 磁盘使用空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disk_storage_available&lt;/code&gt;: 磁盘可用空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;disk_storage_total&lt;/code&gt;: 磁盘总空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minio_disks_offline&lt;/code&gt;: 当前minio实例中处于下线状态的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minio_disks_total&lt;/code&gt;: 当前minio实例的磁盘总数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_requests_total&lt;/code&gt;: 当前minio实例中s3接口总请求数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_errors_total&lt;/code&gt;: s3接口错误请求数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_requests_current&lt;/code&gt;: 活动状态的s3请求数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internode_rx_bytes_total&lt;/code&gt;: 当前MinIO服务器实例接收的节点间字节的总数(bytes)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;internode_tx_bytes_total&lt;/code&gt;: 当前MinIO服务器实例发送到其他节点的字节总数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_rx_bytes_total&lt;/code&gt;: 当前MinIO服务器实例接收的s3字节总数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_tx_bytes_total&lt;/code&gt;: 当前MinIO服务器实例发送的s3字节总数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3_ttfb_seconds_&lt;/code&gt;: 统计s3请求的延迟信息&lt;/li&gt;
&lt;li&gt;- bucket: bucket操作相关的延迟&lt;/li&gt;
&lt;li&gt;- count: 延迟统计&lt;/li&gt;
&lt;li&gt;- sum: 总延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; Minio不同的版本的Metrics数据有区别，需要查看具体暴露的数据指标&lt;/p&gt;

&lt;p&gt;&lt;code&gt;示例&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 打开文件数
process_open_fds{job=&amp;#34;minio-metrics&amp;#34;}

# 启动时间(时间戳)
process_start_time_seconds{job=&amp;#34;minio-metrics&amp;#34;}

# 虚拟内存使用
process_virtual_memory_bytes{job=&amp;#34;minio-metrics&amp;#34;}

# cpu占用时间
process_cpu_seconds_total{job=&amp;#34;minio-metrics&amp;#34;}

# minio对外的http接口状态
promhttp_metric_handler_requests_total{job=&amp;#34;minio-metrics&amp;#34;}

# 链接中的http请求
promhttp_metric_handler_requests_in_flight{job=&amp;#34;minio-metrics&amp;#34;}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;配置prometheus数据抓取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 我们的Prometheus是使用CRD方式部署在Kubernetes集群中的，因此抓取外部Metrics数据需要做如下的操作.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 暴露minio服务
$ cat endpoint-minio.yaml
apiVersion: v1
kind: Endpoints
metadata:
  name: minio-metrics
  namespace: monitoring
  labels:
    app: minio-metrics
subsets:
- addresses:
  - ip: 192.168.0.148
  - ip: 192.168.0.149
  - ip: 192.168.0.150
  - ip: 192.168.0.151
  ports:
  - port: 9000
    name: http-metrics
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  namespace: monitoring
  name: minio-metrics
  labels:
    app: minio-metrics
spec:
  ports:
  - name: http-metrics
    port: 9000
    targetPort: 9000
    protocol: TCP

# prometheus servicemonitor
$ cat prometheus-minio.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: minio-metrics
  name: minio-metrics
  namespace: monitoring
spec:
  # 对应的端点是上面创建的svc的ports
  endpoints:
  # 可以定义两个采集端点，一个是minio服务本身的监控，一个是minio节点的基础监控
  - interval: 30s
    port: http-metrics
    path: /minio/prometheus/metrics
  jobLabel: app
  # 匹配monitoring命名空间的app=minio-metrics的svc
  namespaceSelector:
    matchNames:
    - monitoring
  selector:
    matchLabels:
      app: minio-metrics&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;查看prometheus监控的minio相关数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Prometheus成功抓取minio metrics数据后，即可在prometheus中查看到先关数据:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdnrt82rfpj324a0t47at.jpg&#34; alt=&#34;minio-prometheus-metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在Grafana中配置关心的指标以及相关图表:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdofcrk9bbj31gr0u04a4.jpg&#34; alt=&#34;minio-grafana监控&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了方便其他运维小伙伴们，我将Minio的Grafana模板开源出来，有需求的可以直接使用如下模板:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/12063&#34;&gt;minio-grafana模板&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gdra6n69uhj30f00kkgot.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Traefik的可观测性方案</title>
      <link>https://bgbiao.top/post/traefik%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E6%96%B9%E6%A1%88/</link>
      <pubDate>Tue, 07 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/traefik%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E6%96%B9%E6%A1%88/</guid>
      
        <description>&lt;h2 id=&#34;traefik的可观测性支持&#34;&gt;Traefik的可观测性支持&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.traefik.io/observability/logs/&#34;&gt;traefik-observability&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在Traefik-2.X的生态里，将可观测性分为了如下几个部分，并提升到了专门的功能说明中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;服务日志: Traefik进程本身相关的操作日志&lt;/li&gt;
&lt;li&gt;访问日志: 由Traefik接管的代理服务的访问日志(access.log)&lt;/li&gt;
&lt;li&gt;Metrics: Traefik提供的自身详细的metrics数据&lt;/li&gt;
&lt;li&gt;Tracing: Traefik也提供了追踪相关的接口，用来可视化分布式或微服务中的调用情况&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务日志&#34;&gt;服务日志&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;默认的环境中,Traefik会将日志以&lt;code&gt;text&lt;/code&gt;格式写入到stdout中，如果使用docker的方式部署的话，想要查看日志需要使用&lt;code&gt;docker logs container_name&lt;/code&gt;方式来查看日志。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;相关配置&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
$ cat traefik.toml
[log]
  filePath = &amp;#34;/path/to/traefik.log&amp;#34;   # 配置traefik的进程日志路径
  format = &amp;#34;json&amp;#34;                     # 配置日志文件的格式[text(text|json)]
  level = &amp;#34;DEBUG&amp;#34;                     # 指定日志输出的级别[ERROR(ERROR|DEBUG|INFO|PANIC|FATAL|WARN)]

# cli 配置
--log.filePath=/path/to/traefik.log
--log.format=json
--log.level=DEBUG&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 具体的日志配置参数需要和当前环境中的traefik大版本兼容，否则可能会出现意想不到的问题。&lt;/p&gt;

&lt;h3 id=&#34;访问日志&#34;&gt;访问日志&lt;/h3&gt;

&lt;p&gt;访问日志用来记录通过traefik进来的各个请求的访问详情，包含HTTP请求的各个header以及响应时间等数据，类似于Nginx中的&lt;code&gt;access.log&lt;/code&gt;，通常情况，我们可以使用访问日志来分析整个traefik的整体流量以及各个服务流量以及状态详情。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 访问日志默认也是以&lt;code&gt;text&lt;/code&gt;格式被写到标准输出的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;相关配置&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
$ cat traefik.toml
[accessLog]
  filePath = &amp;#34;/path/to/traefik.log&amp;#34;
  format = &amp;#34;&amp;#34;                       # 指定访问日志的格式，默认使用CLF(Common Log Format)，可以指定为json格式
  bufferingSize = 100               # 以异步方式写入日志需要指定该参数，表示写入到指定输出设备前保留在内存中的日志行数
  [accessLog.filters]               # 指定一组逻辑上是Or的过滤连接器,指定多个过滤器将比只指定一个过滤器保留更多的访问日志
    statusCodes = [&amp;#34;200&amp;#34;, &amp;#34;300-302&amp;#34;] # 过滤指定状态码范围的请求日志
    retryAttempts = true             # 当有重试时保留日志
    minDuration = &amp;#34;10ms&amp;#34;             # 当请求花费的时间超过指定的持续时间时，保留访问日志
    
  [accessLog.fields]                # 限制访问日志中的字段(可以使用fields.names和fields.header选项来决定字段的输出)
    defaultMode = &amp;#34;keep&amp;#34;            # 每种字段可以设置成如下字段(keep:保留字段,drop:丢弃,redact:使用redacted替换值)
    [accessLog.fields.names]        # 指定限制的字段名称
      &amp;#34;ClientUsername&amp;#34; = &amp;#34;drop&amp;#34;     # 设置ClientUsername字段为丢弃
    [accessLog.fields.headers]      # 设置headers相关字段
      defaultMode = &amp;#34;keep&amp;#34;          # 对全部的header进行默认保留
      [accessLog.fields.headers.names] # 对指定的header字段设置保留规则
        &amp;#34;User-Agent&amp;#34; = &amp;#34;redact&amp;#34;
        &amp;#34;Authorization&amp;#34; = &amp;#34;drop&amp;#34;
        &amp;#34;Content-Type&amp;#34; = &amp;#34;keep&amp;#34;

# cli 配置
--accesslog=true
--accesslog.filepath=/path/to/access.log
--accesslog.format=json
--accesslog.bufferingsize=100
--accesslog.filters.statuscodes=200,300-302
--accesslog.filters.retryattempts
--accesslog.filters.minduration=10ms
--accesslog.fields.defaultmode=keep
--accesslog.fields.names.ClientUsername=drop
--accesslog.fields.headers.defaultmode=keep
--accesslog.fields.headers.names.User-Agent=redact
--accesslog.fields.headers.names.Authorization=drop
--accesslog.fields.headers.names.Content-Type=keep&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 由于我们是将Traefik当做Kubernetes集群中的边缘节点，去代理内部HTTP服务的，因此Traefik部署在集群内部,将进程日志和访问日志都以volume的方式挂载到边缘节点的数据目录中。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;DaemonSet&lt;/code&gt;方式将Traefik部署在k8s集群内部，具体的配置如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;97
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ cat traefik-ds.yml
---
kind: DaemonSet
apiVersion: extensions/v1beta1
metadata:
  name: traefik-ingress-controller
  namespace: kube-system
  labels:
    k8s-app: traefik-ingress-lb
spec:
  template:
    metadata:
      labels:
        k8s-app: traefik-ingress-lb
        name: traefik-ingress-lb
    spec:
      affinity:
        # 定义node的亲和性，不允许调度到master节点
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: node-role.kubernetes.io/master
                operator: DoesNotExist
      serviceAccountName: traefik-ingress-controller
      terminationGracePeriodSeconds: 30
      hostNetwork: true
      containers:
      - image: traefik:v1.7.16
        name: traefik-ingress-lb
        ports:
        - name: http
          containerPort: 80
          hostPort: 80
        - name: admin
          containerPort: 8080
        securityContext:
          capabilities:
            drop:
            - ALL
            add:
            - NET_BIND_SERVICE
        args:
        - --api
        - --kubernetes
        - --logLevel=INFO
        - --traefikLog.filePath=/logdata/traefik.log
        - --configfile=/config/traefik.toml
        - --accesslog.filepath=/logdata/access.log
        - --accesslog.bufferingsize=100
        volumeMounts:
        - mountPath: /config
          name: config
        - mountPath: /logdata
          name: access-log
      volumes:
      - configMap:
          name: traefik-config
        name: config
      - name: access-log
        hostPath:
          path: /opt/logs/ingress/

# 查看traefik 的状态
$ kubectl  get pods -n kube-system  | grep traefik
traefik-ingress-controller-2dx7k   1/1     Running   0          5h28m
...
...

$ kubectl  get svc -n kube-system  | grep traefik
traefik-ingress-service   ClusterIP   10.253.132.216   &amp;lt;none&amp;gt;        80/TCP,8080/TCP          123d
traefik-web-ui            ClusterIP   10.253.54.184    &amp;lt;none&amp;gt;        80/TCP                   172d


# 可以通过节点的ping接口和admin接口来查看traefik服务是否正常
$ curl 10.253.132.216/ping
OK

$ curl 10.253.132.216:8080
&amp;lt;a href=&amp;#34;/dashboard/&amp;#34;&amp;gt;Found&amp;lt;/a&amp;gt;.


# 在调度到treafik的节点上查看进程日志和访问日志
$ tree -L 2 /opt/logs/ingress/
/opt/logs/ingress/
├── access.log
└── traefik.log

$ tail -n 10 /opt/logs/ingress/traefik.log
time=&amp;#34;2020-04-07T08:53:38Z&amp;#34; level=warning msg=&amp;#34;Endpoints not available for my-data/my-data-selfaccess-dev&amp;#34;
time=&amp;#34;2020-04-07T08:53:38Z&amp;#34; level=warning msg=&amp;#34;Endpoints not available for my-data/my-data-metadata-prod1&amp;#34;


$ tail -n 10 /opt/logs/ingress/access.log
172.16.21.28 - - [07/Apr/2020:08:52:54 +0000] &amp;#34;POST /.kibana/_search?ignore_unavailable=true&amp;amp;filter_path=aggregations.types.buckets HTTP/1.1&amp;#34; 503 161 &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; 491674 &amp;#34;prod-es-cluster.soulapp-inc.cn&amp;#34; &amp;#34;http://20.0.41.10:9200&amp;#34; 1ms
172.16.21.28 - - [07/Apr/2020:08:52:54 +0000] &amp;#34;POST /.kibana/_search?ignore_unavailable=true&amp;amp;filter_path=aggregations.types.buckets HTTP/1.1&amp;#34; 503 161 &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; 491671 &amp;#34;prod-es-cluster.soulapp-inc.cn&amp;#34; &amp;#34;http://20.0.26.20:9200&amp;#34; 1ms
172.16.21.28 - - [07/Apr/2020:08:52:54 +0000] &amp;#34;GET /.kibana/doc/config%3A6.4.0 HTTP/1.1&amp;#34; 503 301 &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; 491675 &amp;#34;prod-es-cluster.soulapp-inc.cn&amp;#34; &amp;#34;http://20.0.14.6:9200&amp;#34; 1ms&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从访问日志的输出格式中，我们可以看到，traefik的访问日志和Nginx的访问日志会比较相似，有了这份日志后，我们可以通过一些ELK之类的日志分析方案来分期网站的整体状态，比如UV,PV,区域分布，状态分布以及响应时间等等。&lt;/p&gt;

&lt;p&gt;另外，我们是将访问日志直接持久化输出到node节点上，后面可以通过node主机上的日志采集插件，将日志发送到ELK Stack中，进行分析，当然也可以直接将ELK Stack的日志采集端部署到traefik的pod中，也是可以的。&lt;/p&gt;

&lt;h3 id=&#34;metrics&#34;&gt;Metrics&lt;/h3&gt;

&lt;p&gt;Traefik默认支持四种Metrics的后端实现:
- &lt;a href=&#34;https://docs.traefik.io/observability/metrics/datadog/&#34;&gt;Datadog&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/metrics/influxdb/&#34;&gt;Influxdb&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/metrics/prometheus/&#34;&gt;Prometheus&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/metrics/statsd/&#34;&gt;StatsD&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;想要开启&lt;code&gt;metrics&lt;/code&gt;的支持，只需要做如下配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
    [metrics]
      [metrics.prometheus]
      buckets=[0.1,0.3,1.2,5.0]
      entryPoint = &amp;#34;traefik&amp;#34;

# yaml 配置文件
metrics: {}

# cli 配置
--metrics=true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Datadog后端支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置详情:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml配置文件
[metrics]
  [metrics.datadog]
    address = &amp;#34;127.0.0.1:8125&amp;#34;
    addEntryPointsLabels = true   #在入口处增加metrics标签[true]
    addServicesLabels = true      #在service中启用meirtcs[true]
    pushInterval = 10s            #push metrics到datalog的间隔时间[10s]

# cli 配置
--metrics.datadog=true
--metrics.datadog.address=127.0.0.1:8125
--metrics.datadog.addEntryPointsLabels=true
--metrics.datadog.addServicesLabels=true
--metrics.datadog.pushInterval=10s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;InfluxDB后端支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置详情:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml配置
[metrics]
  [metrics.influxDB]
    address = &amp;#34;localhost:8089&amp;#34;     #指定influxdb地址 [localhost:8089]
    protocol = &amp;#34;udp&amp;#34;               #influxdb的传输协议 [udp(udp|http)]
    database = &amp;#34;db&amp;#34;                #指定metrics写入的库[&amp;#34;&amp;#34;]
    retentionPolicy = &amp;#34;two_hours&amp;#34;  #metrics在influxdb中的保留策略 [&amp;#34;&amp;#34;]
    username = &amp;#34;&amp;#34;                  #influxdb用户名
    password = &amp;#34;&amp;#34;                  #influxdb密码
    addEntryPointsLabels = true    #入口处增加metrics标签[true]
    addServicesLabels = true       #在service中启用meirtcs[true]
    pushInterval = 10s             #push metrics到datalog的间隔时间[10s]

# cli 配置
--metrics.influxdb=true
--metrics.influxdb.address=localhost:8089
--metrics.influxdb.protocol=udp
--metrics.influxdb.database=db
--metrics.influxdb.retentionPolicy=two_hours
--metrics.influxdb.username=john
--metrics.influxdb.password=secret
--metrics.influxdb.addEntryPointsLabels=true
--metrics.influxdb.addServicesLabels=true
--metrics.influxdb.pushInterval=10s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Prometheus后端支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置详情:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml配置
[metrics]
  [metrics.prometheus]
    buckets = [0.1,0.3,1.2,5.0]      #延迟的metrics的bucket存储[0.100000, 0.300000, 1.200000, 5.000000]
    addEntryPointsLabels = true      #入口处增加metrics标签[true]
    addServicesLabels = true         #在service中启用meirtcs[true]
    entryPoint = &amp;#34;traefik&amp;#34;           #指定metrics的端点[traefik(默认是管理端口8080/metrics)],也可以自定义
    manualRouting = true             #是否禁用内部路由[false]

# cli配置
--metrics.prometheus=true
--metrics.prometheus.buckets=0.100000, 0.300000, 1.200000, 5.000000
--metrics.prometheus.addEntryPointsLabels=true
--metrics.prometheus.addServicesLabels=true
## 自定义了一个metrics端点，并指定了端口
--metrics.prometheus.entryPoint=metrics
--entryPoints.metrics.address=:8082
--metrics.prometheus.manualrouting=true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;和其他两种方式不同的是，prometheus仅会暴露metrics，是需要使用prometheus-server定期进行&lt;code&gt;pull&lt;/code&gt;来收集数据的。&lt;/p&gt;

&lt;p&gt;配置生效后，可以访问如下端口进行测试:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 自定义了metrics端点
$ curl localhost:8082/metrics

# 使用默认的traefik端点(用的是admin的端口)
$ curl localhost:8080/metrics&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;StatsD后端支持&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;详细配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置
[metrics]
  [metrics.statsD]
    address = &amp;#34;localhost:8125&amp;#34;          # 指定statsD服务地址
    addEntryPointsLabels = true         # 入口处增加metrics标签[true] 
    addServicesLabels = true            # 在service中启用meirtcs[true]
    pushInterval = 10s                  # push间隔
    prefix = &amp;#34;traefik&amp;#34;                  # 定义metrics收集的前缀[traefik]

# cli 配置
--metrics.statsd=true
--metrics.statsd.address=localhost:8125
--metrics.statsd.addEntryPointsLabels=true
--metrics.statsd.addServicesLabels=true
--metrics.statsd.pushInterval=10s
--metrics.statsd.prefix=&amp;#34;traefik&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Prometheus后端的Metrics示例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 由于在生产环境使用的是traefik-1.7.6版本，因此上述的一些配置参数可能并不适用于该版本，详细的参数需要查看具体版本的支持参数，同时我们将traefik当做kubernetes集群中的ingress方案，因此如下操作在一个可用的k8s集群内部。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.traefik.io/v1.7/configuration/metrics/&#34;&gt;traefik-1.7-metrics&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;1.traefik的metrics配置&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# traefik metrics 配置
$ cat traefik-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: traefik-config
  namespace: kube-system
data:
  traefik.toml: |
    defaultEntryPoints = [&amp;#34;http&amp;#34;,&amp;#34;https&amp;#34;]
    debug = false
    logLevel = &amp;#34;INFO&amp;#34;

    InsecureSkipVerify = true
    [entryPoints]
      [entryPoints.http]
      address = &amp;#34;:80&amp;#34;
      compress = true
      [entryPoints.https]
      address = &amp;#34;:443&amp;#34;
        [entryPoints.https.tls]
    [web]
      address = &amp;#34;:8080&amp;#34;
    [kubernetes]
    # 定义metrics相关参数
    [metrics]
      [metrics.prometheus]
      buckets=[0.1,0.3,1.2,5.0]
      entryPoint = &amp;#34;traefik&amp;#34;
    [ping]
    entryPoint = &amp;#34;http&amp;#34;

# 重新调度pod后，即可查看暴露的endpoint

$ kubectl  get ep -A | grep traefik
kube-system            traefik-ingress-service                    172.16.171.163:80,172.16.21.26:80,172.16.21.27:80 + 11 more...            122d
kube-system            traefik-web-ui                             172.16.171.163:8080,172.16.21.26:8080,172.16.21.27:8080 + 4 more...       171d

$ kubectl  get svc -n kube-system | grep traefik
traefik-ingress-service   ClusterIP   10.253.132.216   &amp;lt;none&amp;gt;        80/TCP,8080/TCP          122d
traefik-web-ui            ClusterIP   10.253.54.184    &amp;lt;none&amp;gt;        80/TCP                   171d

# 测试访问metrics服务(因为和traefik相关的两个service均路由到了traefil-ingress的pod上,下面两个效果是一致的)
$ curl -s  10.253.132.216:8080/metrics  | head -10
....
....
$ curl -s  10.253.54.184/metrics | head -10&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 推荐使用traefik-web-ui暴露的svc地址&lt;/p&gt;

&lt;p&gt;指标以及相关含义:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指标项&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;process_max_fds&lt;/td&gt;
&lt;td&gt;traefik进程最大的fd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;process_open_fds&lt;/td&gt;
&lt;td&gt;进程打开的fd&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;process_resident_memory_bytes&lt;/td&gt;
&lt;td&gt;进程占用内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;process_start_time_seconds&lt;/td&gt;
&lt;td&gt;进程启动时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;process_virtual_memory_bytes&lt;/td&gt;
&lt;td&gt;进程占用虚拟内存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_open_connections&lt;/td&gt;
&lt;td&gt;traefik后端打开链接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_request_duration_seconds_bucket&lt;/td&gt;
&lt;td&gt;traefik后端请求处理时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_request_duration_seconds_sum&lt;/td&gt;
&lt;td&gt;总时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_request_duration_seconds_count&lt;/td&gt;
&lt;td&gt;总请求时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_requests_total&lt;/td&gt;
&lt;td&gt;一个后端处理的总请求数(按status code, protocol, and method划分)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_backend_server_up&lt;/td&gt;
&lt;td&gt;后端是否up(0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_config_last_reload_failure&lt;/td&gt;
&lt;td&gt;traefik上次失败reload的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_config_last_reload_success&lt;/td&gt;
&lt;td&gt;上次成功reload的时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_config_reloads_failure_total&lt;/td&gt;
&lt;td&gt;失败次数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_config_reloads_total&lt;/td&gt;
&lt;td&gt;成功次数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_entrypoint_open_connections&lt;/td&gt;
&lt;td&gt;入口点存在打开链接的数量(method and protocol划分)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_entrypoint_request_duration_seconds_bucket&lt;/td&gt;
&lt;td&gt;在入口点处理请求花费的时间(status code, protocol, and method.)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;traefik_entrypoint_requests_total&lt;/td&gt;
&lt;td&gt;一个入口点处理的总请求数(状态码分布)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;2.配置prometheus-server&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意，此时我们需要配置prometheus-server来对traefik暴露的metrics进行定期的pull采集。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 在k8s中创建一个prometheus monitor service
$ cat prometheus-traefik.yml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    k8s-app: traefik-ingress-lb
  name: traefik-metrics
  namespace: monitoring
spec:
  # 对应的端点是上面创建的svc的ports
  endpoints:
    # 定义endpoint采集的时间
  - interval: 30s
    port: admin
    path: /metrics
  jobLabel: k8s-app
  # 匹配monitoring命名空间的app=gpu-metrics的svc
  namespaceSelector:
    matchNames:
    - kube-system
  selector:
    matchLabels:
      k8s-app: traefik-ingress-lb

$ kubectl apply -f prometheus-traefik.yml&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;配置完成后，即可在prometheus中查看相关的metrics数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdl4lcmvwsj32620o0ah5.jpg&#34; alt=&#34;prometheus-traefik-metrics&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;3.根据指标配置Grafana&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/12041&#34;&gt;grafana模板&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdl6drdnotj31kw0u0gxk.jpg&#34; alt=&#34;Traefik-全局监控详情&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了Merics的可视化后，针对于HTTP服务来说做各种滚动升级以及切流发布时，就很容易能够看到整个流量的变化。&lt;/p&gt;

&lt;h3 id=&#34;tracing&#34;&gt;Tracing&lt;/h3&gt;

&lt;p&gt;追踪系统可以开发人员可视化其基础架构中的调用流程.&lt;/p&gt;

&lt;p&gt;Traefik遵循OpenTracing规范(一个为分布式跟踪而设计的开放标准)&lt;/p&gt;

&lt;p&gt;Traefik支持五种追踪系统后端:
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/jaeger/&#34;&gt;Jaeger&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/zipkin/&#34;&gt;Zipkin&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/datadog/&#34;&gt;Datadog&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/instana/&#34;&gt;Instana&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/haystack/&#34;&gt;Haystack&lt;/a&gt;
- &lt;a href=&#34;https://docs.traefik.io/observability/tracing/elastic/&#34;&gt;Elastic&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; Datadog,Instana,Haystack为商业解决方案，以下不做介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 默认情况下，traefik使用&lt;code&gt;Jaeger&lt;/code&gt;来最为追踪系统的后端实现.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
$ cat traefik.toml
[tracing]
  serviceName = &amp;#34;traefik&amp;#34;			# 选择追踪系统的后端实现[traefik(表示使用jaeger)]
  spanNameLimit = 150					# 限制长名称的名称阶段(这可以防止某些跟踪提供程序删除超过其长度限制的跟踪)

# cli 配置
--tracing=true
--tracing.serviceName=traefik
--tracing.spanNameLimit=150&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.Jaeger&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相关配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
$ cat traefik.toml
[tracing]
  [tracing.jaeger]					# 开启jaeger的追踪支持
    samplingServerURL = &amp;#34;http://localhost:5778/sampling&amp;#34; 		# 指定jaeger-agent的http采样地址
    samplingType = &amp;#34;const&amp;#34;	# 指定采样类型[const(const|probabilistic|rateLimiting)]
    samplingParam = 1.0			# 采样参数的值[1.0(const:0|1,probabilistic:0-1,rateLimiting:每秒的span数)]
    localAgentHostPort = &amp;#34;127.0.0.1:6831&amp;#34;										# 本地agent主机和端口(会发送到jaeger-agent)
    gen128Bit = true				# 生成128位的traceId,兼容OpenCensus
    propagation = &amp;#34;jaeger&amp;#34;  # 设置数据传输的header类型[jaeger(jaeger|b3兼容OpenZipkin)]
    traceContextHeaderName = &amp;#34;uber-trace-id&amp;#34;  # 跟踪上下文的header,用于传输跟踪上下文的http头名
  [tracing.jaeger.collector]  # 指定jaeger的collector服务
    endpoint = &amp;#34;http://127.0.0.1:14268/api/traces?format=jaeger.thrift&amp;#34;
    user = &amp;#34;my-user&amp;#34;          # 向collector提交时的http认证用户[&amp;#34;&amp;#34;]
    password = &amp;#34;my-password&amp;#34;  # 向collector提交时的http认证密码[&amp;#34;&amp;#34;]


# cli 配置
--tracing.jaeger=true
--tracing.jaeger.samplingServerURL=http://localhost:5778/sampling
--tracing.jaeger.samplingType=const
--tracing.jaeger.samplingParam=1.0
--tracing.jaeger.localAgentHostPort=127.0.0.1:6831
--tracing.jaeger.gen128Bit
--tracing.jaeger.propagation=jaeger
--tracing.jaeger.traceContextHeaderName=uber-trace-id
--tracing.jaeger.collector.endpoint=http://127.0.0.1:14268/api/traces?format=jaeger.thrift
--tracing.jaeger.collector.user=my-user
--tracing.jaeger.collector.password=my-password&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.Zipkin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相关配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
[tracing]
  [tracing.zipkin]                  # 指定使用zipkin追踪系统
    httpEndpoint = &amp;#34;http://localhost:9411/api/v2/spans&amp;#34;   # 指定zipkip收集数据的http端点
    sameSpan = true                 # 使用Zipkin SameSpan RPC 类型追踪方式
    id128Bit = true                 # 使用Zipkin 128 bit的追踪id(true)
    sampleRate = 0.2                # 指定请求trace系统的频率[1.0(0.1-1.0)]

# cli 配置
--tracing.zipkin=true
--tracing.zipkin.httpEndpoint=http://localhost:9411/api/v2/spans
--tracing.zipkin.sameSpan=true
--tracing.zipkin.id128Bit=false
--tracing.zipkin.sampleRate=0.2&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4.Elastic&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相关配置:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# toml 配置文件
$ cat traefik.toml
[tracing]
  [tracing.elastic]
    serverURL = &amp;#34;http://apm:8200&amp;#34;     # 指定Elastic APM服务地址
    secretToken = &amp;#34;&amp;#34;                  # 指定Elastic APM服务的安全token
    serviceEnvironment = &amp;#34;&amp;#34;           # 指定APM Server的环境

# cli 配置
--tracing.elastic=true
--tracing.elastic.serverurl=&amp;#34;http://apm:8200&amp;#34;
--tracing.elastic.secrettoken=&amp;#34;mytoken&amp;#34;
--tracing.elastic.serviceenvironment=&amp;#34;production&amp;#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/007S8ZIlly1gdra6n69uhj30f00kkgot.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>基于DCGM和Prometheus的GPU监控方案</title>
      <link>https://bgbiao.top/post/%E5%9F%BA%E4%BA%8Edcgm%E5%92%8Cprometheus%E7%9A%84gpu%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 05 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E5%9F%BA%E4%BA%8Edcgm%E5%92%8Cprometheus%E7%9A%84gpu%E7%9B%91%E6%8E%A7%E6%96%B9%E6%A1%88/</guid>
      
        <description>&lt;h2 id=&#34;基于dcgm和prometheus的gpu监控方案&#34;&gt;基于DCGM和Prometheus的GPU监控方案&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;背景: 在早期的GPU监控中我们会使用一些NVML工具来对GPU卡的基本信息进行采集，并持久化到监控系统的数据存储层。因为我们知道，其实通过&lt;code&gt;nvidia-smi&lt;/code&gt;这样的命令也是可以获取到GPU的基本信息的，但随着整个AI市场的发展和成熟，对于GPU的监控也越来越需要一套标准化的工具体系，也就是本篇文章讲的关于&lt;a href=&#34;https://developer.nvidia.com/dcgm&#34;&gt;DCGM&lt;/a&gt;相关的监控解决方案。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DCGM(Data Center GPU Manager)即数据中心GPU管理器，是一套用于在集群环境中管理和监视&lt;code&gt;Tesla™&lt;/code&gt;GPU的工具。&lt;/p&gt;

&lt;p&gt;它包括主动健康监控，全面诊断，系统警报以及包括电源和时钟管理在内的治理策略。&lt;/p&gt;

&lt;p&gt;它可以由系统管理员独立使用，并且可以轻松地集成到NVIDIA合作伙伴的集群管理，资源调度和监视产品中。&lt;/p&gt;

&lt;p&gt;DCGM简化了数据中心中的GPU管理，提高了资源可靠性和正常运行时间，自动化了管理任务，并有助于提高整体基础架构效率。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 虽然可以通过&lt;code&gt;nvidia-smi&lt;/code&gt;命令将相关的信息采集，并定期汇报到数据存储进行数据分析计算和展现，但是涉及到一整套的监控体系的整合，仍然需要使用方进行一些列的改造。因此这里，我们采用NVIDIA官方提供的DCGM方案来进行GPU数据采集，并通过声称下一代监控系统的Prometheus进行整个监控和告警的集成。&lt;/p&gt;

&lt;h3 id=&#34;dcgm工具部署&#34;&gt;DCGM工具部署&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ git clone https://github.com/NVIDIA/gpu-monitoring-tools.git

# 构建dcgm-exporter工具，其实就是nvidia官方对于nvidia-docker2.x推出的用于gpu数据监控的工具
# 最终会将gpu卡的metrics基本信息存储以metrics的数据格式存储到文件中
$ cd dcgm-exporter
# nvidia/dcgm-exporter:latest
$ make 

$ docker run -d --runtime=nvidia --rm --name=nvidia-dcgm-exporter nvidia/dcgm-exporter

# 查看dcgm-exporter收集到的gpu metrics数据
$ docker exec -it nvidia-dcgm-exporter tail -n 10  /run/prometheus/dcgm.prom
dcgm_ecc_dbe_aggregate_total{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 0
# HELP dcgm_retired_pages_sbe Total number of retired pages due to single-bit errors.
# TYPE dcgm_retired_pages_sbe counter
dcgm_retired_pages_sbe{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 0
# HELP dcgm_retired_pages_dbe Total number of retired pages due to double-bit errors.
# TYPE dcgm_retired_pages_dbe counter
dcgm_retired_pages_dbe{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 0
# HELP dcgm_retired_pages_pending Total number of pages pending retirement.
# TYPE dcgm_retired_pages_pending counter
dcgm_retired_pages_pending{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;dcgm-exporter采集指标项以及含义:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指标&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;dcgm_fan_speed_percent&lt;/td&gt;
&lt;td&gt;GPU 风扇转速占比（%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_sm_clock&lt;/td&gt;
&lt;td&gt;GPU sm 时钟(MHz)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_memory_clock&lt;/td&gt;
&lt;td&gt;GPU 内存时钟(MHz)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_gpu_temp&lt;/td&gt;
&lt;td&gt;GPU 运行的温度(℃)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_power_usage&lt;/td&gt;
&lt;td&gt;GPU 的功率（w）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_pcie_tx_throughput&lt;/td&gt;
&lt;td&gt;GPU PCIe TX传输的字节总数 （kb）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_pcie_rx_throughput&lt;/td&gt;
&lt;td&gt;GPU PCIe RX接收的字节总数   （kb）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_pcie_replay_counter&lt;/td&gt;
&lt;td&gt;GPU PCIe重试的总数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_gpu_utilization&lt;/td&gt;
&lt;td&gt;GPU 利用率（%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_mem_copy_utilization&lt;/td&gt;
&lt;td&gt;GPU 内存利用率（%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_enc_utilization&lt;/td&gt;
&lt;td&gt;GPU 编码器利用率 （%）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_dec_utilization&lt;/td&gt;
&lt;td&gt;GPU 解码器利用率 (%)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_xid_errors&lt;/td&gt;
&lt;td&gt;GPU 上一个xid错误的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_power_violation&lt;/td&gt;
&lt;td&gt;GPU 功率限制导致的节流持续时间(us)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_thermal_violation&lt;/td&gt;
&lt;td&gt;GPU 热约束节流持续时间(us)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_sync_boost_violation&lt;/td&gt;
&lt;td&gt;GPU 同步增强限制，限制持续时间(us)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_fb_free&lt;/td&gt;
&lt;td&gt;GPU fb（帧缓存）的剩余（MiB）&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;dcgm_fb_used&lt;/td&gt;
&lt;td&gt;GPU fb （帧缓存）的使用 （MiB）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实到这，dcgm已经完整的将我们需要的gpu的metrics数据采集出来了，并且是符合prometheus的数据格式和标准的，此时，我们可以根据实际的情况编写一个简单的api程序，将采集到的数据以api的形式暴露出去，就可以让整个prometheus server对各个gpu主机的metrics进行采集和监控。&lt;/p&gt;

&lt;p&gt;不过官方提供了基于kubernetes集群中pod方式的api接口，采用golang语言开发，具体使用情况可参考如下文档。&lt;/p&gt;

&lt;h3 id=&#34;prometheus-gpu-metrics-exporter&#34;&gt;prometheus gpu metrics exporter&lt;/h3&gt;

&lt;p&gt;在&lt;code&gt;gpu-monitoring-tools&lt;/code&gt;项目中，默认提供了一个&lt;code&gt;pod-gpu-metrics-exporter&lt;/code&gt;模块，用于在kubernetes集群中的gpu-metrics的部署，官方的示例步骤如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;nvidia-k8s-device-plugin&lt;/li&gt;
&lt;li&gt;Deploy GPU Pods&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在使kubernetes集群中部署的前提是你的GPU要托管在k8s集群内部，这也就意味着你得先成功将带GPU的主机成功托管到集群中，并且能够调度GPU资源&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 创建一个监控的命名空间
# Create the monitoring namespace
$ kubectl create namespace monitoring

# Add gpu metrics endpoint to prometheus
$ kubectl create -f prometheus/prometheus-configmap.yaml

# Deploy prometheus
$ kubectl create -f prometheus/prometheus-deployment.yaml

$ kubectl create -f pod-gpu-metrics-exporter-daemonset.yaml

# Open in browser: localhost:9090

# 具体的docker镜像构建和运行
# 依然是gpu-monitoring-tools项目
$ cd  pod-gpu-metrics-exporter
$ docker build -t pod-gpu-metrics-exporter .

# 运行dcgm-exporter
$ docker run -d --runtime=nvidia --rm --name=nvidia-dcgm-exporter nvidia/dcgm-exporter

# 运行gpu-metrics-exporter
$ docker run -d --privileged --rm -p 9400:9400 -v /var/lib/kubelet/pod-resources:/var/lib/kubelet/pod-resources --volumes-from nvidia-dcgm-exporter:ro nvidia/pod-gpu-metrics-exporter:v1.0.0-alpha

# 此时就将上述的那个dcgm-exporter中采集到数据成功暴露到对外的接口了
$ curl -s localhost:9400/gpu/metrics&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要注意的是，在&lt;code&gt;gpu-metrics-exporter&lt;/code&gt;的程序中，是针对pod的方式来采集gpu的metrics的信息，并且附带了pod本身的基本信息，因此如果你的&lt;code&gt;gpu&lt;/code&gt;主机还未在kubernetes集群中托管，官方提供的镜像可能并不能使用，需要对&lt;code&gt;src/http.go&lt;/code&gt;文件中采集的路径进行改变，将默认的&lt;code&gt;gpuPodMetrics&lt;/code&gt;改成&lt;code&gt;gpuMetrics&lt;/code&gt;即可，两者会去读取不同的dcgm-exporter暴露出来的metrics文件，否则访问api接口时会发现无法找到metrics文件.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func getGPUmetrics(resp http.ResponseWriter, req *http.Request) {
	//metrics, err := ioutil.ReadFile(gpuPodMetrics)
	metrics, err := ioutil.ReadFile(gpuMetrics)
	if err != nil {
		http.Error(resp, err.Error(), http.StatusInternalServerError)
		glog.Errorf(&amp;#34;error responding to %v%v: %v&amp;#34;, req.Host, req.URL, err.Error())
		return
	}
	resp.Write(metrics)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;参考&lt;a href=&#34;https://github.com/BGBiao/gpu-monitoring-tools/tree/master/gpu-metrics-exporter&#34;&gt;gpu-metrics-exporter&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;图省事的，可以直接下载如下两个镜像，在已经work 的GPU主机上直接运行.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;dcgm-exporter: &lt;code&gt;docker pull bgbiao/dcgm-exporter:latest&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;gpu-metrics-exporter: &lt;code&gt;docker pull bgbiao/gpu-metrics-exporter:latest&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 确定dcgm-exporter是运行的
$ docker run -d --runtime=nvidia --rm --name=nvidia-dcgm-exporter bgbiao/dcgm-exporter

$ docker run -d --privileged --rm -p 9400:9400  --volumes-from nvidia-dcgm-exporter:ro bgbiao/gpu-metrics-exporter

# 检查gpu暴露出来的基础信息
$ curl -s localhost:9400/gpu/metrics
dcgm_ecc_dbe_aggregate_total{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 0
....
....&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;prometheus采集&#34;&gt;prometheus采集&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 有了上述的gpu-metrics-exporter之后，我们的gpu相关的运行数据就可以以premetheus兼容的方式获取了，此时在prometheus-server上配置，去定期pull 数据即可，我们的prometheus-server目前部署在kubernetes集群内部，因此这里分享将gpu的数据采集到kubernetes集群内部的prometheus中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建endpoint以及对应的service&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# gpu-metrics的endpoint和service配置

$ cat endpoint-gpus.yaml
apiVersion: v1
kind: Endpoints
metadata:
  name: gpu-metrics
  namespace: monitoring
  labels:
    app: gpu-metrics
subsets:
- addresses:
  - ip: 172.16.65.234
  ports:
  - port: 9400
    name: http-metrics
    protocol: TCP
---
apiVersion: v1
kind: Service
metadata:
  namespace: monitoring
  name: gpu-metrics
  labels:
    app: gpu-metrics
spec:
  ports:
  - name: http-metrics
    port: 19400
    targetPort: 9400
    protocol: TCP

$ kubectl  apply -f endpoint-gpus.yaml

# 查看创建的相关资源
$ kubectl  get ep,svc -n monitoring  -l app=gpu-metrics
NAME                    ENDPOINTS            AGE
endpoints/gpu-metrics   172.16.65.234:9400   5m24s

NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)     AGE
service/gpu-metrics   ClusterIP   10.253.138.97   &amp;lt;none&amp;gt;        19400/TCP   5m24s

# 测试service暴露的端点
# 确保集群内部可以访问service暴露出来的endpoint即可

$ curl 10.253.138.97:19400/gpu/metrics
# HELP dcgm_sm_clock SM clock frequency (in MHz).
# TYPE dcgm_sm_clock gauge
dcgm_sm_clock{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 1328
# HELP dcgm_memory_clock Memory clock frequency (in MHz).
# TYPE dcgm_memory_clock gauge
dcgm_memory_clock{gpu=&amp;#34;0&amp;#34;,uuid=&amp;#34;GPU-b91e30ac-fe77-e236-11ea-078bc2d1f226&amp;#34;} 715&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;创建prometheus抓取数据的规则&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ cat prometheus-gpus.yml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  labels:
    app: gpu-metrics
  name: gpu-metrics
  namespace: monitoring
spec:
  # 对应的端点是上面创建的svc的ports
  endpoints:
    # 定义endpoint采集的时间和采集的URI
  - interval: 30s
    port: http-metrics
    path: /gpu/metrics
  jobLabel: app
  # 匹配monitoring命名空间的app=gpu-metrics的svc
  namespaceSelector:
    matchNames:
    - monitoring
  selector:
    matchLabels:
      app: gpu-metrics

$ kubectl  apply -f prometheus-gpus.yml
servicemonitor.monitoring.coreos.com/gpu-metrics created

$ kubectl  get servicemonitor  -n monitoring gpu-metrics
NAME          AGE
gpu-metrics   69s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当上述资源创建完成后，在集群内部的prometheus-server中就可以找到对应的target，确认状态为up即表示prometheus已正常采集集群外gpu的metrics数据了，接下来数据就会以30s为间隔，源源不断的将数据采集到prometheus存储中.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdiuxv5l47j31pk0aegon.jpg&#34; alt=&#34;prometheus-gpu-targets&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gpu监控信息的展示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;到这里，我们已经到万里长征的最后一步了，就是把prometheus中gpu的监控数据用grafana展示出来，以实时去分析一些gpu的基本数据。&lt;/p&gt;

&lt;p&gt;在grafana官网中，已经有大佬制作了gpu监控的相关模板，比如&lt;code&gt;[GPU-Nodes-Metrics](https://grafana.com/grafana/dashboards/12027)&lt;/code&gt;,因此，对于我们使用者来说，在grafana的面板中，将该模板导入即可使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdiv4s5t9nj30ec0ek0tc.jpg&#34; alt=&#34;选择导入方式创建&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdj0dzwdmjj31ly0u041p.jpg&#34; alt=&#34;指定模板(dashboard id或json)&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdj0ftc6d8j31nd0u0djg.jpg&#34; alt=&#34;注意:确认prometheus库正确后即可导入&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gdj0h15tp5j31oi0u0n5x.jpg&#34; alt=&#34;最终的GPU监控图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考项目&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/NVIDIA/gpu-monitoring-tools&#34;&gt;gpu-monitor-tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://grafana.com/grafana/dashboards/11752&#34;&gt;gpu-metrics-grafana&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>构建更小Docker镜像的一些建议</title>
      <link>https://bgbiao.top/post/%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%B0%8Fdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Sun, 22 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E6%9E%84%E5%BB%BA%E6%9B%B4%E5%B0%8Fdocker%E9%95%9C%E5%83%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BB%BA%E8%AE%AE/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 前两天在群里看到有人提到说，自己构建了一个镜像，明明就只往base镜像中增加了tomcat，但是构建好的镜像大小最终却是两倍的tomcat包的大小，最后看到Dockerfile后才发现作者在把tomcat包拷贝进去之后，又使用&lt;code&gt;RUN&lt;/code&gt;指令，执行了一次&lt;code&gt;chmod a+x tomcat&lt;/code&gt;，我想说，这么搞镜像不大那是不可能的。另外一件事就是前段时间，同事说让搞一个公司级别的base镜像，要稳定并且尽量小，借着这两个事，和大家分享几点Docker镜像相关的事情。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，镜像的大小最终取决于如下几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.业务需求和debug的便利性(比如科学计算和普通的java或者golang程序)&lt;/li&gt;
&lt;li&gt;2.业务镜像构建的依赖特性(构建过程和交付物的依赖关系)&lt;/li&gt;
&lt;li&gt;3.交付物的定义过程(Dockerfile分层过程中的变更层)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;接下来，从三个点来谈谈我个人的想法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、单从镜像大小的角度考虑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果仅从镜像的大小角度来讲，为了镜像尽可能的小，有如下的base镜像可供选择:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;alpine: 专为容器而生的基础镜像，缺点是默认使用的&lt;code&gt;musl libc&lt;/code&gt;，但是大多数运行在Linux下的程序几乎都是&lt;code&gt;glibc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;scratch: 没有任何&lt;code&gt;杂念&lt;/code&gt;的基础镜像，优点就是没有杂念，缺点也明显就是各种动态链接库，shell等等都没有(所以对应静态依赖的程序还是可以的)&lt;/li&gt;
&lt;li&gt;busybox: 基本也是一个没有太多&lt;code&gt;杂念&lt;/code&gt;的基础镜像，不过生态里包含了很多依赖镜像，比如&lt;code&gt;busybox:glibc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;centos: centos发行版的mini镜像，基础的库和工具包基本都有，base稍微大了点(200M左右吧,不过也可以精简)&lt;/li&gt;
&lt;li&gt;ubuntu: ubuntu发现版的mini镜像，同上，base大概在120M左右，不过两者的稳定性和包的管理有差异&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但以上几种的base均有利弊，而且企业内部通常业务场景也会有一定的变化，因此我们在维护内部的基础base镜像时一般不会为了&lt;code&gt;镜像小&lt;/code&gt;这个伪目标而使用多种base来构建不同镜像，主要是考虑到后期的维护成本较高(稳定性，可操作性).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、考虑业务的需求和debug的便利性&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;java: 程序依赖基本包含在程序中，仅对java依赖&lt;/li&gt;
&lt;li&gt;c: 可能需要指定的libc库以及动态链接库的依赖&lt;/li&gt;
&lt;li&gt;golang: 编译好的程序几乎不需要依赖&lt;/li&gt;
&lt;li&gt;python: 需要依赖python以及各个库的支持，同时库可能依赖系统的动态链接库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常在企业环境中，系统不可能长期只有一种语言来开发，因此不同语言生态下也就诞生了不同的需求。&lt;/p&gt;

&lt;p&gt;比如，当下不论是&lt;code&gt;DL(Deep Learning)&lt;/code&gt;还是&lt;code&gt;ML(Machine Learning)&lt;/code&gt;大部分对外的库基本都是使用Python开发的，因此在这种场景下，通常业务所需要的基础库是相当大，几个G的竟像也是司空见惯的。&lt;/p&gt;

&lt;p&gt;同时，还有一个比较常见的情况，就是我们的技术人员都有可能去容器内部进行简单的debug操作(比如使用curl,netstat等工具)，此时不同的base镜像会包含不同的生态工具，无疑也会增加大家的学习成本，如果对外推广可能会遭遇一定障碍。&lt;/p&gt;

&lt;p&gt;最后，还有一个点就是业务上层的base竟像的精简化。&lt;/p&gt;

&lt;p&gt;很多时候base环境内部可能存在一些基本工具，仅是程序构建时需要的工具，比如c程序的gcc,golang程序的go,java程序的jdk(其实仅jre就可以)，因此为了进一步减少空间，可以将构建过程相关的工具阉割掉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、交付物的定义过程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在传统的CI/CD流水线中，交付物通常是一个静态的压缩包，而在引入以Docker为代表的容器技术之后，交付物就是包含业务代码和其运行时环境的镜像，因此在交付物的定义过程中也可以做一些镜像精简的优化。&lt;/p&gt;

&lt;p&gt;这里主要是Docker的分层思想，在开源的容器市场中，基于&lt;code&gt;overlay&lt;/code&gt;的存储引擎已经是不争的事实，所以，我们可以在分层过程中进行一些优化，对overlay不太了解的可以阅读以前的一篇文章&lt;a href=&#34;https://www.jianshu.com/p/959e8e3da4b2&#34;&gt;overlayfs的探究以及在docker的使用&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;FROM golang as golang-build
WORKDIR /
COPY hello.go .
RUN go build -ldflags &amp;#34;-s -w&amp;#34; -o hello hello.go

FROM alpine
COPY --from=golang-build hello .
RUN chmod a-x hello &amp;amp;&amp;amp; chmod a+x hello
CMD [&amp;#34;./hello&amp;#34;]&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们知道，在分层的思想中，每一层都是上一层的可写叠加，而在最新层变更的文件才是整个镜像或者容器增加的数据，所以如上的Dockerfile中，我们在&lt;code&gt;RUN&lt;/code&gt;指令中增加了权限的操作(仅用来说明问题)，你会发现，最终的镜像会比不加&lt;code&gt;RUN&lt;/code&gt;指令整整大了一个&lt;code&gt;hello&lt;/code&gt;程序的空间，这其实就是镜像分层中的一个优化点。&lt;/p&gt;

&lt;p&gt;所以，在企业内部进行容器化改造和上线时，除了需要考虑各个适用方的场景问题和操作便利性，同时在构建过程中也需要进行一定的把控。&lt;/p&gt;

&lt;p&gt;当然啦，尽可能的将镜像压缩到最小，不仅可以减少磁盘的使用，同时在大规模分发镜像时也会表现的相对有效率，但在实际使用过程中，并不是所有的镜像越小越好，同时我们需要在镜像的通用性和可维护性上进行一定权重的考量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>使用jwt-go验证API</title>
      <link>https://bgbiao.top/post/golang-jwt%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sun, 15 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/golang-jwt%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;背景: 在如今前后端分离开发的大环境中，我们需要解决一些登陆，后期身份认证以及鉴权相关的事情，通常的方案就是采用请求头携带token的方式进行实现。本篇文章主要分享下在Golang语言下使用&lt;a href=&#34;https://github.com/dgrijalva/jwt-go&#34;&gt;jwt-go&lt;/a&gt;来实现后端的token认证逻辑。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;JSON Web Token(JWT)&lt;/code&gt;是一个常用语HTTP的客户端和服务端间进行身份认证和鉴权的标准规范，使用JWT可以允许我们在用户和服务器之间传递安全可靠的信息。&lt;/p&gt;

&lt;p&gt;在开始学习&lt;a href=&#34;https://jwt.io/&#34;&gt;JWT&lt;/a&gt;之前，我们可以先了解下早期的几种方案。&lt;/p&gt;

&lt;h3 id=&#34;token-cookie-session的区别&#34;&gt;token、cookie、session的区别&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Cookie总是保存在客户端中，按在客户端中的存储位置，可分为&lt;code&gt;内存Cookie&lt;/code&gt;和&lt;code&gt;硬盘Cookie&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为&lt;code&gt;非持久Cookie和持久Cookie&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cookie由服务器生成，发送给浏览器&lt;/code&gt;，浏览器把cookie以key-value形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Session&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Session字面意思是会话，主要用来标识自己的身份。比如在无状态的api服务在多次请求数据库时，如何知道是同一个用户，这个就可以通过session的机制，服务器要知道当前发请求给自己的是谁&lt;/p&gt;

&lt;p&gt;为了区分客户端请求，&lt;code&gt;服务端会给具体的客户端生成身份标识session&lt;/code&gt;，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。&lt;/p&gt;

&lt;p&gt;至于客户端如何保存该标识，可以有很多方式，对于浏览器而言，一般都是使用&lt;code&gt;cookie&lt;/code&gt;的方式&lt;/p&gt;

&lt;p&gt;服务器使用session把用户信息临时保存了服务器上，用户离开网站就会销毁，这种凭证存储方式相对于cookie来说更加安全，但是session会有一个缺陷: 如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。&lt;/p&gt;

&lt;p&gt;因此，通常企业里会使用&lt;code&gt;redis,memcached&lt;/code&gt;缓存中间件来实现session的共享，此时web服务器就是一个完全无状态的存在，所有的用户凭证可以通过共享session的方式存取，当前session的过期和销毁机制需要用户做控制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Token&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;token的意思是“令牌”，是用户身份的验证方式，最简单的token组成: &lt;code&gt;uid(用户唯一标识)&lt;/code&gt;+&lt;code&gt;time(当前时间戳)&lt;/code&gt;+&lt;code&gt;sign(签名,由token的前几位+盐以哈希算法压缩成一定长度的十六进制字符串)&lt;/code&gt;，同时还可以将不变的参数也放进token&lt;/p&gt;

&lt;p&gt;这里我们主要想讲的就是&lt;code&gt;Json Web Token&lt;/code&gt;，也就是本篇的主题:JWT&lt;/p&gt;

&lt;h3 id=&#34;json-web-token-jwt-介绍&#34;&gt;Json-Web-Token(JWT)介绍&lt;/h3&gt;

&lt;p&gt;一般而言，用户注册登陆后会生成一个jwt token返回给浏览器，浏览器向服务端请求数据时携带&lt;code&gt;token&lt;/code&gt;，服务器端使用&lt;code&gt;signature&lt;/code&gt;中定义的方式进行解码，进而对token进行解析和验证。&lt;/p&gt;

&lt;h4 id=&#34;jwt-token组成部分&#34;&gt;JWT Token组成部分&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpwngvonhj30hx03xwf0.jpg&#34; alt=&#34;JWT-Token组成部分&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;header: 用来指定使用的算法(HMAC SHA256 RSA)和token类型(如JWT)&lt;/li&gt;
&lt;li&gt;payload: 包含声明(要求)，声明通常是用户信息或其他数据的声明，比如用户id，名称，邮箱等. 声明可分为三种: registered,public,private&lt;/li&gt;
&lt;li&gt;signature: 用来保证JWT的真实性，可以使用不同的算法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;header&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{
    &amp;#34;alg&amp;#34;: &amp;#34;HS256&amp;#34;,
    &amp;#34;typ&amp;#34;: &amp;#34;JWT&amp;#34;
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对上面的json进行base64编码即可得到JWT的第一个部分&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;payload&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;registered claims: 预定义的声明，通常会放置一些预定义字段，比如过期时间，主题等(iss:issuer,exp:expiration time,sub:subject,aud:audience)&lt;/li&gt;
&lt;li&gt;public claims: 可以设置公开定义的字段&lt;/li&gt;

&lt;li&gt;&lt;p&gt;private claims: 用于统一使用他们的各方之间的共享信息&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;{
&amp;#34;sub&amp;#34;: &amp;#34;xxx-api&amp;#34;,
&amp;#34;name&amp;#34;: &amp;#34;bgbiao.top&amp;#34;,
&amp;#34;admin&amp;#34;: true
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对payload部分的json进行base64编码后即可得到JWT的第二个部分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 不要在header和payload中放置敏感信息，除非信息本身已经做过脱敏处理&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;signature&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了得到签名部分，必须有编码过的header和payload，以及一个秘钥，签名算法使用header中指定的那个，然后对其进行签名即可&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HMACSHA256(base64UrlEncode(header)+&amp;quot;.&amp;quot;+base64UrlEncode(payload),secret)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;签名是&lt;code&gt;用于验证消息在传递过程中有没有被更改&lt;/code&gt;，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;https://jwt.io&#34;&gt;jwt.io&lt;/a&gt;网站中，提供了一些JWT token的编码，验证以及生成jwt的工具。&lt;/p&gt;

&lt;p&gt;下图就是一个典型的jwt-token的组成部分。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpxe1ungej30wq0mygo8.jpg&#34; alt=&#34;jwt官方签名结构&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;什么时候用jwt&#34;&gt;什么时候用JWT&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Authorization(授权): 典型场景，用户请求的token中包含了该令牌允许的路由，服务和资源。单点登录其实就是现在广泛使用JWT的一个特性&lt;/li&gt;
&lt;li&gt;Information Exchange(信息交换):  对于安全的在各方之间传输信息而言，JSON Web Tokens无疑是一种很好的方式.因为JWTs可以被签名，例如，用公钥/私钥对，你可以确定发送人就是它们所说的那个人。另外，由于签名是使用头和有效负载计算的，您还可以验证内容没有被篡改&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;jwt-json-web-tokens-是如何工作的&#34;&gt;JWT(Json Web Tokens)是如何工作的&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcptxpqcrxj30ct0bsq3h.jpg&#34; alt=&#34;JWT认证过程&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以，基本上整个过程分为两个阶段，第一个阶段，客户端向服务端获取token，第二阶段，客户端带着该token去请求相关的资源.&lt;/p&gt;

&lt;p&gt;通常比较重要的是，服务端如何根据指定的规则进行token的生成。&lt;/p&gt;

&lt;p&gt;在认证的时候，当用户用他们的凭证成功登录以后，一个JSON Web Token将会被返回。&lt;/p&gt;

&lt;p&gt;此后，token就是用户凭证了，你必须非常小心以防止出现安全问题。&lt;/p&gt;

&lt;p&gt;一般而言，你保存令牌的时候不应该超过你所需要它的时间。&lt;/p&gt;

&lt;p&gt;无论何时用户想要访问受保护的路由或者资源的时候，用户代理（通常是浏览器）都应该带上JWT，典型的，通常放在Authorization header中，用Bearer schema:
&lt;code&gt;Authorization: Bearer &amp;lt;token&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;服务器上的受保护的路由将会检查Authorization header中的JWT是否有效，如果有效，则用户可以访问受保护的资源。如果JWT包含足够多的必需的数据，那么就可以减少对某些操作的数据库查询的需要，尽管可能并不总是如此。&lt;/p&gt;

&lt;p&gt;如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpxi6z1dmj315o0fvab0.jpg&#34; alt=&#34;获取JWT以及访问APIs以及资源&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;客户端向授权接口请求授权&lt;/li&gt;
&lt;li&gt;服务端授权后返回一个access token给客户端&lt;/li&gt;
&lt;li&gt;客户端使用access token访问受保护的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;基于token的身份认证和基于服务器的身份认证&#34;&gt;基于Token的身份认证和基于服务器的身份认证&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;1.基于服务器的认证&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面说到过session，cookie以及token的区别，在之前传统的做法就是基于存储在服务器上的session来做用户的身份认证，但是通常会有如下问题:
- Sessions: 认证通过后需要将用户的session数据保存在内存中，随着认证用户的增加，内存开销会大
- 扩展性: 由于session存储在内存中，扩展性会受限，虽然后期可以使用redis,memcached来缓存数据
- CORS: 当多个终端访问同一份数据时，可能会遇到禁止请求的问题
- CSRF: 用户容易受到CSRF攻击&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.Session和JWT Token的异同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;都可以存储用户相关信息，但是session存储在服务端，JWT存储在客户端&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcpxunv5qcj30dd0gfgmp.jpg&#34; alt=&#34;session和jwt数据存储位置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.基于Token的身份认证如何工作&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于Token的身份认证是无状态的，服务器或者session中不会存储任何用户信息.(很好的解决了共享session的问题)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户携带用户名和密码请求获取token(接口数据中可使用appId,appKey)&lt;/li&gt;
&lt;li&gt;服务端校验用户凭证，并返回用户或客户端一个Token&lt;/li&gt;
&lt;li&gt;客户端存储token,并在请求头中携带Token&lt;/li&gt;
&lt;li&gt;服务端校验token并返回数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;
- 随后客户端的每次请求都需要使用token
- token应该放在header中
- 需要将服务器设置为接收所有域的请求: &lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.用Token的好处&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;无状态和可扩展性&lt;/li&gt;
&lt;li&gt;安全: 防止CSRF攻击;token过期重新认证&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5.JWT和OAuth的区别&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.OAuth2是一种授权框架 ，JWT是一种认证协议&lt;/li&gt;
&lt;li&gt;2.无论使用哪种方式切记用HTTPS来保证数据的安全性&lt;/li&gt;
&lt;li&gt;3.OAuth2用在&lt;code&gt;使用第三方账号登录的情况&lt;/code&gt;(比如使用weibo, qq, github登录某个app)，而&lt;code&gt;JWT是用在前后端分离&lt;/code&gt;, 需要简单的对后台API进行保护时使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用gin框架集成jwt&#34;&gt;使用Gin框架集成JWT&lt;/h3&gt;

&lt;p&gt;在Golang语言中，&lt;a href=&#34;https://github.com/dgrijalva/jwt-go&#34;&gt;jwt-go&lt;/a&gt;库提供了一些jwt编码和验证的工具，因此我们很容易使用该库来实现token认证。&lt;/p&gt;

&lt;p&gt;另外，我们也知道&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;gin&lt;/a&gt;框架中支持用户自定义middleware，我们可以很好的将jwt相关的逻辑封装在middleware中，然后对具体的接口进行认证。&lt;/p&gt;

&lt;h4 id=&#34;自定义中间件&#34;&gt;自定义中间件&lt;/h4&gt;

&lt;p&gt;在gin框架中，自定义中间件比较容易，只要返回一个&lt;code&gt;gin.HandlerFunc&lt;/code&gt;即完成一个中间件定义。&lt;/p&gt;

&lt;p&gt;接下来，我们先定义一个用于jwt认证的中间件.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 定义一个JWTAuth的中间件
func JWTAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 通过http header中的token解析来认证
		token := c.Request.Header.Get(&amp;#34;token&amp;#34;)
		if token == &amp;#34;&amp;#34; {
			c.JSON(http.StatusOK, gin.H{
				&amp;#34;status&amp;#34;: -1,
				&amp;#34;msg&amp;#34;:    &amp;#34;请求未携带token，无权限访问&amp;#34;,
				&amp;#34;data&amp;#34;:   nil,
			})
			c.Abort()
			return
		}

		log.Print(&amp;#34;get token: &amp;#34;, token)

		// 初始化一个JWT对象实例，并根据结构体方法来解析token
		j := NewJWT()
		// 解析token中包含的相关信息(有效载荷)
		claims, err := j.ParserToken(token)

		if err != nil {
			// token过期
			if err == TokenExpired {
				c.JSON(http.StatusOK, gin.H{
					&amp;#34;status&amp;#34;: -1,
					&amp;#34;msg&amp;#34;:    &amp;#34;token授权已过期，请重新申请授权&amp;#34;,
					&amp;#34;data&amp;#34;:   nil,
				})
				c.Abort()
				return
			}
			// 其他错误
			c.JSON(http.StatusOK, gin.H{
				&amp;#34;status&amp;#34;: -1,
				&amp;#34;msg&amp;#34;:    err.Error(),
				&amp;#34;data&amp;#34;:   nil,
			})
			c.Abort()
			return
		}

		// 将解析后的有效载荷claims重新写入gin.Context引用对象中
		c.Set(&amp;#34;claims&amp;#34;, claims)

	}
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;定义jwt编码和解码逻辑&#34;&gt;定义jwt编码和解码逻辑&lt;/h4&gt;

&lt;p&gt;根据前面提到的jwt-token的组成部分，以及&lt;code&gt;jwt-go&lt;/code&gt;中相关的定义，我们可以使用如下方法进行生成token.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 定义一个jwt对象
type JWT struct {
	// 声明签名信息
	SigningKey []byte
}

// 初始化jwt对象
func NewJWT() *JWT {
	return &amp;amp;JWT{
		[]byte(&amp;#34;bgbiao.top&amp;#34;),
	}
}

// 自定义有效载荷(这里采用自定义的Name和Email作为有效载荷的一部分)
type CustomClaims struct {
	Name  string `json:&amp;#34;name&amp;#34;`
	Email string `json:&amp;#34;email&amp;#34;`
	// StandardClaims结构体实现了Claims接口(Valid()函数)
	jwt.StandardClaims
}


// 调用jwt-go库生成token
// 指定编码的算法为jwt.SigningMethodHS256
func (j *JWT) CreateToken(claims CustomClaims) (string, error) {
	// https://gowalker.org/github.com/dgrijalva/jwt-go#Token
	// 返回一个token的结构体指针
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString(j.SigningKey)
}


// token解码
func (j *JWT) ParserToken(tokenString string) (*CustomClaims, error) {
	// https://gowalker.org/github.com/dgrijalva/jwt-go#ParseWithClaims
	// 输入用户自定义的Claims结构体对象,token,以及自定义函数来解析token字符串为jwt的Token结构体指针
	// Keyfunc是匿名函数类型: type Keyfunc func(*Token) (interface{}, error)
	// func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {}
	token, err := jwt.ParseWithClaims(tokenString, &amp;amp;CustomClaims{}, func(token *jwt.Token) (interface{}, error) {
		return j.SigningKey, nil
	})

	if err != nil {
		// https://gowalker.org/github.com/dgrijalva/jwt-go#ValidationError
		// jwt.ValidationError 是一个无效token的错误结构
		if ve, ok := err.(*jwt.ValidationError); ok {
			// ValidationErrorMalformed是一个uint常量，表示token不可用
			if ve.Errors&amp;amp;jwt.ValidationErrorMalformed != 0 {
				return nil, fmt.Errorf(&amp;#34;token不可用&amp;#34;)
				// ValidationErrorExpired表示Token过期
			} else if ve.Errors&amp;amp;jwt.ValidationErrorExpired != 0 {
				return nil, fmt.Errorf(&amp;#34;token过期&amp;#34;)
				// ValidationErrorNotValidYet表示无效token
			} else if ve.Errors&amp;amp;jwt.ValidationErrorNotValidYet != 0 {
				return nil, fmt.Errorf(&amp;#34;无效的token&amp;#34;)
			} else {
				return nil, fmt.Errorf(&amp;#34;token不可用&amp;#34;)
			}

		}
	}

	// 将token中的claims信息解析出来并断言成用户自定义的有效载荷结构
	if claims, ok := token.Claims.(*CustomClaims); ok &amp;amp;&amp;amp; token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf(&amp;#34;token无效&amp;#34;)

}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;定义登陆验证逻辑&#34;&gt;定义登陆验证逻辑&lt;/h4&gt;

&lt;p&gt;接下来的部分就是普通api的具体逻辑了，比如可以在登陆时进行用户校验，成功后未该次认证请求生成token。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 定义登陆逻辑
// model.LoginReq中定义了登陆的请求体(name,passwd)
func Login(c *gin.Context) {
	var loginReq model.LoginReq
	if c.BindJSON(&amp;amp;loginReq) == nil {
		// 登陆逻辑校验(查库，验证用户是否存在以及登陆信息是否正确)
		isPass, user, err := model.LoginCheck(loginReq)
		// 验证通过后为该次请求生成token
		if isPass {
			generateToken(c, user)
		} else {
			c.JSON(http.StatusOK, gin.H{
				&amp;#34;status&amp;#34;: -1,
				&amp;#34;msg&amp;#34;:    &amp;#34;验证失败&amp;#34; + err.Error(),
				&amp;#34;data&amp;#34;:   nil,
			})
		}

	} else {
		c.JSON(http.StatusOK, gin.H{
			&amp;#34;status&amp;#34;: -1,
			&amp;#34;msg&amp;#34;:    &amp;#34;用户数据解析失败&amp;#34;,
			&amp;#34;data&amp;#34;:   nil,
		})
	}
}

// token生成器
// md 为上面定义好的middleware中间件
func generateToken(c *gin.Context, user model.User) {
	// 构造SignKey: 签名和解签名需要使用一个值
	j := md.NewJWT()

	// 构造用户claims信息(负荷)
	claims := md.CustomClaims{
		user.Name,
		user.Email,
		jwtgo.StandardClaims{
			NotBefore: int64(time.Now().Unix() - 1000), // 签名生效时间
			ExpiresAt: int64(time.Now().Unix() + 3600), // 签名过期时间
			Issuer:    &amp;#34;bgbiao.top&amp;#34;,                    // 签名颁发者
		},
	}

	// 根据claims生成token对象
	token, err := j.CreateToken(claims)

	if err != nil {
		c.JSON(http.StatusOK, gin.H{
			&amp;#34;status&amp;#34;: -1,
			&amp;#34;msg&amp;#34;:    err.Error(),
			&amp;#34;data&amp;#34;:   nil,
		})
	}

	log.Println(token)
	// 封装一个响应数据,返回用户名和token
	data := LoginResult{
		Name:  user.Name,
		Token: token,
	}

	c.JSON(http.StatusOK, gin.H{
		&amp;#34;status&amp;#34;: 0,
		&amp;#34;msg&amp;#34;:    &amp;#34;登陆成功&amp;#34;,
		&amp;#34;data&amp;#34;:   data,
	})
	return

}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;定义普通待验证接口&#34;&gt;定义普通待验证接口&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 定义一个普通controller函数，作为一个验证接口逻辑
func GetDataByTime(c *gin.Context) {
	// 上面我们在JWTAuth()中间中将&amp;#39;claims&amp;#39;写入到gin.Context的指针对象中，因此在这里可以将之解析出来
	claims := c.MustGet(&amp;#34;claims&amp;#34;).(*md.CustomClaims)
	if claims != nil {
		c.JSON(http.StatusOK, gin.H{
			&amp;#34;status&amp;#34;: 0,
			&amp;#34;msg&amp;#34;:    &amp;#34;token有效&amp;#34;,
			&amp;#34;data&amp;#34;:   claims,
		})
	}
}


// 在主函数中定义路由规则
	router := gin.Default()
	v1 := router.Group(&amp;#34;/apis/v1/&amp;#34;)
	{
		v1.POST(&amp;#34;/register&amp;#34;, controller.RegisterUser)
		v1.POST(&amp;#34;/login&amp;#34;, controller.Login)
	}

	// secure v1
	sv1 := router.Group(&amp;#34;/apis/v1/auth/&amp;#34;)
	// 加载自定义的JWTAuth()中间件,在整个sv1的路由组中都生效
	sv1.Use(md.JWTAuth())
	{
		sv1.GET(&amp;#34;/time&amp;#34;, controller.GetDataByTime)

	}
	router.Run(&amp;#34;:8081&amp;#34;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;验证使用jwt后的接口&#34;&gt;验证使用JWT后的接口&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 运行项目
$ go run main.go
127.0.0.1
13306
root:bgbiao.top@tcp(127.0.0.1:13306)/test_api?charset=utf8mb4&amp;amp;parseTime=True&amp;amp;loc=Local
[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.

[GIN-debug] [WARNING] Running in &amp;#34;debug&amp;#34; mode. Switch to &amp;#34;release&amp;#34; mode in production.
 - using env:	export GIN_MODE=release
 - using code:	gin.SetMode(gin.ReleaseMode)

[GIN-debug] POST   /apis/v1/register         --&amp;gt; warnning-trigger/controller.RegisterUser (3 handlers)
[GIN-debug] POST   /apis/v1/login            --&amp;gt; warnning-trigger/controller.Login (3 handlers)
[GIN-debug] GET    /apis/v1/auth/time        --&amp;gt; warnning-trigger/controller.GetDataByTime (4 handlers)
[GIN-debug] Listening and serving HTTP on :8081

# 注册用户
$ curl -i -X POST \
   -H &amp;#34;Content-Type:application/json&amp;#34; \
   -d \
&amp;#39;{
  &amp;#34;name&amp;#34;: &amp;#34;hahaha1&amp;#34;,
  &amp;#34;password&amp;#34;: &amp;#34;hahaha1&amp;#34;,
  &amp;#34;email&amp;#34;: &amp;#34;hahaha1@bgbiao.top&amp;#34;,
  &amp;#34;phone&amp;#34;: 10000000000
}&amp;#39; \
 &amp;#39;http://localhost:8081/apis/v1/register&amp;#39;
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sun, 15 Mar 2020 07:09:28 GMT
Content-Length: 41

{&amp;#34;data&amp;#34;:null,&amp;#34;msg&amp;#34;:&amp;#34;success &amp;#34;,&amp;#34;status&amp;#34;:0}%


# 登陆用户以获取token
$ curl -i -X POST \
   -H &amp;#34;Content-Type:application/json&amp;#34; \
   -d \
&amp;#39;{
  &amp;#34;name&amp;#34;:&amp;#34;hahaha1&amp;#34;,
  &amp;#34;password&amp;#34;:&amp;#34;hahaha1&amp;#34;
}&amp;#39; \
 &amp;#39;http://localhost:8081/apis/v1/login&amp;#39;
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Date: Sun, 15 Mar 2020 07:10:41 GMT
Content-Length: 290

{&amp;#34;data&amp;#34;:{&amp;#34;token&amp;#34;:&amp;#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;hahaha1&amp;#34;},&amp;#34;msg&amp;#34;:&amp;#34;登陆成功&amp;#34;,&amp;#34;status&amp;#34;:0}


# 访问需要认证的接口
# 因为我们对/apis/v1/auth/的分组路由中加载了jwt的middleware，因此该分组下的api都需要使用jwt-token认证
$ curl http://localhost:8081/apis/v1/auth/time
{&amp;#34;data&amp;#34;:null,&amp;#34;msg&amp;#34;:&amp;#34;请求未携带token，无权限访问&amp;#34;,&amp;#34;status&amp;#34;:-1}%

# 使用token认证
$ curl http://localhost:8081/apis/v1/auth/time -H &amp;#39;token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6ImhhaGFoYTEiLCJlbWFpbCI6ImhhaGFoYTFAYmdiaWFvLnRvcCIsImV4cCI6MTU4NDI1OTg0MSwiaXNzIjoiYmdiaWFvLnRvcCIsIm5iZiI6MTU4NDI1NTI0MX0.HNXSKISZTqzjKd705BOSARmgI8FGGe4Sv-Ma3_iK1Xw&amp;#39;
{&amp;#34;data&amp;#34;:{&amp;#34;userName&amp;#34;:&amp;#34;hahaha1&amp;#34;,&amp;#34;email&amp;#34;:&amp;#34;hahaha1@bgbiao.top&amp;#34;,&amp;#34;exp&amp;#34;:1584259841,&amp;#34;iss&amp;#34;:&amp;#34;bgbiao.top&amp;#34;,&amp;#34;nbf&amp;#34;:1584255241},&amp;#34;msg&amp;#34;:&amp;#34;token有效&amp;#34;,&amp;#34;status&amp;#34;:0}%&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/BGBiao/gin-jwt-token&#34;&gt;gin-jwt-go源码&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Golang语言中的ORM框架之gorm</title>
      <link>https://bgbiao.top/post/golang-gorm%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/golang-gorm%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;前言:&lt;a href=&#34;https://github.com/jinzhu/gorm&#34;&gt;gorm&lt;/a&gt;是Golang语言中一款性能极好的ORM库，对开发人员相对是比较友好的。当然还有另外一个&lt;a href=&#34;https://github.com/go-xorm/xorm&#34;&gt;xorm&lt;/a&gt;库也是比较出名的，感兴趣的也可以看看这个库，接下来主要介绍下&lt;code&gt;gorm&lt;/code&gt;库的一些基本使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;gorm介绍和快速入门&#34;&gt;GORM介绍和快速入门&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;功能概览&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;全功能ORM(无限接近)&lt;/li&gt;
&lt;li&gt;关联(Has One, Has Many, Belongs To, Many To Many, 多态)&lt;/li&gt;
&lt;li&gt;钩子函数Hook(在创建/保存/更新/删除/查找之前或之后)&lt;/li&gt;
&lt;li&gt;预加载&lt;/li&gt;
&lt;li&gt;事务&lt;/li&gt;
&lt;li&gt;复合主键&lt;/li&gt;
&lt;li&gt;SQL 生成器&lt;/li&gt;
&lt;li&gt;数据库自动迁移&lt;/li&gt;
&lt;li&gt;自定义日志&lt;/li&gt;
&lt;li&gt;可扩展性, 可基于 GORM 回调编写插件&lt;/li&gt;
&lt;li&gt;所有功能都被测试覆盖&lt;/li&gt;
&lt;li&gt;开发者友好&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们都知道，在golang中需要使用一些驱动包来对指定数据库进行操作，比如MySQL需要使用&lt;code&gt;github.com/go-sql-driver/mysql&lt;/code&gt;库，而Sqlite需要使用&lt;code&gt;github.com/mattn/go-sqlite3&lt;/code&gt;库来支持，不过好在gorm框架中对各个驱动包进行了简单包装，可以让我们在写程序时可以更方便的管理驱动库.&lt;/p&gt;

&lt;p&gt;支持的数据库以及导入路径如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mysql: github.com/jinzhu/gorm/dialects/mysql&lt;/li&gt;
&lt;li&gt;postgres: github.com/jinzhu/gorm/dialects/postgres&lt;/li&gt;
&lt;li&gt;sqlite: github.com/jinzhu/gorm/dialects/sqlite&lt;/li&gt;
&lt;li&gt;sqlserver: github.com/jinzhu/gorm/dialects/mssql&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;gorm框架只是简单封装了数据库的驱动包，在安装时仍需要下载原始的驱动包&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 由于在项目中使用mysql比较多，这里使用mysql进行数据存储
$ go get -u github.com/jinzhu/gorm
$ go get -u github.com/go-sql-driver/mysql&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;快速入门&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;使用docker快速创建一个本地可连接的mysql实例&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;docker&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;itd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;orm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13306&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3306&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;5.6&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;登陆mysql并创建一个测试库&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;docker&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;it&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;orm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uroot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pbgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;database&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;test_api&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Query&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;row&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;affected&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.00&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;show&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;databases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;+--------------------+&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Database&lt;/span&gt;           &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;+--------------------+&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;information_schema&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;              &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;performance_schema&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;test_api&lt;/span&gt;           &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;+--------------------+&lt;/span&gt;
&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rows&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;set&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.00&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;运行一个简单示例&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gorm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;

    &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/jinzhu/gorm&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/jinzhu/gorm/dialects/mysql&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;


&lt;span class=&#34;c1&#34;&gt;// 定义一个数据模型(user表)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 列名是字段名的蛇形小写(PassWd-&amp;gt;pass_word)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Id&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt;        &lt;span class=&#34;s&#34;&gt;`gorm:&amp;#34;AUTO_INCREMENT&amp;#34;`&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;`gorm:&amp;#34;size:50&amp;#34;`&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Age&lt;/span&gt;         &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;         &lt;span class=&#34;s&#34;&gt;`gorm:&amp;#34;size:3&amp;#34;`&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Birthday&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;Email&lt;/span&gt;       &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;`gorm:&amp;#34;type:varchar(50);unique_index&amp;#34;`&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;PassWord&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;      &lt;span class=&#34;s&#34;&gt;`gorm:&amp;#34;type:varchar(25)&amp;#34;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gorm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;DB&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gorm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mysql&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;root:bgbiao.top@(127.0.0.1:13306)/test_api?charset=utf8&amp;amp;parseTime=True&amp;amp;loc=Local&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Errorf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;创建数据库连接失败:%v&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 自动迁移数据结构(table schema)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 注意:在gorm中，默认的表名都是结构体名称的复数形式，比如User结构体默认创建的表为users
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// db.SingularTable(true) 可以取消表名的复数形式，使得表名和结构体名称一致
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AutoMigrate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;


    &lt;span class=&#34;c1&#34;&gt;// 添加唯一索引
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddUniqueIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name_email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;id&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;email&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 插入记录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;bgbiao&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Email&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;bgbiao@bgbiao.top&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Create&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;xxb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Email&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;xxb@bgbiao.top&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;users&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;User&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 查看插入后的全部元素
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;插入后元素:\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 查询一条记录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;First&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name = ?&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;bgbiao&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;查看查询记录:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 更新记录(基于查出来的数据进行更新)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Model&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;biaoge&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;更新后的记录:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 删除记录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 查看全部记录
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;查看全部记录:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;nx&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Find&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;users&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;运行gorm实例&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gorm&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;example&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;插入后元素&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xxb&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xxb&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;查看查询记录&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;更新后的记录&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;biaoge&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;查看全部记录&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xxb&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;xxb&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bgbiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}]&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;gorm常用的功能函数&#34;&gt;GORM常用的功能函数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;自动迁移&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 使用自动迁移模式将保持表的更新，但是不会更新索引以及现有列的类型或删除未使用的列&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 同时迁移多个模型
db.AutoMigrate(&amp;amp;User{}, &amp;amp;Product{}, &amp;amp;Order{})

// 创建表时增加相关参数
// 比如修改表的字符类型CHARSET=utf8
db.Set(&amp;#34;gorm:table_options&amp;#34;, &amp;#34;ENGINE=InnoDB&amp;#34;).AutoMigrate(&amp;amp;User{})&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;检查表&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 检查模型是否存在
db.HasTable(&amp;amp;User{})

// 检查表是否存在
db.HasTable(&amp;#34;users&amp;#34;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;增、删、改表结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在实际企业的生产环境中，通常数据库级别的变更操作，都需要转换成sql交由DBA兄弟帮忙进行线上库表变更，因此不论使用自动迁移，还是手动创建表，都是在开发环境阶段的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 使用模型创建
db.CreateTable(&amp;amp;User{})

// 增加参数创建
db.Set(&amp;#34;gorm:table_options&amp;#34;, &amp;#34;ENGINE=InnoDB&amp;#34;).CreateTable(&amp;amp;User{}) 

// 删除表
db.DropTable(&amp;amp;User{})
db.DropTable(&amp;#34;users&amp;#34;)

// 模型和表名的混搭
db.DropTableIfExists(&amp;amp;User{}, &amp;#34;products&amp;#34;)


// 修改列(修改字段类型)
db.Model(&amp;amp;User{}).ModifyColumn(&amp;#34;description&amp;#34;, &amp;#34;text&amp;#34;)

// 删除列
db.Model(&amp;amp;User{}).DropColumn(&amp;#34;description&amp;#34;)

// 指定表名创建表
db.Table(&amp;#34;deleted_users&amp;#34;).CreateTable(&amp;amp;User{})

// 指定表名查询
var deleted_users []User
db.Table(&amp;#34;deleted_users&amp;#34;).Find(&amp;amp;deleted_users)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;索引和约束&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 添加外键
// 1st param : 外键字段
// 2nd param : 外键表(字段)
// 3rd param : ONDELETE
// 4th param : ONUPDATE
db.Model(&amp;amp;User{}).AddForeignKey(&amp;#34;city_id&amp;#34;, &amp;#34;cities(id)&amp;#34;, &amp;#34;RESTRICT&amp;#34;, &amp;#34;RESTRICT&amp;#34;)

// 单个索引
db.Model(&amp;amp;User{}).AddIndex(&amp;#34;idx_user_name&amp;#34;, &amp;#34;name&amp;#34;)

// 多字段索引
db.Model(&amp;amp;User{}).AddIndex(&amp;#34;idx_user_name_age&amp;#34;, &amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;)

// 添加唯一索引(通常使用多个字段来唯一标识一条记录)
db.Model(&amp;amp;User{}).AddUniqueIndex(&amp;#34;idx_user_name&amp;#34;, &amp;#34;name&amp;#34;)
db.Model(&amp;amp;User{}).AddUniqueIndex(&amp;#34;idx_user_name_age&amp;#34;, &amp;#34;name&amp;#34;, &amp;#34;id&amp;#34;,&amp;#34;email&amp;#34;)


// 删除索引
db.Model(&amp;amp;User{}).RemoveIndex(&amp;#34;idx_user_name&amp;#34;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;gorm模型注意事项&#34;&gt;GORM模型注意事项&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;gorm.Model结构体&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实在&lt;code&gt;gorm&lt;/code&gt;官方文档的示例中，会默认在模型的属性中增加一个&lt;a href=&#34;https://pkg.go.dev/github.com/jinzhu/gorm?tab=doc#Model&#34;&gt;gorm.Model&lt;/a&gt;的属性，该属性的原始结构如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 官方示例模型
type User struct {
  gorm.Model
  Name         string
	.....
}

// gorm.Model结构体
type Model struct {
	ID        uint `gorm:&amp;#34;primary_key&amp;#34;`
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt *time.Time `sql:&amp;#34;index&amp;#34;`
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;很明显，当我们在用户自定义的模型中增加&lt;code&gt;gorm.Model&lt;/code&gt;时，会自动为我们的表增加&lt;code&gt;id,created_at,updated_at,deleted_at&lt;/code&gt;四个字段。&lt;/p&gt;

&lt;p&gt;同时需要注意的是，当我们的模型中有&lt;code&gt;CreatedAt&lt;/code&gt;,&lt;code&gt;UpdatedAt&lt;/code&gt;,&lt;code&gt;DeletedAt&lt;/code&gt;属性并且类型为&lt;code&gt;time.Time&lt;/code&gt;或者&lt;code&gt;*time.Time&lt;/code&gt;类型时，当有数据操作时，会自动更新对应的时间。&lt;/p&gt;

&lt;p&gt;所以，在定义模型时，可以根据实际的需求来决定是否引入&lt;code&gt;gorm.Model&lt;/code&gt;结构&lt;/p&gt;

&lt;p&gt;另外需要注意的是: 所有字段的零值, 比如&lt;code&gt;0, &#39;&#39;, false 或者其它零值&lt;/code&gt;都不会保存到数据库内，但会使用他们的默认值，因此一些非必须字段，可以使用&lt;code&gt;DEFAULT&lt;/code&gt;的tag字段来声明列的默认值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;gorm模型支持的tags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;gorm支持一些常见的tags来自定义模型字段的扩展信息&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结构体标记&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;column&lt;/td&gt;
&lt;td&gt;列明(默认是字段的蛇形小写)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;数据类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;列长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PRIMARY_KEY&lt;/td&gt;
&lt;td&gt;声明主键&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNIQUE&lt;/td&gt;
&lt;td&gt;声明唯一&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEFAULT&lt;/td&gt;
&lt;td&gt;指定默认值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PRECISION&lt;/td&gt;
&lt;td&gt;声明列精度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;NOT NULL&lt;/td&gt;
&lt;td&gt;将列指定为非 NULL&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AUTO_INCREMENT&lt;/td&gt;
&lt;td&gt;声明自增列&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INDEX&lt;/td&gt;
&lt;td&gt;创建具有或不带名称的索引, 如果多个索引同名则创建复合索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNIQUE_INDEX&lt;/td&gt;
&lt;td&gt;创建唯一索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EMBEDDED&lt;/td&gt;
&lt;td&gt;将结构设置为嵌入&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EMBEDDED_PREFIX&lt;/td&gt;
&lt;td&gt;设置嵌入结构的前缀&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;忽略此字段&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; gorm也支持一些关联的结构体标签，比如外键，关联外键，等操作，通常在复杂的企业环境中，建议在库表设计时将相关表都设计成孤立表，具体的关联逻辑由业务层去实现(可能增加了开发的成本，不过当业务发展比较复杂时，这样做无疑是方便后期做扩展和优化的)&lt;/p&gt;

&lt;h3 id=&#34;详细的crud接口&#34;&gt;详细的CRUD接口&lt;/h3&gt;

&lt;h4 id=&#34;创建&#34;&gt;创建&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;插入记录&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 相当于insert into users(name,age,brithday) values(&amp;#34;BGBiao&amp;#34;,18,time.Now())
user := User{Name: &amp;#34;BGBiao&amp;#34;, Age: 18, Birthday: time.Now()}
// 主键为空返回`true`
db.NewRecord(user)
db.Create(&amp;amp;user)
// 创建`user`后返回`false`
db.NewRecord(user) &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;在Hooks中设置字段值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: 通常我们在设计模型时，有一些原始字段，希望在初始化模型后就拥有记录，此时可以使用hooks来插入初始记录&lt;/p&gt;

&lt;p&gt;如果想再&lt;code&gt;BeforeCreate&lt;/code&gt;hook中修改字段的值，可以使用&lt;code&gt;scope.SetColumn&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func (user *User) BeforeCreate(scope *gorm.Scope) error {
  scope.SetColumn(&amp;#34;ID&amp;#34;, uuid.New())
  return nil
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;创建扩展选项&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 为Instert语句添加扩展SQL选项
// insert into produce(name,code) values(&amp;#34;name&amp;#34;,&amp;#34;code&amp;#34;) on conflict;
db.Set(&amp;#34;gorm:insert_option&amp;#34;, &amp;#34;ON CONFLICT&amp;#34;).Create(&amp;amp;product)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;查询&#34;&gt;查询&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;基本查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 根据主键查询第一条记录
// SELECT * FROM users ORDER BY id LIMIT 1;
db.First(&amp;amp;user)


// 随机获取一条记录
// SELECT * FROM users LIMIT 1;
db.Take(&amp;amp;user)


// 根据主键查询最后一条记录
// SELECT * FROM users ORDER BY id DESC LIMIT 1;
db.Last(&amp;amp;user)


// 查询所有的记录
// SELECT * FROM users;
db.Find(&amp;amp;users)


// 查询指定的某条记录(仅当主键为整型时可用)
// SELECT * FROM users WHERE id = 10;
db.First(&amp;amp;user, 10)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;结构体方式查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 结构体方式
// select * from users where name = &amp;#39;bgbiao.top&amp;#39;
db.Where(&amp;amp;User{Name: &amp;#34;bgbiao.top&amp;#34;, Age: 20}).First(&amp;amp;user)

// Map方式
// select * from users where name = &amp;#39;bgbiao.top&amp;#39; and age = 20;
db.Where(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;bgbiao.top&amp;#34;, &amp;#34;age&amp;#34;: 20}).Find(&amp;amp;users)

// 主键的切片
// select * from users where id in (20,21,22);
db.Where([]int64{20, 21, 22}).Find(&amp;amp;users)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Where条件查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 使用了Where()方法，基本上就是基本的sql语法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 使用条件获取一条记录 First()方法
db.Where(&amp;#34;name = ?&amp;#34;, &amp;#34;bgbiao.top&amp;#34;).First(&amp;amp;user)

// 获取全部记录 Find()方法
db.Where(&amp;#34;name = ?&amp;#34;, &amp;#34;jinzhu&amp;#34;).Find(&amp;amp;users)

// 不等于
db.Where(&amp;#34;name &amp;lt;&amp;gt; ?&amp;#34;, &amp;#34;jinzhu&amp;#34;).Find(&amp;amp;users)

// IN
db.Where(&amp;#34;name IN (?)&amp;#34;, []string{&amp;#34;jinzhu&amp;#34;, &amp;#34;bgbiao.top&amp;#34;}).Find(&amp;amp;users)

// LIKE
db.Where(&amp;#34;name LIKE ?&amp;#34;, &amp;#34;%jin%&amp;#34;).Find(&amp;amp;users)

// AND
db.Where(&amp;#34;name = ? AND age &amp;gt;= ?&amp;#34;, &amp;#34;jinzhu&amp;#34;, &amp;#34;22&amp;#34;).Find(&amp;amp;users)

// Time
// select * from users where updated_at &amp;gt; &amp;#39;2020-03-06 00:00:00&amp;#39;
db.Where(&amp;#34;updated_at &amp;gt; ?&amp;#34;, lastWeek).Find(&amp;amp;users)

// BETWEEN
// select * from users where created_at between &amp;#39;2020-03-06 00:00:00&amp;#39; and &amp;#39;2020-03-14 00:00:00&amp;#39;
db.Where(&amp;#34;created_at BETWEEN ? AND ?&amp;#34;, lastWeek, today).Find(&amp;amp;users)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Not条件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// select * from users where name != &amp;#39;bgbiao.top&amp;#39;;
db.Not(&amp;#34;name&amp;#34;, &amp;#34;jinzhu&amp;#34;).First(&amp;amp;user)

// Not In
// select * from users where name not in (&amp;#34;jinzhu&amp;#34;,&amp;#34;bgbiao.top&amp;#34;);
db.Not(&amp;#34;name&amp;#34;, []string{&amp;#34;jinzhu&amp;#34;, &amp;#34;bgbiao.top&amp;#34;}).Find(&amp;amp;users)

// 主键不在slice中的查询
// select * from users where id not in (1,2,3)
db.Not([]int64{1,2,3}).First(&amp;amp;user)

// select * from users;
db.Not([]int64{}).First(&amp;amp;user)

// 原生SQL
// select * from users where not(name = &amp;#39;bgbiao.top&amp;#39;);
db.Not(&amp;#34;name = ?&amp;#34;, &amp;#34;bgbiao.top&amp;#34;).First(&amp;amp;user)

// struct方式查询
// select * from users where name != &amp;#39;bgbiao.top&amp;#39;
db.Not(User{Name: &amp;#34;bgbiao.top&amp;#34;}).First(&amp;amp;user)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Or条件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT * FROM users WHERE role = &amp;#39;admin&amp;#39; OR role = &amp;#39;super_admin&amp;#39;;
db.Where(&amp;#34;role = ?&amp;#34;, &amp;#34;admin&amp;#34;).Or(&amp;#34;role = ?&amp;#34;, &amp;#34;super_admin&amp;#34;).Find(&amp;amp;users)

// Struct 方式
// SELECT * FROM users WHERE name = &amp;#39;jinzhu&amp;#39; OR name = &amp;#39;bgbiao.top&amp;#39;;
db.Where(&amp;#34;name = &amp;#39;jinzhu&amp;#39;&amp;#34;).Or(User{Name: &amp;#34;bgbiao.top&amp;#34;}).Find(&amp;amp;users)

// Map 方式
// SELECT * FROM users WHERE name = &amp;#39;jinzhu&amp;#39; OR name = &amp;#39;bgbiao.top&amp;#39;;
db.Where(&amp;#34;name = &amp;#39;jinzhu&amp;#39;&amp;#34;).Or(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;bgbiao.top&amp;#34;}).Find(&amp;amp;users)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;FirstOrCreate&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;获取匹配的第一条记录, 否则根据给定的条件创建一个新的记录(仅支持 struct 和 map 条件)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 未找到,就插入记录
if select * from users where name = &amp;#39;non_existing&amp;#39;) is null; insert into users(name) values(&amp;#34;non_existing&amp;#34;)
db.FirstOrCreate(&amp;amp;user, User{Name: &amp;#34;non_existing&amp;#34;})

// 找到
// select * from users where name = &amp;#39;bgbiao.top&amp;#39; 
db.Where(User{Name: &amp;#34;bgbiao.top&amp;#34;}).FirstOrCreate(&amp;amp;user)

## attrs参数:如果记录未找到，将使用参数创建 struct 和记录.
// 未找到(将条件前置，并将拆入数据填充到Attrs方法中)
db.Where(User{Name: &amp;#34;non_existing&amp;#34;}).Attrs(User{Age: 20}).FirstOrCreate(&amp;amp;user)

// 找到
db.Where(User{Name: &amp;#34;bgbiao.top&amp;#34;}).Attrs(User{Age: 30}).FirstOrCreate(&amp;amp;user)

## assgin参数: 不管记录是否找到，都将参数赋值给 struct 并保存至数据库
db.Where(User{Name: &amp;#34;non_existing&amp;#34;}).Assign(User{Age: 20}).FirstOrCreate(&amp;amp;user)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;子查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*gorm.expr&lt;/code&gt; 子查询&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT * FROM &amp;#34;orders&amp;#34;  WHERE &amp;#34;orders&amp;#34;.&amp;#34;deleted_at&amp;#34; IS NULL AND (amount &amp;gt; (SELECT AVG(amount) FROM &amp;#34;orders&amp;#34;  WHERE (state = &amp;#39;paid&amp;#39;)));
db.Where(&amp;#34;amount &amp;gt; ?&amp;#34;, DB.Table(&amp;#34;orders&amp;#34;).Select(&amp;#34;AVG(amount)&amp;#34;).Where(&amp;#34;state = ?&amp;#34;, &amp;#34;paid&amp;#34;).QueryExpr()).Find(&amp;amp;orders)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;字段查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常情况下，我们只想选择几个字段进行查询，指定你想从数据库中检索出的字段，默认会选择全部字段。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT name, age FROM users;
db.Select(&amp;#34;name, age&amp;#34;).Find(&amp;amp;users)

// SELECT name, age FROM users;
db.Select([]string{&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;}).Find(&amp;amp;users)

// SELECT COALESCE(age,&amp;#39;42&amp;#39;) FROM users; 
db.Table(&amp;#34;users&amp;#34;).Select(&amp;#34;COALESCE(age,?)&amp;#34;, 42).Rows()&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;排序(Order)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT * FROM users ORDER BY age desc, name;
db.Order(&amp;#34;age desc, name&amp;#34;).Find(&amp;amp;users)

// 多字段排序
// SELECT * FROM users ORDER BY age desc, name;
db.Order(&amp;#34;age desc&amp;#34;).Order(&amp;#34;name&amp;#34;).Find(&amp;amp;users)

// 覆盖排序
// 
db.Order(&amp;#34;age desc&amp;#34;).Find(&amp;amp;users1).Order(&amp;#34;age&amp;#34;, true).Find(&amp;amp;users2)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;限制输出&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT * FROM users LIMIT 3;
db.Limit(3).Find(&amp;amp;users)

// -1 取消 Limit 条件
// SELECT * FROM users LIMIT 10;
// SELECT * FROM users;
db.Limit(10).Find(&amp;amp;users1).Limit(-1).Find(&amp;amp;users2)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;统计count&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// SELECT count(*) from USERS WHERE name = &amp;#39;jinzhu&amp;#39; OR name = &amp;#39;bgbiao.top&amp;#39;;
db.Where(&amp;#34;name = ?&amp;#34;, &amp;#34;jinzhu&amp;#34;).Or(&amp;#34;name = ?&amp;#34;, &amp;#34;bgbiao.top&amp;#34;).Find(&amp;amp;users).Count(&amp;amp;count)

// select count(*) from users where name = &amp;#39;bgbiao.top&amp;#39;
db.Model(&amp;amp;User{}).Where(&amp;#34;name = ?&amp;#34;, &amp;#34;bgbiao.top&amp;#34;).Count(&amp;amp;count)

// SELECT count(*) FROM deleted_users;
db.Table(&amp;#34;deleted_users&amp;#34;).Count(&amp;amp;count)

// SELECT count( distinct(name) ) FROM deleted_users;
db.Table(&amp;#34;deleted_users&amp;#34;).Select(&amp;#34;count(distinct(name))&amp;#34;).Count(&amp;amp;count)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;分组(grouo&amp;amp;having)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;rows, err := db.Table(&amp;#34;orders&amp;#34;).Select(&amp;#34;date(created_at) as date, sum(amount) as total&amp;#34;).Group(&amp;#34;date(created_at)&amp;#34;).Rows()
for rows.Next() {
  ...
}

rows, err := db.Table(&amp;#34;orders&amp;#34;).Select(&amp;#34;date(created_at) as date, sum(amount) as total&amp;#34;).Group(&amp;#34;date(created_at)&amp;#34;).Having(&amp;#34;sum(amount) &amp;gt; ?&amp;#34;, 100).Rows()
for rows.Next() {
  ...
}

type Result struct {
  Date  time.Time
  Total int64
}
db.Table(&amp;#34;orders&amp;#34;).Select(&amp;#34;date(created_at) as date, sum(amount) as total&amp;#34;).Group(&amp;#34;date(created_at)&amp;#34;).Having(&amp;#34;sum(amount) &amp;gt; ?&amp;#34;, 100).Scan(&amp;amp;results)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;连接查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;rows, err := db.Table(&amp;#34;users&amp;#34;).Select(&amp;#34;users.name, emails.email&amp;#34;).Joins(&amp;#34;left join emails on emails.user_id = users.id&amp;#34;).Rows()
for rows.Next() {
  ...
}

db.Table(&amp;#34;users&amp;#34;).Select(&amp;#34;users.name, emails.email&amp;#34;).Joins(&amp;#34;left join emails on emails.user_id = users.id&amp;#34;).Scan(&amp;amp;results)

// 多连接及参数
db.Joins(&amp;#34;JOIN emails ON emails.user_id = users.id AND emails.email = ?&amp;#34;, &amp;#34;jinzhu@example.org&amp;#34;).Joins(&amp;#34;JOIN credit_cards ON credit_cards.user_id = users.id&amp;#34;).Where(&amp;#34;credit_cards.number = ?&amp;#34;, &amp;#34;411111111111&amp;#34;).Find(&amp;amp;user)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;pluck查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pluck，查询 model 中的一个列作为&lt;code&gt;切片&lt;/code&gt;，如果您想要查询多个列，您应该使用&lt;code&gt;Scan&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;var ages []int64
db.Find(&amp;amp;users).Pluck(&amp;#34;age&amp;#34;, &amp;amp;ages)

var names []string
db.Model(&amp;amp;User{}).Pluck(&amp;#34;name&amp;#34;, &amp;amp;names)

db.Table(&amp;#34;deleted_users&amp;#34;).Pluck(&amp;#34;name&amp;#34;, &amp;amp;names)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;scan扫描&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;type Result struct {
  Name string
  Age  int
}

var result Result
db.Table(&amp;#34;users&amp;#34;).Select(&amp;#34;name, age&amp;#34;).Where(&amp;#34;name = ?&amp;#34;, &amp;#34;Antonio&amp;#34;).Scan(&amp;amp;result)

// 原生 SQL
db.Raw(&amp;#34;SELECT name, age FROM users WHERE name = ?&amp;#34;, &amp;#34;Antonio&amp;#34;).Scan(&amp;amp;result)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;更新&#34;&gt;更新&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;更新所有字段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;save会更新所有字段，及时没有赋值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;db.First(&amp;amp;user)

user.Name = &amp;#34;bgbiao.top&amp;#34;
user.Age = 100
// update users set name = &amp;#39;bgbiao.top&amp;#39;,age=100 where id = user.id
db.Save(&amp;amp;user)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;更新修改字段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;Update&lt;/code&gt;和&lt;code&gt;Updates&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 更新单个属性，如果它有变化
// update users set name = &amp;#39;hello&amp;#39; where id = user.id
db.Model(&amp;amp;user).Update(&amp;#34;name&amp;#34;, &amp;#34;hello&amp;#34;)

// 根据给定的条件更新单个属性
// update users set name = &amp;#39;hello&amp;#39; where active = true
db.Model(&amp;amp;user).Where(&amp;#34;active = ?&amp;#34;, true).Update(&amp;#34;name&amp;#34;, &amp;#34;hello&amp;#34;)

// 使用 map 更新多个属性，只会更新其中有变化的属性
// update users set name = &amp;#39;hello&amp;#39;,age=18,actived=false where id = user.id
db.Model(&amp;amp;user).Updates(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;age&amp;#34;: 18, &amp;#34;actived&amp;#34;: false})

// 使用 struct 更新多个属性，只会更新其中有变化且为非零值的字段
db.Model(&amp;amp;user).Updates(User{Name: &amp;#34;hello&amp;#34;, Age: 18})

// 警告：当使用 struct 更新时，GORM只会更新那些非零值的字段
// 对于下面的操作，不会发生任何更新，&amp;#34;&amp;#34;, 0, false 都是其类型的零值
db.Model(&amp;amp;user).Updates(User{Name: &amp;#34;&amp;#34;, Age: 0, Actived: false})&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;更新选定字段&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想要更新或者忽略某些字段，可以先使用&lt;code&gt;Select&lt;/code&gt;或&lt;code&gt;Omit&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// update users set name = &amp;#39;hello&amp;#39; where id = user.id;
db.Model(&amp;amp;user).Select(&amp;#34;name&amp;#34;).Updates(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;age&amp;#34;: 18, &amp;#34;actived&amp;#34;: false})

// Omit()方法用来忽略字段
// update users set age=18,actived=false where id = user.id
db.Model(&amp;amp;user).Omit(&amp;#34;name&amp;#34;).Updates(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;age&amp;#34;: 18, &amp;#34;actived&amp;#34;: false})&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;无hook更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面的更新操作会会自动运行 model 的&lt;code&gt;BeforeUpdate&lt;/code&gt;,&lt;code&gt;AfterUpdate&lt;/code&gt;方法，来更新一些类似&lt;code&gt;UpdatedAt&lt;/code&gt;的字段在更新时保存其 &lt;code&gt;Associations&lt;/code&gt;, 如果你不想调用这些方法，你可以使用&lt;code&gt;UpdateColumn&lt;/code&gt;,&lt;code&gt;UpdateColumns&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 更新单个属性，类似于 `Update`
// update users set name = &amp;#39;hello&amp;#39; where id = user.id;
db.Model(&amp;amp;user).UpdateColumn(&amp;#34;name&amp;#34;, &amp;#34;hello&amp;#34;)

// 更新多个属性，类似于 `Updates`
// update users set name = &amp;#39;hello&amp;#39;,age=18 where id = user.id;
db.Model(&amp;amp;user).UpdateColumns(User{Name: &amp;#34;hello&amp;#34;, Age: 18})&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;批量更新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 使用struct实例更新时，只会更新非零值字段，弱项更新全部字段，建议使用map&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// update users set name = &amp;#39;hello&amp;#39;,age=18 where id in (10,11)
db.Table(&amp;#34;users&amp;#34;).Where(&amp;#34;id IN (?)&amp;#34;, []int{10, 11}).Updates(map[string]interface{}{&amp;#34;name&amp;#34;: &amp;#34;hello&amp;#34;, &amp;#34;age&amp;#34;: 18})

// 使用 struct 更新时，只会更新非零值字段，若想更新所有字段，请使用map[string]interface{}
db.Model(User{}).Updates(User{Name: &amp;#34;hello&amp;#34;, Age: 18})

// 使用 `RowsAffected` 获取更新记录总数
db.Model(User{}).Updates(User{Name: &amp;#34;hello&amp;#34;, Age: 18}).RowsAffected&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;使用SQL计算表达式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// update products set price = price*2+100 where id = product.id
DB.Model(&amp;amp;product).Update(&amp;#34;price&amp;#34;, gorm.Expr(&amp;#34;price * ? + ?&amp;#34;, 2, 100))

// update products set price = price*2+100 where id = product.id;
DB.Model(&amp;amp;product).Updates(map[string]interface{}{&amp;#34;price&amp;#34;: gorm.Expr(&amp;#34;price * ? + ?&amp;#34;, 2, 100)})

// update products set quantity = quantity-1 where id = product.id;
DB.Model(&amp;amp;product).UpdateColumn(&amp;#34;quantity&amp;#34;, gorm.Expr(&amp;#34;quantity - ?&amp;#34;, 1))

// update products set quantity = quantity -1 where id = product.id and quantity &amp;gt; 1
DB.Model(&amp;amp;product).Where(&amp;#34;quantity &amp;gt; 1&amp;#34;).UpdateColumn(&amp;#34;quantity&amp;#34;, gorm.Expr(&amp;#34;quantity - ?&amp;#34;, 1))&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;删除&#34;&gt;删除&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;删除记录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 删除记录时，请确保主键字段有值，GORM 会通过主键去删除记录，如果主键为空，GORM 会删除该 model 的所有记录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 删除现有记录
// delete from emails where id = email.id;
db.Delete(&amp;amp;email)

// 为删除 SQL 添加额外的 SQL 操作
// delete from emails where id = email.id OPTION (OPTIMIZE FOR UNKNOWN)
db.Set(&amp;#34;gorm:delete_option&amp;#34;, &amp;#34;OPTION (OPTIMIZE FOR UNKNOWN)&amp;#34;).Delete(&amp;amp;email)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;批量删除&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// delete from emails where email like &amp;#39;%jinzhu%&amp;#39;
db.Where(&amp;#34;email LIKE ?&amp;#34;, &amp;#34;%jinzhu%&amp;#34;).Delete(Email{})

// 同上
db.Delete(Email{}, &amp;#34;email LIKE ?&amp;#34;, &amp;#34;%jinzhu%&amp;#34;)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;软删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果一个model有&lt;code&gt;DeletedAt&lt;/code&gt;字段，他将自动获得软删除的功能！&lt;/p&gt;

&lt;p&gt;当调用&lt;code&gt;Delete&lt;/code&gt;方法时， 记录不会真正的从数据库中被删除，只会将&lt;code&gt;DeletedAt&lt;/code&gt;字段的值会被设置为当前时间。&lt;/p&gt;

&lt;p&gt;在之前，我们可能会使用&lt;code&gt;isDelete&lt;/code&gt;之类的字段来标记记录删除，不过在gorm中内置了&lt;code&gt;DeletedAt&lt;/code&gt;字段，并且有相关hook来保证软删除。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// UPDATE users SET deleted_at=&amp;#34;2020-03-13 10:23&amp;#34; WHERE id = user.id;
db.Delete(&amp;amp;user)

// 批量删除
// 软删除的批量删除其实就是把deleted_at改成当前时间,并且在查询时无法查到,所以底层用的是update的sql
db.Where(&amp;#34;age = ?&amp;#34;, 20).Delete(&amp;amp;User{})

// 查询记录时会忽略被软删除的记录
// SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL;
db.Where(&amp;#34;age = 20&amp;#34;).Find(&amp;amp;user)

// Unscoped 方法可以查询被软删除的记录
// SELECT * FROM users WHERE age = 20;
db.Unscoped().Where(&amp;#34;age = 20&amp;#34;).Find(&amp;amp;users)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;物理删除&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 使用&lt;code&gt;Unscoped().Delete()&lt;/code&gt;方法才是真正执行sql中的&lt;code&gt;delete&lt;/code&gt;语句.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// Unscoped 方法可以物理删除记录
// DELETE FROM orders WHERE id=10;
db.Unscoped().Delete(&amp;amp;order)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>过去这一个月的所思所想</title>
      <link>https://bgbiao.top/post/%E7%96%AB%E6%83%85%E5%9C%A8%E5%AE%B6%E8%BF%99%E4%B8%AA%E6%9C%88/</link>
      <pubDate>Sun, 01 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E7%96%AB%E6%83%85%E5%9C%A8%E5%AE%B6%E8%BF%99%E4%B8%AA%E6%9C%88/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gceh0gxrolj313y0u07wl.jpg&#34; alt=&#34;可乐葱三结义&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;这一个月以来，受疫情的影响，一直在家办公，可能对外人而言，觉得在家办公会相对比较轻松，能够除工作外做更多的事情，但这一个月下来，我却有颇多的不爽和不适，也因此把公众号的更新耽误了许久。本来计划3月2号全员复工的我们，在2月的尾巴突然通知延迟到3月16号上班，这让我顿时有了紧迫感，2020年的规划和计划得赶紧抓紧执行了，公号也得更起来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;先说说在家办公吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在春节期间，由于疫情的爆发，国家将法定的春节延长至2月2日(正月初九)，所以我们正式的远程办公是在2月3日开始执行的，截止2月底，相当于已经整整在家办公四周了。&lt;/p&gt;

&lt;p&gt;在家的办公的这四周里，虽然对于个人实际的工作内容没有太大的变化，但整个工作形式、工作状态以及工作效能却是有很大的变化的。(&lt;code&gt;注意:这里说的是在家办公而非远程办公&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;在工作形式上可谓是百花齐放。相关的协作和协同工具也基本上处于头部几家互联网大厂，首当其冲的肯定属于阿里旗下的&lt;code&gt;钉钉&lt;/code&gt;,由于其早已在TOB领域深耕多年，在这次特殊情况下也就自然发挥了其作用，不过在以直播方式应用在中小学教学领域时也是遭遇&lt;code&gt;1分好评&lt;/code&gt;的尴尬场面。其次是企业微信和头条旗下的&lt;code&gt;飞书&lt;/code&gt;，前者由于存在个人版，所以没做尝试，而飞书前两天在&lt;code&gt;姜胡说&lt;/code&gt;作者胡子老师的直播会议时有幸做了尝试，只能说用过了钉钉，基本很难去转向飞书，毕竟作为TOB产品，以及协作工具，后者的功能更全，生态更广。&lt;/p&gt;

&lt;p&gt;为什么在家办公一个月我会有很多不适？我总结了几个点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;早中午的打卡(每天按点进行团队视频打卡)&lt;/li&gt;
&lt;li&gt;网络的限制&lt;/li&gt;
&lt;li&gt;家庭办公中的生活干扰&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在家办公后公司采取了一系列措施来保证员工的安全和&amp;rdquo;到岗&amp;rdquo;，而钉钉则解决了团队以及项目的沟通和协作问题，看起来似乎即使因为疫情的影响，对于互联网业务的技术岗位来说，也基本不会影响业务进度。事实上也的确是这个样子的。&lt;/p&gt;

&lt;p&gt;但是，对于员工个人(其实是我自己)而言，需要克服的是更多的困难。&lt;/p&gt;

&lt;p&gt;比如家庭网络对于远程办公场景的支撑如何，又如家庭场景的多样性对办公场景的干扰性如何，因为疫情是突然爆发的，所以大部分人在这两方面应该没有足够的准备，也因此可以确定的是，在目标导向或者结果导向的情况下，在家办公的工作内容可能会花费更多的时间。&lt;/p&gt;

&lt;p&gt;我不知道其他小伙伴们如何，但事实上，在北漂出租屋办公一个月的日子里，我好像每天都要加班到晚上十点，才能勉强将当日的计划做完，并且办公环境的限制会使得身体各种不舒服。&lt;/p&gt;

&lt;p&gt;说了这么多我的在家办公情况，其实并未想表明什么，只是希望疫情能够快速过去，企业能早日复工，而我也能去公司去做工作上的事情。&lt;/p&gt;

&lt;p&gt;不过上周五，收到这个通知，感觉又要痛苦两周。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gcepuaum3fj30ks0axt9k.jpg&#34; alt=&#34;延期办公&#34; /&gt;&lt;/p&gt;

&lt;p&gt;但其实，如果在家办公久了，也许以后会成为常态，那对于技术工作者而言是不是也会不再受地域的限制，会不会未来北上广深的技术人员在家办公即可，如此以来不是企业降负，员工自由么，那个时候就可以在家置办个高速网络和工作台，真正实现SOHO了(容我自己YY会儿)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;蜗居生活&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在家办公这一周可以算得上是真正的蜗居生活了，对于我这种天生好动的人来说，一周出门两三次，活动空间不超过40平，这种情况下，也很难会有比较好的心情(主要是我也不咋喜欢宅的娱乐活动)。&lt;/p&gt;

&lt;p&gt;所以，偶然在一次做饭中，想起来将菜根留下来做水培，也就有了题图的&amp;rdquo;可乐葱三结义&amp;rdquo;，一方面是因为实在没事干，想用这种小葱根水培来见证蜗居的日子，另外一方面是因为从假期开始也一直在看电视剧《三国》，每每看到刘备取得一定成绩时，就会想起这桃园三兄弟，三人有勇有谋，且情同手足。&lt;/p&gt;

&lt;p&gt;可叹刘备的胸襟，关羽的忠义，张飞的粗狂。&lt;/p&gt;

&lt;p&gt;话说，活动空间有限，又不能出门，对于运动细胞发达的我更是煎熬，为了不使自己在疫情过后丢掉了矫健的步伐，开始了每晚的Keep运动，每晚10点开始一天的简单运动放松，项目是: 李现HIT全身燃脂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关于成长&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实当人越是处于一个封闭的物理环境时，越容易有焦虑感，这种焦虑感一方面源自于个人成长多样性，另外一方面也源于缺乏与真实环境的正面反馈。&lt;/p&gt;

&lt;p&gt;在家办公的一个月(加上环境的限制)，的确在个人成长方面受限了很多，比如没有足够时间和经历去学习一些新技术，也很难抽出一小段时间来专注读技术之外的书籍(不过还是读完了两本)，这对于整个人的体系化成长会有很大的影响。&lt;/p&gt;

&lt;p&gt;所以，虽然突然又多出来两周的在家办公时间，但是我已经调整了整个生活和工作计划，打算充分利用在家办工的这段时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其他，就没有什么了，我打算趁着现在还没复工，好好梳理梳理我的运维知识体系和个人价值体系以及财富体系，毕竟整个2月一个月的时间整个收益曲线变化很大，现在刚好是可以整理自己思绪的时候，加油吧，baby！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/00831rSTly1gceh0txnrhj313y0u01l9.jpg&#34; alt=&#34;坚定的眼神&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>开源分布式对象存储服务-MinIO</title>
      <link>https://bgbiao.top/post/minio%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Wed, 22 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/minio%E5%88%86%E5%B8%83%E5%BC%8F%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E6%9C%8D%E5%8A%A1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景:通常在企业中我们会将一些图片，视频，文档等相关数据存储在对象存储中，以便于数据的存储和快速获取。在过去的一段时间，我们将这部分数据存储在公有云的对象存储服务上，但随着业务的快速发展，我们需要存储一些身份信息用于审核和实名相关的数据，这部分数据较为敏感，因此对于敏感数据的存储我们选择了使用兼容S3协议的开源分布式对象存储-&lt;a href=&#34;https://github.com/minio/minio&#34;&gt;Minio&lt;/a&gt;来进行自建服务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Minio可能在国内知道和用的人不是很多，我第一次接触Minio是也是当时我们需要使用Spinnaker集群来管理和维护内部的Kubernetes集群，而Spinnaker的中的持久化存储就使用的是Minio &lt;a href=&#34;https://mp.weixin.qq.com/s/uN0RoGtcK1jT4QXlzkf4Bg&#34;&gt;Spinnaker集群搭建&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;但其实，Minio这款开源的分布式对象存储服务在国外已经相当受欢迎，并且国内也有多中小型互联网公司使用它来作为对象存储服务。&lt;/p&gt;

&lt;p&gt;有意思的是当年在开源的分布式存储方案中，比较有名的就是&lt;code&gt;GlusterFS&lt;/code&gt;和&lt;code&gt;Ceph&lt;/code&gt;。前者虽然也提供了块存储和对象存储的接口，但对于企业来说更多用于了分布式文件系统存储，其实就是一种高可用版本的NAS解决方案(通常用于替换NFS)，而后者则针对多种存储场景设计了不同的产品，针对分布式文件系统存储有&lt;code&gt;CephFS&lt;/code&gt;，针对分布式块存储有&lt;code&gt;Ceph RBD&lt;/code&gt;，针对分布式对象存储有&lt;code&gt;Ceph Radosgw&lt;/code&gt;，基本上可以做到开箱即用。&lt;/p&gt;

&lt;p&gt;所以，在后来GlusterFS后来被收购后，据说创始团队又开源了一个分布式存储软件，就是这个用Golang编写的小而美的对象存储&lt;a href=&#34;https://min.io/&#34;&gt;Minio&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;minio介绍&#34;&gt;Minio介绍&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;MinIO&lt;/code&gt;是一个用&lt;code&gt;Golang&lt;/code&gt;开发的基于&lt;code&gt;Apache License v2.0&lt;/code&gt;开源协议的&lt;code&gt;对象存储服务&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。&lt;/p&gt;

&lt;p&gt;Minio使用纠删码&lt;code&gt;erasure code&lt;/code&gt;和校验和&lt;code&gt;checksum&lt;/code&gt;来保护数据免受硬件故障和数据损坏。&lt;/p&gt;

&lt;p&gt;因此，即便您丢失一半数量（N/2）的硬盘，您仍然可以恢复数据。&lt;/p&gt;

&lt;h4 id=&#34;纠错码介绍-erasure-code&#34;&gt;纠错码介绍(erasure code)&lt;/h4&gt;

&lt;p&gt;纠删码是一种恢复丢失和损坏数据的数学算法， Minio采用&lt;code&gt;Reed-Solomon code&lt;/code&gt;将对象拆分成&lt;code&gt;可变数据块&lt;/code&gt;和&lt;code&gt;奇偶校验块&lt;/code&gt;。 比如12块盘(driver)，一个对象可以被切分到所有驱动器上的可变数量的数据和奇偶校验块—从6个数据和6个奇偶校验块到10个数据和2个奇偶校验块。&lt;/p&gt;

&lt;p&gt;但是，默认情况下，MinIO在&lt;code&gt;N/2&lt;/code&gt;个数据块和&lt;code&gt;N/2&lt;/code&gt;个奇偶校验驱动器上分片对象，当然用户可以通过&lt;a href=&#34;https://github.com/minio/minio/tree/master/docs/erasure/storage-class&#34;&gt;storage classes&lt;/a&gt;来自定义配置，不过官方还是建议采用使用N/2个节点来分配数据块和奇偶校验块，这样能够以最佳的方式保护防止驱动器(driver)故障.&lt;/p&gt;

&lt;p&gt;在上面的12个驱动器示例(使用默认配置)中，您可以丢失6个驱动器中的任何一个，但仍然可以从其余驱动器可靠地重构和恢复数据。&lt;/p&gt;

&lt;h4 id=&#34;为什么纠错码有用&#34;&gt;为什么纠错码有用&lt;/h4&gt;

&lt;p&gt;与RAID或复制不同，纠错码可以保护数据不受多个驱动器故障的影响。&lt;/p&gt;

&lt;p&gt;比如，在经典的&lt;code&gt;RAID6&lt;/code&gt;中可以在损失两块盘的情况下不丢数据，然而在Minio中纠错码可以保证当一般的盘故障时依然不会影响到数据。此外，纠错码在在对象级别，并且每次就可以修复一个对象。对于&lt;code&gt;RAID&lt;/code&gt;而言，数据的修复在卷(volume)级别，这就意味比较高的修复时间。由于MinIO对每个对象单独编码，所以它可以逐步的对对象进行修复。一旦部署了存储服务器，就不需要在服务器的生命周期内更换或修复驱动器。MinIO的纠错码后端是为提高操作效率而设计的，它可以更加高效的利用硬件而达到加速的效果。&lt;/p&gt;

&lt;h4 id=&#34;什么是-bit-rot-保护&#34;&gt;什么是&lt;code&gt;Bit Rot&lt;/code&gt;保护&lt;/h4&gt;

&lt;p&gt;Bit Rot，也称为Data Rot或静默数据损坏，是当今磁盘驱动器面临的数据丢失问题。驱动器上的数据可能在不发出错误信号的情况下被损坏，这使得比特损坏比永久的硬盘驱动器故障更危险。而在Minio内部的设计中采用了高速的&lt;a href=&#34;https://github.com/minio/highwayhash&#34;&gt;HighwayHash&lt;/a&gt;校验和来保护&lt;code&gt;Bit Bot&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;drivers是如何使用纠错码的&#34;&gt;Drivers是如何使用纠错码的&lt;/h4&gt;

&lt;p&gt;MinIO将您提供的驱动器分为4、6、8、10、12、14或16个驱动器的纠错码集，因此，在你构建一个Minio集群时，需要确保提供的驱动器的数量是这些数据之一的倍数，然后每个对象都会被写入一个单一的纠错码集中。&lt;/p&gt;

&lt;p&gt;Minio会使用尽可能大的EC集(除以给定驱动器的数量)，比如，18个驱动器可以配置为3组6个驱动器，但是24个驱动器最大只能分配2组12个驱动器。&lt;/p&gt;

&lt;p&gt;驱动器的大小应该大致相同。&lt;/p&gt;

&lt;h3 id=&#34;minio集群实操&#34;&gt;Minio集群实操&lt;/h3&gt;

&lt;h4 id=&#34;使用纠错码模式运行minio服务&#34;&gt;使用纠错码模式运行minio服务&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 使用二进制方式运行有12个驱动器的minio服务
$ minio server /data1 /data2 /data3 /data4 /data5 /data6 /data7 /data8 /data9 /data10 /data11 /data12

# 使用docker方式运行有8驱动器的minio服务
$ docker run -p 9000:9000 --name minio \
  -v /mnt/data1:/data1 \
  -v /mnt/data2:/data2 \
  -v /mnt/data3:/data3 \
  -v /mnt/data4:/data4 \
  -v /mnt/data5:/data5 \
  -v /mnt/data6:/data6 \
  -v /mnt/data7:/data7 \
  -v /mnt/data8:/data8 \
  minio/minio server /data1 /data2 /data3 /data4 /data5 /data6 /data7 /data8&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以纠错码方式运行服务后，你就可以尝试将任意一半盘毁坏，依然不会影响整个系统的IO。但是&lt;code&gt;如果要求不影响写，处于正常的的驱动器个数必须大于N/2&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;分布式minio集群&#34;&gt;分布式MinIO集群&lt;/h4&gt;

&lt;p&gt;通常情况下，为了成本和效率的考虑开发同学可能会使用上述方式快速创建一个minio服务，但是从稳定性和可用性的角度来考虑，上述方式均无法保证，因此MinIO也提供了分布式的模式。&lt;/p&gt;

&lt;p&gt;分布式Minio可以让你将多块硬盘（甚至在不同的机器上）组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。&lt;/p&gt;

&lt;p&gt;分布式的Minio的优势:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;数据保护&lt;/code&gt;: 采用纠错码&lt;code&gt;erasure code&lt;/code&gt;防止多节点或者驱动器异常，采用&lt;code&gt;bit rot&lt;/code&gt;来进行数据保护。一个分布式的Minio集群最小需要4块盘(其实是纠错码要求最小4块)来驱动整个集群，当我们启动分布式集群后，纠错码会自动启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;高可用&lt;/code&gt;: 多节点组成的分布式minio可保证服务的高可用(一个N节点的分布式Minio,只要有N/2节点在线，你的数据就是安全的。不过你需要至少有N/2+1个节点才能创建新的对象。)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;一致性保障&lt;/code&gt;: MinIO在所有的IO操作中都严格遵循&lt;code&gt;read-after-write&lt;/code&gt;和&lt;code&gt;list-after-write&lt;/code&gt;一致性模型&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;运行分布式minio集群&#34;&gt;运行分布式MinIO集群&lt;/h4&gt;

&lt;p&gt;想要运行一个分布式的MinIO集群，你只需要将驱动器的位置参数传给minio指令即可，然后需要在全部节点运行相同的命令。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意事项&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的节点需要有相同的access key 和 secret key，推荐在启动之前使用&lt;code&gt;MINIO_ACCESS_KEY&lt;/code&gt;和&lt;code&gt;MINIO_SECRET_KEY&lt;/code&gt;变量来共享key&lt;/li&gt;
&lt;li&gt;MinIO创建一组4, 6, 8, 10, 12, 14 or 16个驱动器的纠错码，因此提供的驱动数量必须是前面数字的倍数&lt;/li&gt;
&lt;li&gt;MinIO会选择给定驱动中，较大的一个EC集合，比如8个驱动将会使用一个大小为8的EC集，而不是两个大小为4的EC集&lt;/li&gt;
&lt;li&gt;每一个对象都会写到一个EC集中，因此对象的分布不可能超过16个驱动&lt;/li&gt;
&lt;li&gt;MinIO集群中的所有节点应该是同构的(比如:相同的OS,相同的磁盘和相同的网络架构)&lt;/li&gt;
&lt;li&gt;MinIO分布式模式需要&lt;code&gt;fresh directories&lt;/code&gt;(即干净的目录)，如果需要可以和其他应用程序共享驱动器(使用子目录的方式)&lt;/li&gt;
&lt;li&gt;运行分布式MinIO实例的服务器之间的间隔应该小于15分钟，你可以使用&lt;code&gt;NTP&lt;/code&gt;服务来保证服务器时间同步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MINIO_DOMAIN&lt;/code&gt;环境变量应该被定义成&lt;code&gt;bucket DNS&lt;/code&gt;样式的支持(可以给每个bucket设置子域名)&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Windows&lt;/code&gt;上的分布式集群是实验性的，需要谨慎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gb4fbrthg2j30qo0f0myz.jpg&#34; alt=&#34;官方提供的有32个驱动器的32节点的分布式集群&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;一个EC Set 上包含多少个Drive是由系统自动根据集群规模算出来的，当然你可以自己去配置.&lt;/p&gt;

&lt;p&gt;我们以1个驱动器的4节点来组成集群:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# tree -L 1 /opt/app/
/opt/app/
├── minio
├── minio.conf

$ cat minio.conf
MINIO_ACCESS_KEY=BGBiao
MINIO_SECRET_KEY=BGBiao
ENDPOINTS=&amp;#34;http://10.0.0.148:9000/data/minio http://172.16.62.149:9000/data/minio http://172.16.62.150:9000/data/minio http://172.16.62.151:9000/data/minio&amp;#34;

$ cat /usr/lib/systemd/system/minio.service
[Unit]
Description=Minio
Documentation=https://docs.minio.io
Wants=network-online.target
After=network-online.target
AssertFileIsExecutable=/opt/app/minio

[Service]
EnvironmentFile=-/opt/app/minio.conf
ExecStart=/opt/app/minio server $ENDPOINTS

# Let systemd restart this service always
Restart=always
# Specifies the maximum file descriptor number that can be opened by this process
LimitNOFILE=65536
# Disable timeout logic and wait until process is stopped
TimeoutStopSec=infinity
SendSIGKILL=no
[Install]
WantedBy=multi-user.target


# 将上述配置同步到4个节点，并启动，minio实例之间会自行发现各个节点
$ systemctl restart minio&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&#34;minio分布式对象存储服务使用&#34;&gt;Minio分布式对象存储服务使用&lt;/h3&gt;

&lt;p&gt;当使用前面的方式成功运行minio的对象服务后，我们就可以使用以下几种方式进行访问:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;web&lt;/code&gt;: 默认我们可以访问实例的9000端口，通过access key和secret key进行访问实例&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mc&lt;/code&gt;: 使用minio官方提供的兼容s3的客户端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;aws-cli&lt;/code&gt;: 使用aws的客户端命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s3cmd&lt;/code&gt;: 使用3s的开源客户端执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minio-go&lt;/code&gt;: 使用minio的golang客户端操作集群&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: 当我们成功运行minio服务后，默认会提供一个简单的web管理页面.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gb5hep7kazj31zm0u0aer.jpg&#34; alt=&#34;web管理页面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们使用&lt;code&gt;mc&lt;/code&gt;客户端命令进行操作(&lt;code&gt;值得一提的是，有了mc客户端之后操作oss就如同本地操作一样方便快捷&lt;/code&gt;)&lt;/p&gt;

&lt;h4 id=&#34;minio客户端mc的使用&#34;&gt;minio客户端mc的使用&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;客户端配置管理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 添加minio云存储服务(会将数据存入~/.mc/config.json)
# mc config host add &amp;lt;ALIAS&amp;gt; &amp;lt;YOUR-S3-ENDPOINT&amp;gt; &amp;lt;YOUR-ACCESS-KEY&amp;gt; &amp;lt;YOUR-SECRET-KEY&amp;gt; &amp;lt;API-SIGNATURE&amp;gt;
$ mc config host add minio http://bgbiao.top:9000 BGBiao BGBiao S3v4&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;查看bucket&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 查看minio集群中的bucket
$ mc ls minio
[2020-01-10 20:54:19 CST]      0B test11/
[2019-07-08 19:51:02 CST]      0B test23/
[2019-07-08 20:10:58 CST]      0B test4/

# 查看bucket的内容
$ mc ls minio/test11
[2019-07-05 21:22:34 CST]   88KiB 111
[2019-07-07 11:03:21 CST]   88KiB 112
[2019-07-08 10:50:51 CST]   88KiB 113
[2019-07-08 18:17:17 CST]   88KiB 114
[2019-07-09 11:51:30 CST]   66KiB 116
[2019-07-09 14:24:23 CST]   66KiB 117.jpg
[2019-07-09 14:33:17 CST]   66KiB 118.jpg
[2019-07-09 14:52:36 CST]   66KiB 119.jpg
[2020-01-10 20:52:28 CST]  7.4KiB server.xml&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;bucket管理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 创建一个bucket
$ mc mb minio/bgbiao
Bucket created successfully `minio/bgbiao`.
$ mc ls minio/ | grep bgbiao
[2020-01-22 16:32:43 CST]      0B bgbiao/

# rb可以直接删除指定的bucket
$ mc rb minio/bgbiao
Removed `minio/bgbiao` successfully.

# tree可以打印出来bucket组织的文件系统树形结构
$ mc tree --depth 2 --files minio/bgbiao
minio/bgbiao
└─ hostname.txt

# du可以查看某个bucket或者object的大小
$ mc du minio/bgbiao
10B bgbiao
$ mc du minio/
9.1GiB&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对象管理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 将本地文件拷贝到minio的oss服务
# 并直接使用cat命令访问
$ hostname &amp;gt; hostname.txt
$ mc cp hostname.txt minio/bgbiao/
hostname.txt:         10 B / 10 B  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  132 B/s 0s%
$ mc ls minio/bgbiao/
[2020-01-22 16:33:52 CST]     10B hostname.txt
$ mc cat  minio/bgbiao/hostname.txt
localhost

# 使用pipe命令可以将标准输入的数据直接写入到minio的存储中
$ echo ${PATH} | mc pipe minio/bgbiao/path.txt
$ mc ls minio/bgbiao/
[2020-01-22 16:33:52 CST]     10B hostname.txt
[2020-01-22 16:43:43 CST]    111B path.txt
$ mc cat minio/bgbiao/path.txt
/Users/BGBiao/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/go/bin:/usr/local/soul/bin


# 受用share命令生成可供外部匿名下载的临时链接地址
# 生成后我们就可以使用共享链接在4小时内随意下载
$ mc share download --expire 4h minio/bgbiao/hostname.txt
URL: http://bgbiao.top:9000/bgbiao/hostname.txt
Expire: 4 hours 0 minutes 0 seconds
Share: http://bgbiao.top:9000/bgbiao/hostname.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=BGBiao%2F20200122%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20200122T083619Z&amp;amp;X-Amz-Expires=14400&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=ec49806b7c249bbeb140af759afeff907672ebd97637b759efd11d4f9b1a20b3

# 使用mirror指令对bucket内容进行镜像(最实用的一个指令)
# 将minio这个对象服务下的bgbiao的整个bucket的对象镜像到本地
# 使用minio的mc客户端可以在多个minio服务之间进行数据镜像
$ mc mirror minio/bgbiao .
...iao/hostname.txt:  10 B / 10 B  ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  39 B/s 0s %

# 使用find指令来直接查找内容(相对比较实用,find指令支持很多方便快捷的参数，和Linux本地的find命令内容相似)
# 查找名称为*.txt的文件并打印临时url下载地址
$ mc find minio/bgbiao/ --name &amp;#34;*.txt&amp;#34; --print {url}
http://bgbiao.top:9000/bgbiao/hostname.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=BGBiao%2F20200122%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20200122T084926Z&amp;amp;X-Amz-Expires=604800&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=a02a370575cae5d5cf92c565d02918e20d734f80afed3e5eebf5fe1433aa348a
http://bgbiao.top:9000/bgbiao/path.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;amp;X-Amz-Credential=BGBiao%2F20200122%2Fus-east-1%2Fs3%2Faws4_request&amp;amp;X-Amz-Date=20200122T084926Z&amp;amp;X-Amz-Expires=604800&amp;amp;X-Amz-SignedHeaders=host&amp;amp;X-Amz-Signature=d7d87f6a4f9d406ae02a6844574f02f6e1479215bee8401feea58e95e98b8b36
 
# diff命令可以列出两个bucket之间对象的大小，名字，时间的不同
$ mc diff . minio/bgbiao/
&amp;gt; http://bgbiao.top:9000/bgbiao/path.txt
&amp;lt; readme.md

# rm可以直接删除指定的对象(--force --recursive就相当于我们linux中的rm -rf)
$ mc rm --force --recursive   minio/bgbiao
Removing `minio/bgbiao/hostname.txt`.
Removing `minio/bgbiao/path.txt`.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;minio运维管理&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# stat可以查看minio服务的元数据信息
$ mc stat minio/bgbiao
Name      : bgbiao/
Date      : 1970-01-01 08:00:00 CST
Size      : 0 B
Type      : folder
$ mc stat minio/bgbiao/hostname.txt
Name      : hostname.txt
Date      : 2020-01-22 17:04:27 CST
Size      : 10 B
ETag      : 902f570940ba8d4b74743a3a97f5aff6-1
Type      : file
Metadata  :
  Content-Type         : text/plain
  X-Minio-Deployment-Id: 80525c40-fec3-459e-8080-6f5210548647


# retention指令可以设置指定前缀的对象的保留时间

# events指令可以查看和添加对象的事件

# watch可以实时监听对象的events

# policy用来管理匿名用户对bucket和object的访问
# 设置bgbiao这个bucket匿名用户仅可以下载(download/public/upload)
$ mc policy set download minio/bgbiao
$ mc policy list minio/bgbiao 

# admin用来管理minio服务
# mc admin info 查看minio服务基本信息
# mc admin service 重启和停止minio服务
# mc admin config  管理minio服务的配置信息
$ mc admin info minio
●  10.0.0.149:9000
   Uptime: 1 day
   Version: 2020-01-16T22:40:29Z
   Network: 4/4 OK
   Drives: 1/1 OK

●  10.0.0.150:9000
   Uptime: 1 day
   Version: 2020-01-16T22:40:29Z
   Network: 4/4 OK
   Drives: 1/1 OK

●  10.0.0.151:9000
   Uptime: 1 day
   Version: 2020-01-16T22:40:29Z
   Network: 4/4 OK
   Drives: 1/1 OK

●  10.0.0.148:9000
   Uptime: 1 day
   Version: 2020-01-16T22:40:29Z
   Network: 4/4 OK
   Drives: 1/1 OK

13 GiB Used, 2 Buckets, 166,580 Objects
4 drives online, 0 drives offline
 
# config 用来管理客户端的配置文件(还记得我们刚开始配置本地环境的时候吗)
# minio默认帮我们配置了一些公共的对象存储服务，同时也配置了一个本地的oss服务
$ mc config host list
gcs
  URL       : https://storage.googleapis.com
  AccessKey : YOUR-ACCESS-KEY-HERE
  SecretKey : YOUR-SECRET-KEY-HERE
  API       : S3v2
  Lookup    : dns

local
  URL       : http://localhost:9000
  AccessKey :
  SecretKey :
  API       :
  Lookup    : auto

minio
  URL       : http://bgbiao.top:9000
  AccessKey : BGBiao
  SecretKey : BGBiao
  API       : s3v4
  Lookup    : auto

play
  URL       : https://play.min.io
  AccessKey : Q3AM3UQ867SPQQA43P2F
  SecretKey : zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG
  API       : S3v4
  Lookup    : auto&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>思考自己的价值系统</title>
      <link>https://bgbiao.top/post/2020-%E6%80%9D%E8%80%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%B7%E5%80%BC%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sat, 18 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/2020-%E6%80%9D%E8%80%83%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%B7%E5%80%BC%E7%B3%BB%E7%BB%9F/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwgy1gazzkqu1bqj31970u0b2a.jpg&#34; alt=&#34;~美丽的布达拉宫~&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;文末有彩蛋&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;批判(&lt;code&gt;胡&lt;/code&gt;)性(&lt;code&gt;思&lt;/code&gt;)思(&lt;code&gt;乱&lt;/code&gt;)考(&lt;code&gt;想&lt;/code&gt;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在过去的几个月里，我又做了一个实验。&lt;/p&gt;

&lt;p&gt;我这个人总是有一个特点，就是当自己内心里突然出现一个比较有意思的想法时，我就会尽自己最大可能去做一个亲身实验，当然我也不知道这个特点对于我个人来说是福是祸，但每当想起能够控制自己去做一件事情的时候，就觉的特别酷。&lt;/p&gt;

&lt;p&gt;我们都知道如今的互联网有几大产品几乎占据了我们全部的生活，对我个人感触最大的就是&lt;code&gt;抖音&lt;/code&gt;和&lt;code&gt;微信&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;17年因为追&lt;code&gt;中国有嘻哈&lt;/code&gt;节目，了解到&lt;code&gt;抖音&lt;/code&gt;这个产品，那个时候抖音还没有19年这么火，但当时它们的内容以及推荐策略足以让我在卫生间的马桶上呆一个多小时(如果不是公共区域可能会更长)。&lt;/p&gt;

&lt;p&gt;你要知道人对一个东西上瘾是一件很恐怖的事情，因为不知不觉一天就会过去，而人生命的长度是有限的，想到这内心不免会有一些愧疚感(应该很多人都会这样的感觉吧)。那个时候我想办法就强制把抖音卸载了，幸亏我是一个自控力还算可以的人，算是没有在这个产品上荒废太多时光(但其实后来才发现，在这个产品里其实可以有很多&lt;code&gt;价值&lt;/code&gt;可以挖掘，不仅可以带货，也可以用来学习专业领域知识)。&lt;/p&gt;

&lt;p&gt;而微信则非常不同，这个伴随移动互联网崛起的社交软件一直在不断的&lt;code&gt;侵蚀&lt;/code&gt;我们，从一开始的&lt;code&gt;即时通讯，语音聊天，微信群，图片聊天，朋友圈，公众号，小程序，支付，搜一搜(再看)，到现在的圈子和朋友圈图文评论&lt;/code&gt;，微信生态几乎可以满足我们一天大部分的工作和生活需求。&lt;/p&gt;

&lt;p&gt;从一般人的角度来讲可能觉得这样挺好的，我们不需要在不同需求之间来回切换软件，整个工作和生活可能都觉得高效了起来，但如果你仔细想想就会发现，其实没有那么简单。&lt;/p&gt;

&lt;p&gt;在没有离开京东数科之前，曾经有段时间我一直处于被微信引导的状态。&lt;/p&gt;

&lt;p&gt;什么意思呢，就是我发现几乎只要有碎片时间就会去刷朋友圈，去看公众号的推送文章。&lt;/p&gt;

&lt;p&gt;当你通过微信这样的方式去学习和涨见识的时候，你会发现你的朋友都是能力圈周边的人，你的朋友圈也因为各种屏蔽功能只能让你看到你想看的东西，而公众号的推送一般都是我们主动关注的领域(&lt;em&gt;但通常一般主动关注公众号有80%对我个人来说是没有价值的，也就是干扰知识，这可能也是微信团队退出&lt;code&gt;搜一搜&lt;/code&gt;和&lt;code&gt;看一看&lt;/code&gt;两个功能的主要原因吧&lt;/em&gt;)。&lt;/p&gt;

&lt;p&gt;这样造成的一个结果就是我们总是会习惯性的打开微信去消耗碎片时间，而几乎很难得到一些真正有价值成体系的知识(&lt;em&gt;所以关注我公众号的兄弟们如果觉得内容没有给自己带来价值我是非常建议取关的，如果给您带来价值了可以点个&lt;code&gt;在看&lt;/code&gt;，因为这样我的推送不会干扰到您，也可以给有需要的同学带来便利&lt;/em&gt;)。&lt;/p&gt;

&lt;p&gt;讲了这么多废话，我做的小实验其实就是&lt;code&gt;关闭朋友圈&lt;/code&gt;和&lt;code&gt;公众号取关&lt;/code&gt;，通过这种主动屏蔽的方式来改变以前被微信生态绑定的习惯和状态。
&lt;em&gt;其实很佩服微信的产品，很多功能其实都是插拔式的，用户完全可以根据自己的需求来关闭某些功能，所以在&lt;code&gt;关闭朋友圈&lt;/code&gt;后丝毫不会影响微信给我们带来的便利&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;可能会有人有很多疑虑，这其实也是我这半年的思考和写该篇文章的原因，因为当我从这些碎片化的内容中剥离出来后，我能够更加聚焦到自己想关注的内容上来，从而满足自己内心的需要。&lt;/p&gt;

&lt;p&gt;写这篇文章主要想通过自己的一些思考，来不断优化自己的成长路径，同时也希望能对大家有一定帮助。&lt;/p&gt;

&lt;p&gt;接下来，我会从&lt;code&gt;工作&lt;/code&gt;,&lt;code&gt;生活&lt;/code&gt;,&lt;code&gt;运动&lt;/code&gt;,&lt;code&gt;理财&lt;/code&gt;几个方面来分享一下我这大半年的一些感悟和思考。&lt;/p&gt;

&lt;h4 id=&#34;工作&#34;&gt;工作&lt;/h4&gt;

&lt;p&gt;我是15年毕业的，去年6月底从老东家(也是第一家公司)出来的，我很幸运在一毕业能够进入一个大企业进行学习和成长，也很幸运能够加入一个比较好的团队和各种优秀的同事一起共事，这让我在整个职业生涯初期得到了飞速的成长，当然这里要非常感谢三位老领导：超哥，郑老板，还有一位可算是我的职业生涯的启蒙老师波哥。&lt;/p&gt;

&lt;p&gt;有的人可能会说，都9012年了，整个经济周期都从十年缩短到3-5年了，还能在一家互联公司呆4年，可真是&amp;rdquo;兄弟&amp;rdquo;啊。&lt;/p&gt;

&lt;p&gt;其实并不是这样的，要知道我们每个人的职业生涯都是螺旋式成长的，在过去的四年中的确会有成长瓶颈点而有想出去的想法，但考虑到自己的职业履历后都打消这种念头了，幸运的是，通常这个时候都会找到新成长途径(也多亏有个好领导)，不至于让自己四年重复了一年的工作。&lt;/p&gt;

&lt;p&gt;所以，就有了在去年中旬离开的这件事。&lt;/p&gt;

&lt;p&gt;其实在当时老板们对我都很好，而且整体待遇也相当不错，只是对于我个人而言，在相对舒适的环境里成长确实受限了些，而且在一个熟悉的环境里很多决策和思考会形成一定的固有模式，这对于一个发散型思维和批判性思维的人来说并不是一个好事。&lt;/p&gt;

&lt;p&gt;认清自己的现状和期望后，便十分果断的离开了。在这之前还有一个小插曲，就是当年在数科时有个要好的小伙伴，后来去了鹅厂，各种怂恿我出去看看，说出来后机会很多，认知也会提升很多，而我的内心其实也是非常认同的，事实也证明早出来其实是非常明智的，甚至有时在想如果我早一年出来的话，又会是怎样的。&lt;/p&gt;

&lt;p&gt;在工作这件事上，前期我的想法是很简单的，因为我主要追求的是个人成长，只需要自己努力工作，自己快速成长，至于钱的事情可能也没怎么考虑(如果遇到好领导，你的努力老板不会看不见的)，并且刚毕业的前几年，我们往往是不那么缺钱的，更缺的是一些技能和经验，毕竟这两者才是未来个人价值的基础。&lt;/p&gt;

&lt;p&gt;但其实在后面的时间，你会发现钱越来越重要了，因为我们不断面临着买房，结婚以及身体上的压力，而此时并不一定是领导或者公司给你的报酬幅度降低了，而可能是你所处的大环境限制了你所拿到的报酬。&lt;/p&gt;

&lt;p&gt;所以，择机选择一个新的环境，新的方向去继续努力也不失为一种良策，这就好比在2018-2019年整体经济形势不景气的大背景下，很多企业依然保持着高速的成长，那我们要是能够选择一个好的企业，努力工作，闷声发大财不也挺香么(&lt;em&gt;不过也需要谨慎，好的企业不一定一直好，也不容易选择&lt;/em&gt;)，毕竟我们这一代人努力工作一方面是为了满足自己的成就感，另外一方面是为了更好的品质生活(这不得是用钱来换么)，前者通常来讲只要个人自驱力强，很容易在工作中找到成就感，而后者在职业生涯中往往需要依靠自身努力和所处的企业大环境，两者缺一都很难实现(当然也不排除那些不怎么努力但是运气绝佳的人)。&lt;/p&gt;

&lt;p&gt;看到这里的人，或许会有些好奇，我换到了什么企业，做什么工作。&lt;/p&gt;

&lt;p&gt;实际上，从数科离开后，我加入了一家创业公司，还是做运维相关的事，但不同的是在创业公司的整个基础设施都是云化的，在未来整个云计算的大背景，做和云相关的东西至少不会掉队，另外整个运维体系化建设还很原始，正好可以将这几年经历过的也都落地一次，从零将整个运维体系闭环走通(实际上在任何工作中，整个生态或商业闭环的能力其实是相当重要的)。&lt;/p&gt;

&lt;p&gt;当然，还有比较重要的一点是，我们公司的产品更多是面向Z世代人群的，整个互联网的发展史告诉我未来的战场是面向年轻人市场的，所以接触接触年轻人们的世界我觉的对于我们这个当叔叔年级的人来说是有一定帮助的，就像一个B站年会会对它的市值造成那么大影响，我们得去学着理解年轻人的世界不是吗？&lt;/p&gt;

&lt;p&gt;在工作这块我的感悟有以下几点:
- 1.如果你是有想法，自驱力较强的人，没必要为了履历呆够3-5年，外面的世界很大(没想的那么好，但也没有大家说的那么差)，并且这个世界正在&lt;code&gt;微服务&lt;/code&gt;化
- 2.选择一个&lt;code&gt;&amp;quot;有未来&amp;quot;&lt;/code&gt;的企业(即坡道够长)
- 3.尽可能选择一个自己喜欢的方向和能让自己有成就感的事情(不要一味追求利益)，并持续下去&lt;/p&gt;

&lt;p&gt;所以，我目前来说还是做着我比较喜欢的运维相关的工作(Ops也好，DevOps也罢，亦或者是SRE)，本质的内容还是帮助业务快速发展，但其实可能会更多的从&lt;code&gt;技术、运营，甚至营销&lt;/code&gt;等多方面来辅助工作执行。&lt;/p&gt;

&lt;h4 id=&#34;生活&#34;&gt;生活&lt;/h4&gt;

&lt;p&gt;生活上我一直是一个不太讲究的人，但也时常会有一些比较喜欢的东西或者想要去体验的事情，虽然很多东西最后都是浅尝辄止，但是不去尝试，又如何知道自己曾经心心念的东西为何般。&lt;/p&gt;

&lt;p&gt;所以说，人嘛，在生活中总得有一个比较喜欢的事情去做。&lt;/p&gt;

&lt;p&gt;比如说曾经的我，工作就是我全部的生活，不仅仅是工作能够带来给我成就感，还有重要一点是，任何我们想象中美好的生活都是需要很多成本的，一切都是为了未来美好的生活。&lt;/p&gt;

&lt;p&gt;而现在我也会在空闲时间适当的去看一些可以引发思考的节目，电视剧，甚至为了想了解年轻人的世界而去关注一些娱乐节目(当然很多都是向女票请教的)。&lt;/p&gt;

&lt;p&gt;女朋友也找到一个自己喜欢的事(她说喜欢做饭😸)，并且在不断的学习和进步。&lt;/p&gt;

&lt;p&gt;同时，我们会在日常生活之外的时间定期去咖啡馆学习，一起共同成长。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;不得不说家附近有咖啡馆真的是相当方便，通常在星巴克之类的咖啡馆长坐的人大部分都是来学习的，我们看到的基本上都是抱着电脑或者书本在做自己的事，点一杯咖啡，戴一个耳机，自己尽情做自己的事就好。虽然可能这样下来整个开销大了，但其实做事的效率却是很高的，这种高效和快速的成长是无法用金钱的成本来衡量的，因为说不定哪天老板就突然给加薪了呢。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对了，在过去的几个月里我还给自己找了个事，学&lt;code&gt;架子鼓&lt;/code&gt;，这件事情可算得上从小一直心心念的东西了，但迫于经济和地域条件一直未曾尝试，虽然不知道能不能学会，能学多久，但我还是发自内心的比较喜欢摇滚，比较喜欢这个乐器，希望2020年能够有一定的成绩。&lt;/p&gt;

&lt;h3 id=&#34;运动&#34;&gt;运动&lt;/h3&gt;

&lt;p&gt;工作是为了更好的生活，生活的目的又是不断去探知这个世界，所以健康的身体就成为了最基础的保障，所谓身体是革命的本钱嘛。我在大学时期刚开始跑步时也是为了不感冒(每次感冒就会鼻炎)，直到后面真正爱上了跑步，就会开心也跑，痛苦也跑。&lt;/p&gt;

&lt;p&gt;所以在19年年初和跑团的兄弟们定了契约之后，基本在每个月都会去争取完成100km的任务(只有7月差了5km，到新公司第一个月的最后一天加了个夜班)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwgy1gazzcfhzz1j30ku112n06.jpg&#34; alt=&#34;19年单月跑量&#34; /&gt;&lt;/p&gt;

&lt;p&gt;遗憾的是，19年没有参加过马拉松(北马没中签)，而越野跑也仅跑过一个50km和一个打5折的50km。&lt;/p&gt;

&lt;p&gt;不过，令我比较兴奋的是，以前动不动各种腰痛，颈椎痛，基本很少出现了，以前买的电脑桌自从换工作后也没在用过，我想这可能也是坚持定量运动一个最大的好处吧。&lt;/p&gt;

&lt;p&gt;另外，去年给自己定的目标是挑战崇礼168KM的越野跑，不过因为工作的事情无法参赛，今年提前规划了赛事，如果不出意外会跑完TNF100和崇礼130KM两个越野赛事。其他赛事估计看运气和时间吧，日常的运动量打算继续保持至少100km的跑量(不过1月应该不行了，春节要进藏，不能瞎蹦跶)。&lt;/p&gt;

&lt;p&gt;20年会继续坚持运动，如果有可能，会带着女朋友一起运动，毕竟健康的身体，好看的身材大家都想拥有。&lt;/p&gt;

&lt;h3 id=&#34;理财&#34;&gt;理财&lt;/h3&gt;

&lt;p&gt;理财这件事情是我在过去一年都是比较重视的，但也仅限于基金和股票理财。&lt;/p&gt;

&lt;p&gt;大家都说2018-2019是这几年市场最低迷的两年，的确整个经济的波动在金融市场也表现的淋漓尽致，而我所持仓的理财标的物也是有赔有赚，基金整体上来讲还算不错，所以也想在这里和大家分享一些心路历程。&lt;/p&gt;

&lt;p&gt;我是怎么开始有理财意识的呢？&lt;/p&gt;

&lt;p&gt;源于大学时期，由于我就读的是财经院校，并且会学习金融类相关课程(也会学习支付相关的东西)，有老师就教导我们要&lt;code&gt;有才&lt;/code&gt;，也要&lt;code&gt;有财&lt;/code&gt;，基本上从那个时候就慢慢培养了自己的理财意识(老师会让我们去买余额宝之类的产品来辅助学习支付工具)。&lt;/p&gt;

&lt;p&gt;刚开始毕业那会，会选一些类似P2P理财之类的产品，基本上年化可以保持在4%-6%之间，通常情况会把每个月工资的一部分放进去，直到后来P2P产品的不断倒台，才完全从里面抽出来。&lt;/p&gt;

&lt;p&gt;但是抽出来后会发现，那点钱放在银行账户里收益太低，拿出来又不足以去购买其他资产，索性就找到在银行工作的朋友，让帮忙指导下基金理财，后来也就入了基金理财的坑，到目前为止整体的基金理财平均收益可以保持在10%左右，个人觉得还算是可以的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwgy1gazlk45r55j30ku11241x.jpg&#34; alt=&#34;天天基金上的持仓收益&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwgy1gazljvr5oej30ku1120uk.jpg&#34; alt=&#34;支付宝上的持仓收益&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中图1中可以看到我个人的持仓年涨幅为&lt;code&gt;18.77%&lt;/code&gt;，而&lt;code&gt;沪深300的涨幅为36.07%&lt;/code&gt;，由于我买的都是股票型基金，所以也就意味着在去年一年整个A股市场基本是属于稳定上升状态的，这也就是我在&lt;code&gt;工作&lt;/code&gt;总结中说的&lt;code&gt;外面的环境没想像的那么好，但也没有大家说的那么差&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为不论市场好坏，总有一些东西是必须品，也总会存在一些持续上升的价值系统。&lt;/p&gt;

&lt;p&gt;在过去大半年基金理财的收益还算不错后，我开始向几位小伙伴推荐，从前几天来看小伙伴们的基金理财收益也基本达到7%-10%左右，这也是促使我想要写这个总结的动力。&lt;/p&gt;

&lt;p&gt;在经历过两年多的基金理财后，我总结了以下几个点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.选一只蓝筹鸡，至于如何选鸡，我之前写过一篇文章&lt;a href=&#34;https://mp.weixin.qq.com/s/swAOiIT-tWkpC0wa24C51Q&#34;&gt;门外汉如何选鸡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2.设置每月投资资金的5%-10%到定投中，并坚持下去&lt;/li&gt;
&lt;li&gt;3.以月或周为单位进行复盘，进行适当调仓&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最重要的我认为属于选鸡，因为通常整个基金背后的管理是较为复杂的，一般基金背后的团队和投资物都会相对来说比较稳定，所以前期选好一只基金后，基本上持续定投，只需等待复利效应了。&lt;/p&gt;

&lt;p&gt;股票投资我是投了A股，港股和美股的，基本上各自都有盈亏，美股整体上是亏损的，下面来说说我这一年在股票上学到东西。&lt;/p&gt;

&lt;p&gt;A股我在年初是买了几家公司的，其中包括了&lt;code&gt;京东方A&lt;/code&gt;，&lt;code&gt;苏宁易购&lt;/code&gt;，&lt;code&gt;达华智能&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;买这几只股票是因为看好5G，智能时代和新零售市场，结果却发现在不断的跌，后来在合适的点不断清仓，最终基本全部撤离(苏宁易购还剩了点)，后来总结的一点就是虽然整个5G和智能时代可能是未来的方向，但是由于基础设施或者商业化方案不成熟，对应的股票并不能在当时表现出自己的价值，再加上前期自己只是抱着学习的态度去炒股的，希望能在实践中学习并保留资产，所以就做了快速止损的操作。&lt;/p&gt;

&lt;p&gt;不过从现在来看，那几只股票到现在为止都是涨的(也再一次说明2019年市场没有太差).&lt;/p&gt;

&lt;p&gt;港股过去一年买卖过几家，比较出名的有&lt;code&gt;新东方在线&lt;/code&gt;,&lt;code&gt;美团&lt;/code&gt;,&lt;code&gt;小米&lt;/code&gt;,&lt;code&gt;呷哺呷哺&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;新东方在线我看中的是当前的K12领域，并且有母公司新东方已经在美股上市，线下资源较为丰富，在移动互联网+短视频的双重作用下，新东方在线应该不会太差，事实也证明了它非常不错(我当时10港币买的最后11港币卖出，当前是25港币😅)。&lt;/p&gt;

&lt;p&gt;美团是因为属于互联网新股，并且属于占领整个年轻人生活生态的一家公司，在整个懒人时代，美团外卖着实帮助了很多年轻人，想着整体的价值逻辑和我的认知逻辑比较相符，所以也买卖了一波(50港币买入，60港币卖出，当前是111港元😓)。&lt;/p&gt;

&lt;p&gt;现在持仓的还有小米和呷哺呷哺，不要问我为什么那么快就轻易卖了前两只股票，当然和自己的认知有一定关系，但其实更多在于子弹不够吧，还是前面提到的逻辑，我比较看好智能时代，而小米的整个生态规划都是相当符合我的认知的，所以为了能够赶时机重仓小米，在前两只还不赔的情况下作了快速调仓，然而小米却一度让它的股民失望，其实原因还是在于智能时代的基础设施和条件不具备，导致当下的反应比较疲，不过从当前的状态来看，也算是还不错(目前持仓收益40%左右，而且我相信它会继续上涨)。&lt;/p&gt;

&lt;p&gt;呷哺呷哺，想必在北京的小伙伴都比较熟悉，一个时尚小火锅，当年没毕业时，就听一位老师说过呷哺呷哺，后来这几年也经常去吃，在时尚火锅里算是性价比比较高的，后来开始炒股后一直关注该股票，直到后来到达心里认为的底部价格后开始入仓(当前收益30%左右)。&lt;/p&gt;

&lt;p&gt;美股过去一年买卖的比较多，当然也赔的比较多，当前还持有的欧朋、趣店、蔚来、蘑菇街、如涵控股、京东，不过因为过程中的心理问题，现在几乎全部清仓。&lt;/p&gt;

&lt;p&gt;美股是最开始玩的，最早是因为在京东工作(讲真，当时看到京东做的很多事情，觉得都特别有价值)，就开始买卖自家的股票，但后来发生一些列乌龙事件，在去年年初市值暴跌(最低19刀)，不过到现在整个价值也算平稳(40刀)。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;蔚来&lt;/code&gt;是看好电动汽车，毕竟属于国产领域的特斯拉，个人觉得在电动车市场，还算是相当不错的。&lt;code&gt;如涵控股&lt;/code&gt;是看好整个网红电商经济，经济的本质是交易，而整个电商经济中除了品牌效益之外通过网红带货也是一个相当不错的模式(这个其实和当前的直播带货我认为是一套逻辑)，而这两只股票都因为曾经跌到太低，心里接受不了而在初涨时出仓，当前价格都远超于当时卖出价格。&lt;/p&gt;

&lt;p&gt;剩下的几只股票均为无脑买入，为啥叫无脑买入呢，就是关注了几天股票，发现跌了很多，个人感觉应该可以抄底了，但往往我们个人投资者是无法判断低点的，所以整个美股市场当前整体还是赔着。&lt;/p&gt;

&lt;p&gt;从过去一年的股票交易经历中，我也总结了几点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;永远不要抄底，因为散户永远不知道低点在哪里&lt;/li&gt;
&lt;li&gt;炒股过程中&lt;code&gt;逻辑&amp;gt;股票指标&amp;gt;股票相关数据&amp;gt;财报结论&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;要努力工作，先要保证有足够的资金池&lt;/li&gt;
&lt;li&gt;普通人炒股还是要关注价值投资&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，一句话总结就是&lt;code&gt;&amp;quot;你赚的前都是你对这个世界认知的变现；你赔的每一分钱，都是因为你还不太了解这个世界&amp;quot;.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;过去的半年，不论是在工作、生活还是其他方面对我来说都算得上收获颇丰，希望把这些思考和感受写下来来不断鞭策自己，同时希望2020年能够更上一层路。&lt;/p&gt;

&lt;p&gt;也希望有志青年(技术从业者，理财爱好者，跑步爱好者)一起交流，一起学习，共同成长。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwgy1gb01r8pzz7j30u01h9qac.jpg&#34; alt=&#34;看到这了，领个红包再走吧&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>Golang中的逃逸分析</title>
      <link>https://bgbiao.top/post/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</link>
      <pubDate>Thu, 16 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/golang-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/</guid>
      
        <description>

&lt;blockquote&gt;
&lt;p&gt;背景:说实话，使用Golang来作为日常的cmdline程序开发也有一两年了，之前作为一名Ops来说，会使用Golang去开发一些常用的工具来实现生产环境的各种常规操作以及日常运维管理，而对于整个Golang语言内部的一些细节都不甚了解。但随着对Ops要求的提高，以及向SRE理念转型的需要，我们越来越需要深入理解一些内部底层的原理，这样在我们去管理的我们的Kubernetes集群，或者其他的一些内部系统时才能真正做到游刃有余。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Golang中，一个对象最终是分配到&lt;code&gt;堆&lt;/code&gt;还是&lt;code&gt;栈&lt;/code&gt;呢，接下来我们就一起通过&lt;code&gt;逃逸分析&lt;/code&gt;来一起学习学习。&lt;/p&gt;

&lt;h3 id=&#34;概念介绍&#34;&gt;概念介绍&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;逃逸分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;逃逸分析&lt;/code&gt;是编译器用来确定由程序创建的值所处位置的过程。具体来说，&lt;code&gt;编译器执行静态代码分析&lt;/code&gt;，以确定是否可以将值放在构造函数的&lt;code&gt;栈(帧)&lt;/code&gt;上，或者该值是否必须&lt;code&gt;逃逸&lt;/code&gt;到&lt;code&gt;堆&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;所以，更通俗一点讲，逃逸分析就是确定一个对象是要放在&lt;code&gt;堆&lt;/code&gt;还是&lt;code&gt;栈&lt;/code&gt;上，一般遵循如下规则:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.是否有非局部调用(对象定义之外的调用).即:如果有可能被&lt;code&gt;引用&lt;/code&gt;，那通常会被分配到堆上，否则就在&lt;code&gt;栈上&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2.如果对象太大(即使没有被引用),无法放在栈区也是可能放到&lt;code&gt;堆&lt;/code&gt;上的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结起来就是: &lt;code&gt;如果在函数外部引用，必定在堆中分配;如果没有外部引用，优先在栈中分配;如果一个函数返回的是一个（局部）变量的地址，那么这个变量就发生逃逸&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;避免逃逸的好处:&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.减少gc的压力，不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要gc标记清除&lt;/li&gt;
&lt;li&gt;2.逃逸分析完后可以确定哪些变量可以分配在栈上，栈的分配比堆快，性能好(系统开销少)&lt;/li&gt;
&lt;li&gt;3.减少动态分配所造成的内存碎片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如何进行逃逸分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; Golang程序中是在编译阶段确定逃逸的，而非运行时，因此我们可以使用&lt;code&gt;go build&lt;/code&gt;的相关工具来进行逃逸分析.&lt;/p&gt;

&lt;p&gt;分析工具:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.通过编译工具查看详细的逃逸分析过程(&lt;code&gt;go build -gcflags &#39;-m -l&#39; main.go&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;2.通过反编译命令查看&lt;code&gt;go tool compile -S main.go&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;编译参数介绍(-gcflags):&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-N&lt;/code&gt;: 禁止编译优化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;: 禁止内联(可以有效减少程序大小)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt;: 逃逸分析(最多可重复四次)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-benchmem&lt;/code&gt;: 压测时打印内存分配统计&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;堆是除栈之外的第二个内存区域，用于存储值，&lt;code&gt;全局变量、内存占用大的局部变量、发生了逃逸的局部变量存在的地方就是堆&lt;/code&gt;，这块的内存没有特定的结构，也没有固定大小，可以根据需要进行调整(但也造成管理成本)，因此堆不像栈那样是自清理的，使用这个内存的成本更大(一般各个语言都会有自己的GC机制，在Golang中会使用&lt;code&gt;三色标记法&lt;/code&gt;来进行堆内存的垃圾回收)。&lt;/p&gt;

&lt;p&gt;首先，成本与垃圾收集器(GC)有关，垃圾收集器必须参与进来以保持该区域的清洁。当GC运行时，它将使用25%的可用CPU资源。此外，它可能会产生微秒级的“stop the world”延迟。拥有GC的好处是你不需要担心内存的管理问题，因为内存管理是相当复杂、也容易出错的。&lt;/p&gt;

&lt;p&gt;堆上的值构成Go中的内存分配。这些分配对GC造成压力，因为堆中不再被指针引用的每个值都需要删除。需要检查和删除的值越多，GC每次运行时必须执行的工作就越多。因此，GC算法一直在努力在堆的大小分配和运行速度之间寻求平衡。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;堆是进程级别的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在程序中，每个函数块都会有自己的&lt;code&gt;内存区域&lt;/code&gt;用来存自己的&lt;code&gt;局部变量&lt;/code&gt;（内存占用少）、返回&lt;code&gt;地址、返回值&lt;/code&gt;之类的数据，这一块内存区域有特定的结构和寻址方式，&lt;code&gt;大小在编译时已经确定&lt;/code&gt;，寻址起来也十分迅速，开销很少。&lt;/p&gt;

&lt;p&gt;这块内存地址称为&lt;code&gt;栈&lt;/code&gt;，&lt;code&gt;栈是线程级别&lt;/code&gt;的，&lt;code&gt;大小在创建的时候已经确定&lt;/code&gt;，所以当数据太大的时候，就会发生&amp;rdquo;stack overflow&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在Golang程序中，函数都是运行在&lt;code&gt;栈&lt;/code&gt;上的，在栈上声明临时变量分配内存，函数运行完成后回收该段栈空间，并且每个函数的栈空间都是独立的，其他代码不可访问的。但是在某些场景下，&lt;code&gt;栈上的空间&lt;/code&gt;需要在该函数被释放后依旧能访问到(函数外调用)，这时候就涉及到内存的逃逸了，而逃逸往往会对应对象的内存分配到堆上.&lt;/p&gt;

&lt;h3 id=&#34;逃逸分析示例&#34;&gt;逃逸分析示例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.示例-参数泄露&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;测试代码&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 定义一个简单的结构体
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;age&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;webSite&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 获取用户信息
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetUserInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;u&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 获取用户名称
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;u&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 初始化user结构体的指针对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;BGBiao&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;https://bgbiao.top&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;GetUserInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;GetName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;逃逸分析&lt;/code&gt;来进行内存分析&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ go build -gcflags &amp;#39;-m -m  -l&amp;#39; taoyi.go
# command-line-arguments
./taoyi.go:21:18: leaking param: u to result ~r1 level=0
./taoyi.go:25:14: leaking param: u to result ~r1 level=1
./taoyi.go:31:31: main &amp;amp;user literal does not escape&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由上述输出的&lt;code&gt;leaking param&lt;/code&gt;可以看到，在&lt;code&gt;GetUserInfo&lt;/code&gt;和&lt;code&gt;GetName&lt;/code&gt;函数中的&lt;code&gt;指针变量u&lt;/code&gt;是一个泄露参数，在两个函数中均没有对&lt;code&gt;u&lt;/code&gt;进行变量操作，就直接返回了变量内容，因此最后的该变量&lt;code&gt;user&lt;/code&gt;并没有发生逃逸，&lt;code&gt;&amp;amp;user&lt;/code&gt;对象还是作用在了&lt;code&gt;main()&lt;/code&gt;函数中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.示例-未知类型&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个时候，我们把上面的代码稍微改动一下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;....
....
func main() {
    user := &amp;amp;user{&amp;#34;BGBiao&amp;#34;,18,&amp;#34;https://bgbiao.top&amp;#34;}
    fmt.Println(GetUserInfo(user))
    fmt.Println(GetName(user))
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;再次进行逃逸分析:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ go build -gcflags &amp;#39;-m -m  -l&amp;#39; taoyi.go
# command-line-arguments
./taoyi.go:21:18: leaking param: u to result ~r1 level=0
./taoyi.go:25:14: leaking param: u to result ~r1 level=1
./taoyi.go:31:31: &amp;amp;user literal escapes to heap
./taoyi.go:32:16: main ... argument does not escape
./taoyi.go:32:28: GetUserInfo(user) escapes to heap
./taoyi.go:33:16: main ... argument does not escape
./taoyi.go:33:24: GetName(user) escapes to heap&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由上可以发现我们的指针对象&lt;code&gt;&amp;amp;user&lt;/code&gt;在该程序中发生了逃逸，具体是在&lt;code&gt;GetUserInfo(user)&lt;/code&gt;和&lt;code&gt;GetName(user)&lt;/code&gt;发生了逃逸.&lt;/p&gt;

&lt;p&gt;这是为什么呢？怎么加了个&lt;code&gt;fmt.Println&lt;/code&gt;之后对象就发生了逃逸呢?&lt;/p&gt;

&lt;p&gt;其实主要原因为&lt;code&gt;fmt.Println&lt;/code&gt;函数的原因:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;func Println(a ...interface{}) (n int, err error)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到&lt;code&gt;fmt.Println(a)&lt;/code&gt;函数中入参为&lt;code&gt;interface{}&lt;/code&gt;类型，在编译阶段编译器无法确定其具体的类型。因此会产生逃逸，最终分配到堆上(最本质的原因是interface{}类型一般情况下底层会进行&lt;code&gt;reflect&lt;/code&gt;，而使用的&lt;code&gt;reflect.TypeOf(arg).Kind()&lt;/code&gt;获取接口类型对象的底层数据类型时发生了堆逃逸，最终就会反映为当入参是空接口类型时发生了逃逸)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.示例-指针&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此时，我们再小改点代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 返回结构体对象的指针，此时就会产生逃逸
func GetUserInfo(u user) (*user) {
    return &amp;amp;u
}

func main() {
    user := user{&amp;#34;BGBiao&amp;#34;,18,&amp;#34;https://bgbiao.top&amp;#34;}
    GetUserInfo(user)
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;逃逸分析:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;$ go build -gcflags &amp;#39;-m -m  -l&amp;#39; taoyi.go
# command-line-arguments
./taoyi.go:21:18: moved to heap: u

# 查看汇编代码(可以看到有个CALL	runtime.newobject(SB)的系统调用)
$ go tool compile -S taoyi.go | grep taoyi.go:21
	0x0000 00000 (taoyi.go:21)	TEXT	&amp;#34;&amp;#34;.GetUserInfo(SB), ABIInternal, $40-48
	0x0000 00000 (taoyi.go:21)	MOVQ	(TLS), CX
	0x0009 00009 (taoyi.go:21)	CMPQ	SP, 16(CX)
	0x000d 00013 (taoyi.go:21)	JLS	147
	0x0013 00019 (taoyi.go:21)	SUBQ	$40, SP
	0x0017 00023 (taoyi.go:21)	MOVQ	BP, 32(SP)
	0x001c 00028 (taoyi.go:21)	LEAQ	32(SP), BP
	0x0021 00033 (taoyi.go:21)	FUNCDATA	$0, gclocals·fb57040982f53920ad6a8ad662a1594f(SB)
	0x0021 00033 (taoyi.go:21)	FUNCDATA	$1, gclocals·263043c8f03e3241528dfae4e2812ef4(SB)
	0x0021 00033 (taoyi.go:21)	FUNCDATA	$2, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)
	0x0021 00033 (taoyi.go:21)	PCDATA	$0, $1
	0x0021 00033 (taoyi.go:21)	PCDATA	$1, $0
	0x0021 00033 (taoyi.go:21)	LEAQ	type.&amp;#34;&amp;#34;.user(SB), AX
	0x0028 00040 (taoyi.go:21)	PCDATA	$0, $0
	0x0028 00040 (taoyi.go:21)	MOVQ	AX, (SP)
	0x002c 00044 (taoyi.go:21)	CALL	runtime.newobject(SB)
	0x0031 00049 (taoyi.go:21)	PCDATA	$0, $1
	0x0031 00049 (taoyi.go:21)	MOVQ	8(SP), AX
	0x0036 00054 (taoyi.go:21)	PCDATA	$0, $-2
	0x0036 00054 (taoyi.go:21)	PCDATA	$1, $-2
	0x0036 00054 (taoyi.go:21)	CMPL	runtime.writeBarrier(SB), $0
	0x003d 00061 (taoyi.go:21)	JNE	104
	0x003f 00063 (taoyi.go:21)	MOVQ	&amp;#34;&amp;#34;.u+48(SP), CX
	0x0044 00068 (taoyi.go:21)	MOVQ	CX, (AX)
	0x0047 00071 (taoyi.go:21)	MOVUPS	&amp;#34;&amp;#34;.u+56(SP), X0
	0x004c 00076 (taoyi.go:21)	MOVUPS	X0, 8(AX)
	0x0050 00080 (taoyi.go:21)	MOVUPS	&amp;#34;&amp;#34;.u+72(SP), X0
	0x0055 00085 (taoyi.go:21)	MOVUPS	X0, 24(AX)
	0x0068 00104 (taoyi.go:21)	PCDATA	$0, $-2
	0x0068 00104 (taoyi.go:21)	PCDATA	$1, $-2
	0x0068 00104 (taoyi.go:21)	MOVQ	AX, &amp;#34;&amp;#34;.&amp;amp;u+24(SP)
	0x006d 00109 (taoyi.go:21)	LEAQ	type.&amp;#34;&amp;#34;.user(SB), CX
	0x0074 00116 (taoyi.go:21)	MOVQ	CX, (SP)
	0x0078 00120 (taoyi.go:21)	MOVQ	AX, 8(SP)
	0x007d 00125 (taoyi.go:21)	LEAQ	&amp;#34;&amp;#34;.u+48(SP), CX
	0x0082 00130 (taoyi.go:21)	MOVQ	CX, 16(SP)
	0x0087 00135 (taoyi.go:21)	CALL	runtime.typedmemmove(SB)
	0x0091 00145 (taoyi.go:21)	JMP	89
	0x0093 00147 (taoyi.go:21)	NOP
	0x0093 00147 (taoyi.go:21)	PCDATA	$1, $-1
	0x0093 00147 (taoyi.go:21)	PCDATA	$0, $-1
	0x0093 00147 (taoyi.go:21)	CALL	runtime.morestack_noctxt(SB)
	0x0098 00152 (taoyi.go:21)	JMP	0&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由以上输出可以看到在&lt;code&gt;GetUserInfo(u user)&lt;/code&gt;函数中的对象u已经被移到&lt;code&gt;堆&lt;/code&gt;上了，这是因为该函数返回的是&lt;code&gt;指针对象&lt;/code&gt;，引用对象被返回到方法之外了(此时该引用对象可以在外部被调用和修改)，因此编译器会把该对象分配到堆上(否则方法结束后，局部变量被回收岂不是很惨)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.示例-综合案例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;BGBiao&amp;#34;&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;build&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gcflags&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;arguments&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;does&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在上面第三个示例中我们提到，当返回对象是&lt;code&gt;指针类型&lt;/code&gt;(引用对象)时，就会发现逃逸，但上面的示例其实告诉我们虽然&lt;code&gt;*name&lt;/code&gt;是一个指针类型，但是并未发生逃逸，这是因为&lt;code&gt;该引用类型未被外部使用&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;但是又如第二个示例中所说，如果我们在上面的示例中增加&lt;code&gt;fmt.Println(name)&lt;/code&gt;后，会发现该实例又会出现逃逸.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;:虽然当使用fmt.Println的时候又会出现逃逸，但是当使用fmt.Println(*name)和fmt.Println(name)，也是不同的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;demo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;BGBiao&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;build&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gcflags&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;arguments&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;does&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;argument&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;does&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escapes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由上述输出可看到，当使用引用类型来获取底层的值时，在&lt;code&gt;fmt.Println&lt;/code&gt;的入参处&lt;code&gt;*name&lt;/code&gt;发生了逃逸.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;demo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;BGBiao&amp;#34;&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;build&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gcflags&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;line&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;arguments&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escapes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;argument&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;does&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escape&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taoyi&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;escapes&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;而这次我们使用&lt;code&gt;fmt.Println(name)&lt;/code&gt;来输出底层值，就会发现变量&lt;code&gt;name&lt;/code&gt;在初始化的时候就会出现逃逸&lt;code&gt;new(string)&lt;/code&gt;，&lt;/p&gt;

&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;

&lt;p&gt;通过上面的概念和实例分析，我们基本知道了逃逸分析的概念和规则，并且大概知道何时，那种对象会被分配到堆或栈内存中，在实际情况中可能情况会更加复杂，需要具体分析。&lt;/p&gt;

&lt;p&gt;不过，有如下几点可能在我们实际使用过程中要注意下:
- 静态分配到栈上，性能一定比动态分配到堆上好
- 底层分配到堆，还是栈。实际上对你来说是透明的，不需要过度关心
- 每个 Go 版本的逃逸分析都会有所不同（会改变，会优化)
- 直接通过&lt;code&gt;go build -gcflags &#39;-m -l&#39;&lt;/code&gt; 就可以看到逃逸分析的过程和结果
- 到处都用&lt;code&gt;指针传递并不一定是最好的&lt;/code&gt;，要用对
- map &amp;amp; slice 初始化时，预估容量，避免由扩展导致的内存分配。但是如果太大（10000）也会逃逸，因为栈的空间是有限的&lt;/p&gt;

&lt;h3 id=&#34;思考&#34;&gt;思考&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数传递指针真的比传值效率高吗？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内存碎片化问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实际项目基本都是通过 &lt;code&gt;c := make([]int, 0, l)&lt;/code&gt; 来申请内存，长度都是不确定的，自然而然这些变量都会申请到堆上面了.&lt;/p&gt;

&lt;p&gt;Golang使用的垃圾回收算法是『标记——清除』.&lt;/p&gt;

&lt;p&gt;简单得说，就是程序要从操作系统申请一块比较大的内存，内存分成小块，通过链表链接。&lt;/p&gt;

&lt;p&gt;每次程序申请内存，就从链表上面遍历每一小块，找到符合的就返回其地址，没有合适的就从操作系统再申请。如果申请内存次数较多，而且申请的大小不固定，就会引起内存碎片化的问题。&lt;/p&gt;

&lt;p&gt;申请的堆内存并没有用完，但是用户申请的内存的时候却没有合适的空间提供。这样会遍历整个链表，还会继续向操作系统申请内存。这就能解释我一开始描述的问题，申请一块内存变成了慢语句。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>深入Gin框架内幕2</title>
      <link>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%952/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%952/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;在上一篇文章&lt;a href=&#34;https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95/&#34;&gt;深入gin框架内幕(一)&lt;/a&gt;中，主要介绍了Gin框架中是如何创建一个HTTP服务以及内部的核心结构和常用的一些结构体方法，并在最后以一个简单的示例来详细讲解Gin框架内部具体是如何运行的，但是在最后我们会发现使用了一个&lt;code&gt;Context&lt;/code&gt;引用对象的一些方法来返回具体的HTTP响应数据，在本篇文章中，我们将继续学习和分析Gin框架内幕。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在开始分析之前，我们先简单回顾一下上一个章节中讲到的Gin框架中的几个核心的结构.&lt;/p&gt;

&lt;h3 id=&#34;gin框架中的几个核心结构&#34;&gt;Gin框架中的几个核心结构&lt;/h3&gt;

&lt;p&gt;Gin框架中的几个重要的模型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Engine&lt;/code&gt;: 用来初始化一个&lt;code&gt;gin&lt;/code&gt;对象实例，在该对象实例中主要包含了一些框架的基础功能，比如日志，中间件设置，路由控制(组)，以及handlercontext等相关方法.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L54&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Router&lt;/code&gt;: 用来定义各种路由规则和条件，并通过HTTP服务将具体的路由注册到一个由context实现的handler中&lt;/li&gt;
&lt;li&gt;Context: &lt;code&gt;Context&lt;/code&gt;是框架中非常重要的一点，它允许我们在中间件间共享变量，管理整个流程，验证请求的json以及提供一个json的响应体. 通常情况下我们的业务逻辑处理也是在整个Context引用对象中进行实现的.&lt;/li&gt;
&lt;li&gt;Bind: 在Context中我们已经可以获取到请求的详细信息，比如HTTP请求头和请求体，但是我们需要根据不同的HTTP协议参数来获取相应的格式化
数据来处理底层的业务逻辑，就需要使用&lt;code&gt;Bind&lt;/code&gt;相关的结构方法来解析context中的HTTP数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-gin框架对http响应数据的处理&#34;&gt;1.Gin框架对HTTP响应数据的处理&lt;/h4&gt;

&lt;p&gt;我们在&lt;a href=&#34;https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%95/&#34;&gt;深入Gin框架内幕(一)&lt;/a&gt;中，以一个简单的Gin实例来具体讲解它内部是如何创建一个Http服务，并且注册一个路由来接收用户的请求，在示例程序中我们使用了&lt;code&gt;Context&lt;/code&gt;引用对象的&lt;code&gt;String&lt;/code&gt;方法来处理HTTP服务的数据响应，所以在整个Gin框架中紧跟&lt;code&gt;Router&lt;/code&gt;模型结构的就要属&lt;code&gt;Context&lt;/code&gt;结构了，该结构体主要用来处理整个HTTP请求的上下文数据，也是我们在开发HTTP服务中相对比较重要的一个结构体了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;gh&#34;&gt;# 深入Gin框架内幕(一)中的示例
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ cat case1.go
package main
import (
    &amp;#34;net/http&amp;#34;

    &amp;#34;github.com/gin-gonic/gin&amp;#34;
)
func main() {
    ginObj := gin.Default()
    ginObj.Any(&amp;#34;/hello&amp;#34;,func(c *gin.Context){
        c.String(http.StatusOK,&amp;#34;Hello BGBiao.&amp;#34;)
    })
    ginObj.Run(&amp;#34;localhost:8080&amp;#34;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们可以看到，在使用Gin框架后，我们只需要很简单的代码，即可以快速运行一个返回&lt;code&gt;Hello BGBiao.&lt;/code&gt;的HTTP服务，而在&lt;code&gt;ginObj.Any&lt;/code&gt;方法中，我们传入了一个参数为&lt;code&gt;Context&lt;/code&gt;引用类型的匿名函数，并在该函数内部采用&lt;code&gt;String(code,data)&lt;/code&gt;方法来处理HTTP服务的响应数据(返回Hello BGBiao字符串)，这个时候，你可能会想，我们在企业内部都是前后端分离，通常情况下后端仅会提供&lt;code&gt;RESTful API&lt;/code&gt;，并通过&lt;code&gt;JSON&lt;/code&gt;格式的数据和前端进行交互，那么Gin是如何处理其他非字符串类型的数据响应呢，这也是我们接下来要主要讲的&lt;code&gt;Context&lt;/code&gt;结构模型。&lt;/p&gt;

&lt;h4 id=&#34;2-gin框架中的context结构体&#34;&gt;2.Gin框架中的Context结构体&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt; 在Gin框架中由&lt;code&gt;Router&lt;/code&gt;结构体来负责路由和方法(URL和HTTP方法)的绑定，内的Handler采用&lt;code&gt;Context&lt;/code&gt;结构体来处理具体的HTTP数据传输方式，比如HTTP头部，请求体参数，状态码以及响应体和其他的一些常见HTTP行为。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Context结构体&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;type Context struct {
    // 一个包含size,status和ResponseWriter的结构体
    writermem responseWriter
    // http的请求体(指向原生的http.Request指针)
    Request   *http.Request
    // ResonseWriter接口
    Writer    ResponseWriter

    // 请求参数[]{&amp;#34;Key&amp;#34;:&amp;#34;Value&amp;#34;}
    Params   Params
    handlers HandlersChain
    index int8
    // http请求的全路径地址
    fullPath string
    // gin框架的Engine结构体指针
    engine   *Engine
    // 每个请求的context中的唯一键值对
    Keys map[string]interface{}
    // 绑定到所有使用该context的handler/middlewares的错误列表
    Errors errorMsgs
    // 定义了允许的格式被用于内容协商(content)
    Accepted []string
    // queryCache 使用url.ParseQuery来缓存参数查询结果(c.Request.URL.Query())
    queryCache url.Values
    // formCache 使用url.ParseQuery来缓存PostForm包含的表单数据(来自POST,PATCH,PUT请求体参数)
    formCache url.Values
}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Context结构体常用的一些方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;基本方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Copy(): 返回当前正在使用的context的拷贝(context指针)，当这个context必须在goroutine中用时，该方法比较有用&lt;/li&gt;
&lt;li&gt;HandlerName(): 返回当前主handler的名称(比如:handler为handleGetUsers(),该方法将返回&amp;rdquo;main.handleGetUsers&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;HandlerNames(): 返回所有注册的handler的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handler()&lt;/code&gt;: 返回当前的主handler(&lt;code&gt;func (c *Context) Handler() HandlerFunc&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;FullPath(): 返回一个匹配路由的全路径(uri: &amp;ldquo;/user/:id&amp;rdquo;,c.FullPath() == &amp;ldquo;/user/:id&amp;rdquo; )&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;http常用方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ClientIP() string: 返回客户端ip(该方法会解析&lt;code&gt;X-Real-IP&lt;/code&gt;,&lt;code&gt;X-Forwarded-For&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;ContentType() string: 返回HTTP的Content-Type头&lt;/li&gt;
&lt;li&gt;IsWebsocket() bool: 返回是否为ws链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;流控相关的方法:&lt;/code&gt;
- Next(): 该方法仅被使用在middleware中，它会在被调用的handler链内部执行pending handler
- IsAborted(): 如果当前的context被终止了，该方法返回true
- Abort(): 该函数可以从正在被调用中保护pending handler. 该方法停止后不会停止当前正在执行的handler. 比如我们有一个鉴权的中间件来验证请求是否有权限，如果认证失败了(用户信息异常等)，此时调用Abort()来确保后面的handler不再被调用
- AbortWithStatus(code int): 同上，在会写入状态码。context.AbortWithStatus(401)即可表示上述的鉴权失败
- AbortWithStatusJSON(code int, jsonObj interface{}): 同上，会再加响应数据.该方法会停止整个handler链，再写入状态码和json的响应体，同时也会设置Content-Type=&amp;ldquo;application/json&amp;rdquo;
- AbortWithError(code int, err error) *Error: 同上返回错误信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;错误管理&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error(err error) *Error: 返回一些错误对象&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;元数据管理&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Set(key string, value interface{}): 给当前这个context设置一个新的键值对&lt;/li&gt;
&lt;li&gt;Get(key string) (value interface{}, exists bool): 返回指定的key的值,以及是否存在&lt;/li&gt;
&lt;li&gt;MustGet(key string) interface{}: 返回指定key的值，不存在则panic&lt;/li&gt;
&lt;li&gt;GetString(key string) (s string): 以string类型返回指定的key&lt;/li&gt;
&lt;li&gt;GetBool(key string) (b bool): 返回分配给该key的值(bool类型)&lt;/li&gt;
&lt;li&gt;GetInt(key string) (i int):&lt;/li&gt;
&lt;li&gt;GetStringSlice(key string) (ss []string): 返回key的slice类型&lt;/li&gt;
&lt;li&gt;GetStringMap(key string) (sm map[string]interface{}): 返回interface{}类型的map结构&lt;/li&gt;
&lt;li&gt;GetStringMapString(key string) (sms map[string]string): 返回string类型的map结构&lt;/li&gt;
&lt;li&gt;GetStringMapStringSlice(key string) (smss map[string][]string): 同理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;输入数据&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Param(key string) string: 返回URL的参数值(uri_patten: &amp;ldquo;/user/:id&amp;rdquo;,url: &amp;ldquo;/user/john&amp;rdquo;,c.Param(&amp;ldquo;id&amp;rdquo;) = &amp;ldquo;john&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Query(key string) string: 返回url中的查询参数值(url: &amp;ldquo;/path?id=1234&amp;amp;name=Manu&amp;amp;value=&amp;ldquo;,c.Query(&amp;ldquo;id&amp;rdquo;)为1234,c.Query(&amp;ldquo;name&amp;rdquo;)为Manu,c.Query(&amp;ldquo;value&amp;rdquo;)为空)&lt;/li&gt;
&lt;li&gt;DefaultQuery(key, defaultValue string) string: 返回url中的查询参数的默认值(同上，但是c.Query(&amp;ldquo;value&amp;rdquo;)就没有值，该方法可以设置默认值)&lt;/li&gt;
&lt;li&gt;GetQuery(key string) (string, bool): 同Query()方法，并且会返回状态，如果对应的key不存在，返回(&amp;ldquo;&amp;rdquo;,false)&lt;/li&gt;
&lt;li&gt;QueryArray(key string) []string: 返回指定key的对应的array(slice的长度取决于给定key的参数的数量)&lt;/li&gt;
&lt;li&gt;GetQueryArray(key string) ([]string, bool): 同上，会返回状态&lt;/li&gt;
&lt;li&gt;QueryMap(key string) map[string]string: 返回指定key对应map类型&lt;/li&gt;
&lt;li&gt;GetQueryMap(key string) (map[string]string, bool): 同上，并且会返回状态&lt;/li&gt;
&lt;li&gt;PostForm(key string) string: 该方法返回一个从POST 请求的urlencode表单或者multipart表单数据，不存在时返回空字符串&lt;/li&gt;
&lt;li&gt;DefaultPostForm(key, defaultValue string) string: 同上，key不存在时返回默认值&lt;/li&gt;
&lt;li&gt;GetPostForm(key string) (string, bool): 同PostForm()方法，并且会返回状态&lt;/li&gt;
&lt;li&gt;PostFormArray(key string) []string: 该方法返回指定key的字符串类型的slice&lt;/li&gt;
&lt;li&gt;GetPostFormArray(key string) ([]string, bool): 同上，并返回状态&lt;/li&gt;
&lt;li&gt;PostFormMap(key string) map[string]string: 返回指定key的map类型&lt;/li&gt;
&lt;li&gt;GetPostFormMap(key string) (map[string]string, bool): 同上，并返回状态&lt;/li&gt;
&lt;li&gt;FormFile(name string) (*multipart.FileHeader, error): 返回指定key的第一个文件(用作文件上传)&lt;/li&gt;
&lt;li&gt;MultipartForm() (*multipart.Form, error): 该方法解析multipart表单，包含file文件上传&lt;/li&gt;
&lt;li&gt;SaveUploadedFile(file *multipart.FileHeader, dst string) error: 该方法用来上传指定的文件头到目标路径(dst)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Bind家族相关方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Bind(obj interface{}) error: 自动解析&lt;code&gt;Content-Type&lt;/code&gt;并绑定到指定的binding引擎&lt;/li&gt;
&lt;li&gt;BindJSON(obj interface{}) error: 同上，binding引擎为&lt;code&gt;binding.JSON&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BindXML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindQuery(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindYAML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindHeader(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;BindUri(obj interface{}) error: 使用&lt;code&gt;binding.Uri&lt;/code&gt;来绑定传递的结构体指针&lt;/li&gt;
&lt;li&gt;MustBindWith(obj interface{}, b binding.Binding) error: 使用指定的binding引擎来绑定传递的结构体指针(当有任何错误时，终止请求并返回400)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;ShouldBind家族相关方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ShouldBind(obj interface{}) error: 同上述的Bind()方法，但是该方法在json结构无效时不会返回400&lt;/li&gt;
&lt;li&gt;ShouldBindJSON(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindXML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindQuery(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindYAML(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindHeader(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindUri(obj interface{}) error:&lt;/li&gt;
&lt;li&gt;ShouldBindWith(obj interface{}, b binding.Binding) error: 等同于MustBindWith()方法&lt;/li&gt;
&lt;li&gt;ShouldBindBodyWith(obj interface{}, bb binding.BindingBody) (err error): 和ShouldBindWith()方法相似，但是他会存储请求体到context中，当下次调用时可以重用(因为该方法是在binding之前读取body，因此在你只使用一次时，为了更好的性能还是使用ShouldBindWith会比较好)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;HTTP响应相关的方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Status(code int): 设置http的响应码&lt;/li&gt;
&lt;li&gt;Header(key, value string): 是&lt;code&gt;c.Writer.Header().Set(key, value)&lt;/code&gt;的简单实现，在响应体重写入一个header，如果value为空，则相当于调用了&lt;code&gt;c.Writer.Header().Del(key)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GetHeader(key string) string: 返回请求体重的header&lt;/li&gt;
&lt;li&gt;GetRawData() ([]byte, error): 返回流式数据&lt;/li&gt;
&lt;li&gt;SetCookie(name, value string, maxAge int, path, domain string, secure, httpOnly bool): 该方法将设置一个Set-Cookie到ResponseWriter的头中(注意:name必须是一个合法可用的名称,无效的coookie可能会被丢弃)&lt;/li&gt;
&lt;li&gt;Cookie(name string) (string, error): 返回名称为name的cookie&lt;/li&gt;
&lt;li&gt;Render(code int, r render.Render): 该方法写入响应头并调用render.Render去渲染数据&lt;/li&gt;
&lt;li&gt;HTML(code int, name string, obj interface{}): 该方法使用指定文件模板名称去渲染http模板(同时会更新状态码并设置Content-Type as &amp;ldquo;text/html&amp;rdquo;.)&lt;/li&gt;
&lt;li&gt;IndentedJSON(code int, obj interface{}): 该方法会序列化对象obj为一个pretty JSON 数据到响应体中，同时设置Content-Type as &amp;ldquo;application/json&amp;rdquo;(pretty JSON需要消耗cpu和带宽，强烈建议生产使用&lt;code&gt;Context.JSON()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;SecureJSON(code int, obj interface{}): 同上，会序列化成&lt;code&gt;Secure Json&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;JSONP(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;JSON(code int, obj interface{}): 序列化为JSON,并写Content-Type:&amp;ldquo;application/json&amp;rdquo;头&lt;/li&gt;
&lt;li&gt;AsciiJSON(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;PureJSON(code int, obj interface{}):&lt;/li&gt;
&lt;li&gt;XML(code int, obj interface{}): 序列化成&lt;code&gt;xml&lt;/code&gt;格式,并写Content-Type:&amp;ldquo;application/xml&amp;rdquo;&lt;/li&gt;
&lt;li&gt;YAML(code int, obj interface{}): 序列化成&lt;code&gt;yaml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ProtoBuf(code int, obj interface{}): 序列化成&lt;code&gt;probuf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;String(code int, format string, values &amp;hellip;interface{}): 将制定的string写入响应体&lt;/li&gt;
&lt;li&gt;Redirect(code int, location string): 重定向&lt;/li&gt;
&lt;li&gt;Data(code int, contentType string, data []byte): 写一些数据到响应体重，并更新响应码&lt;/li&gt;
&lt;li&gt;DataFromReader(code int, contentLength int64, contentType string, reader io.Reader, extraHeaders map[string]string): 写一些制定模板的数据到响应体中，并更新状态码&lt;/li&gt;
&lt;li&gt;File(filepath string): 以一种高效方式将制定文件写入响应体数据中&lt;/li&gt;
&lt;li&gt;FileAttachment(filepath, filename string): 同上，但是在客户端文件会被直接下载下来&lt;/li&gt;
&lt;li&gt;SSEvent(name string, message interface{}): 写Server-Sent Event到响应数据中&lt;/li&gt;
&lt;li&gt;Stream(step func(w io.Writer) bool) bool: 发送一个流式的响应数据并返回状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-gin实例示例&#34;&gt;3.Gin实例示例&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;3.1返回json格式的数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为了解决我们在开头提到的问题，我们将使用context引用对象的JSON家族方法来处理该需求&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;gh&#34;&gt;# 使用context来返回json格式的数据
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ cat case2.go
package main

import (
    &amp;#34;github.com/gin-gonic/gin&amp;#34;
)

// 我们定义一个通用的格式化的响应数据
// 在Data字段中采用空接口类型来实际存放我们的业务数据
type restData struct {
    Data        interface{}   &lt;span class=&#34;sb&#34;&gt;`json:&amp;#34;data&amp;#34;`&lt;/span&gt;
    Message     string        &lt;span class=&#34;sb&#34;&gt;`json:&amp;#34;message&amp;#34;`&lt;/span&gt;
    Status      bool          &lt;span class=&#34;sb&#34;&gt;`json:&amp;#34;status&amp;#34;`&lt;/span&gt;
}

func main() {
    // mock一个http响应数据
    restdata := &amp;amp;restData{&amp;#34;Hello,BGBiao&amp;#34;,&amp;#34;&amp;#34;,true}
    restdata1 := &amp;amp;restData{map[string]string{&amp;#34;name&amp;#34;:&amp;#34;BGBiao&amp;#34;,&amp;#34;website&amp;#34;:&amp;#34;https://bgbiao.top&amp;#34;},&amp;#34;&amp;#34;,true}

    // 使用Gin框架启动一个http接口服务
    ginObj := gin.Default()
    ginObj.GET(&amp;#34;/api/test&amp;#34;,func(c &lt;span class=&#34;ge&#34;&gt;*gin.Context){
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;       // 我们的handlerFunc中入参是一个Context结构的引用对象c
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;       // 因此我们可以使用Context中的JSON方法来返回一个json结构的数据
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;       // 可用的方法有如下几种，我们可以根据实际需求进行选择
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;       /*&lt;/span&gt;
          IndentedJSON(code int, obj interface{}): 带缩进的json(消耗cpu和mem)
          SecureJSON(code int, obj interface{}): 安全化json
          JSONP(code int, obj interface{})
          JSON(code int, obj interface{}): 序列化为JSON,并写Content-Type:&amp;#34;application/json&amp;#34;头
       */
       c.JSON(200,restdata)
    })
    ginObj.GET(&amp;#34;/api/test1&amp;#34;,func(c *gin.Context){
        c.IndentedJSON(200,restdata1)
    })

    ginObj.Run(&amp;#34;localhost:8080&amp;#34;)
}


&lt;span class=&#34;gh&#34;&gt;# 实例运行(这里成功将我们写的两个api接口进行对外暴露)
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ go run case2.go
....
....
[GIN-debug] GET    /api/test                 --&amp;gt; main.main.func1 (3 handlers)
[GIN-debug] GET    /api/test1                --&amp;gt; main.main.func2 (3 handlers)

&lt;span class=&#34;gh&#34;&gt;# 接口测试访问
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ curl localhost:8080/api/test
{&amp;#34;data&amp;#34;:&amp;#34;Hello,BGBiao&amp;#34;,&amp;#34;message&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;status&amp;#34;:true}
$ curl localhost:8080/api/test1
{
    &amp;#34;data&amp;#34;: {
        &amp;#34;name&amp;#34;: &amp;#34;BGBiao&amp;#34;,
        &amp;#34;website&amp;#34;: &amp;#34;https://bgbiao.top&amp;#34;
    },
    &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;status&amp;#34;: true
}% &lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当然上面我们仅以JSON格式来示例，类似的方式我们可以使用&lt;code&gt;XML&lt;/code&gt;,&lt;code&gt;YAML&lt;/code&gt;,&lt;code&gt;ProtoBuf&lt;/code&gt;等方法来输出指定格式化后的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2其他常用的基本方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;在其他基本方法中我们仍然使用上述示例代码中的主逻辑，主要用来测试基本的方法.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;gh&#34;&gt;# 我们在/api/test这个路由中增加如下两行代码
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;// 设置响应体中的自定义header(通常我们可以通过自定义头来实现一个内部标识)
c.Header(&amp;#34;Api-Author&amp;#34;,&amp;#34;BGBiao&amp;#34;)
// GetHeader方法用来获取指定的请求头，比如我们经常会使用请求中的token来进行接口的认证和鉴权
// 这里由于我们使用的restdata的指针，通过GetHeader方法获取到token赋值给Message
// ClientIP()方法用于获取客户端的ip地址
restdata.Message = fmt.Sprintf(&amp;#34;token:%s 当前有效，客户端ip:%s&amp;#34;,c.GetHeader(&amp;#34;token&amp;#34;),c.ClientIP())

&lt;span class=&#34;gh&#34;&gt;# 访问接口示例(我们可以看到在响应体中多了一个我们自定义的Api-Author头，并且我们将请求头token的值)
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ curl -H &amp;#39;token:xxxxxxxx&amp;#39; localhost:8080/api/test -i
HTTP/1.1 200 OK
Api-Author: BGBiao
Content-Type: application/json; charset=utf-8
Date: Sun, 12 Jan 2020 14:41:01 GMT
Content-Length: 66

{&amp;#34;data&amp;#34;:&amp;#34;Hello,BGBiao&amp;#34;,&amp;#34;message&amp;#34;:&amp;#34;token:xxxxxxxx 当前有效，客户端ip:127.0.0.1&amp;#34;,&amp;#34;status&amp;#34;:true}&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3.3用户数据输入&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然到这里后，你可能还会有新的疑问，就是通常情况下，我们开发后端接口会提供一些具体的参数，通过一些具体数据提交来实现具体的业务逻辑处理，这些参数通常会分为如下三类:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用HTTP GET方法获取到的url中的一些查询参数来执行更具体的业务逻辑(比如我们查询数据的指定条数之类的)&lt;/li&gt;
&lt;li&gt;使用HTTP POST GET等其他方式以form表单方式提交的数据来验证和处理用户数据&lt;/li&gt;
&lt;li&gt;在URL中获取一些可变参数(比如通常我们的url会定义为&amp;rdquo;/api/uid/:id&amp;rdquo;来表示用户id相关的接口，这个时候通常需要获取到url中的id字段)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上的基本需求，几乎都可以在Context结构体的&lt;code&gt;输入数据&lt;/code&gt;中找到响应的方法.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;gh&#34;&gt;# 接下来，我们依然在上述的代码中进行修改，增加如下路由
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ cat case2.go
....
....
    // 比如我们该接口时用来获取全部数据，但是我们希望在url中增加参数来限制数据条数
    datas := []string{&amp;#34;Golang&amp;#34;,&amp;#34;Python&amp;#34;,&amp;#34;Docker&amp;#34;,&amp;#34;Kubernetes&amp;#34;,&amp;#34;CloudNative&amp;#34;,&amp;#34;DevOps&amp;#34;}
    ginObj.GET(&amp;#34;/api/testdata&amp;#34;,func(c &lt;span class=&#34;ge&#34;&gt;*gin.Context){
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        limit := c.Query(&amp;#34;limit&amp;#34;)
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 其实既然这里我们已经确定需求了，当用户没有输入limit参数时我们就可以设置默认值
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // DefaultQuery(&amp;#34;limit&amp;#34;,&amp;#34;1&amp;#34;)
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 同时我们其实也可以使用GetQuery方法来获取参数解析状态，即是否有对应的参数
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 还有QueryArray和GetQueryArray类似的方法
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        if limit != &amp;#34;&amp;#34; {
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;            num,_&lt;/span&gt; := strconv.Atoi(limit)
            restdata1.Data = datas[:num]
        }else {
            restdata1.Data = datas
        }
        c.IndentedJSON(200,restdata1)

    })

    // 使用form表单方式提交数据
    ginObj.POST(&amp;#34;/api/testdata&amp;#34;,func(c &lt;span class=&#34;ge&#34;&gt;*gin.Context){
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 使用c.PostForm方法来提交一个data数据
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 同时我们可以使用DefaultPostForm方法来给提交数据一个默认值，比如我们有些参数是希望有默认值的
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // 当然也可以使用GetPostForm，PostFormArray，PostFormArray方法来获取多个数据和状态
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // data := c.PostForm(&amp;#34;data&amp;#34;)
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        // datas = append(datas,data)
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        /*&lt;/span&gt; 这里可能会有个问题就是同时提交多个数据时，使用PostForm方法就会不那么好使了
        通常情况下回使用PostFormArray方法
        */
        data := c.PostFormArray(&amp;#34;data&amp;#34;)
        datas = append(datas,data...)
        restdata1.Data = datas
        c.IndentedJSON(200,restdata1)
    })

    // 获取url中的路径参数
    ginObj.GET(&amp;#34;/api/testdata/:data&amp;#34;,func(c &lt;span class=&#34;ge&#34;&gt;*gin.Context){
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        data := c.Param(&amp;#34;data&amp;#34;)
&lt;/span&gt;&lt;span class=&#34;ge&#34;&gt;        for _&lt;/span&gt;,rawData := range datas {
            if data == rawData {
                restdata1.Data = data
                break
            }
        }
        if restdata1.Data != data {
            restdata1.Data = &amp;#34;&amp;#34;
            restdata1.Message = fmt.Sprintf(&amp;#34;%v 不存在&amp;#34;,data)
            restdata1.Status = false
        }
        c.IndentedJSON(200,restdata1)
    })
....
....



&lt;span class=&#34;gh&#34;&gt;# 请求示例接口
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;# 我们可以看到使用GET方法默认会获取到全部数据，但是如果有了limit参数后，我们就可以限制数据的条数
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ curl -H &amp;#39;token:xxxxxxxx&amp;#39; localhost:8080/api/testdata
{
    &amp;#34;data&amp;#34;: [
        &amp;#34;Golang&amp;#34;,
        &amp;#34;Python&amp;#34;,
        &amp;#34;Docker&amp;#34;,
        &amp;#34;Kubernetes&amp;#34;,
        &amp;#34;CloudNative&amp;#34;,
        &amp;#34;DevOps&amp;#34;
    ],
    &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;status&amp;#34;: true
}%
$ curl -H &amp;#39;token:xxxxxxxx&amp;#39; &amp;#34;localhost:8080/api/testdata?limit=2&amp;#34;
{
    &amp;#34;data&amp;#34;: [
        &amp;#34;Golang&amp;#34;,
        &amp;#34;Python&amp;#34;
    ],
    &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;status&amp;#34;: true
}%

&lt;span class=&#34;gh&#34;&gt;# 当我们使用post接口往服务提交数据时，就可以让服务端按照需求进行数据处理
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;curl -X POST  -d data=&amp;#34;vue&amp;#34; &amp;#34;localhost:8080/api/testdata&amp;#34;
{
    &amp;#34;data&amp;#34;: [
        &amp;#34;Golang&amp;#34;,
        &amp;#34;Python&amp;#34;,
        &amp;#34;Docker&amp;#34;,
        &amp;#34;Kubernetes&amp;#34;,
        &amp;#34;CloudNative&amp;#34;,
        &amp;#34;DevOps&amp;#34;,
        &amp;#34;vue&amp;#34;
    ],
    &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;status&amp;#34;: true
}%

&lt;span class=&#34;gh&#34;&gt;# 当我们同时需要提交多份数据时，可以使用PostFormArray方法，同时提交多份数据(可以理解为批量提交)
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ curl -X POST -d data=&amp;#34;vue&amp;#34; -d data=&amp;#34;Rust&amp;#34; &amp;#34;localhost:8080/api/testdata&amp;#34;

&lt;span class=&#34;gh&#34;&gt;# 获取URL中的参数值
&lt;/span&gt;&lt;span class=&#34;gh&#34;&gt;&lt;/span&gt;$ curl &amp;#34;localhost:8080/api/testdata/Golang&amp;#34;
{
    &amp;#34;data&amp;#34;: &amp;#34;Golang&amp;#34;,
    &amp;#34;message&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;status&amp;#34;: true
}%

$ curl &amp;#34;localhost:8080/api/testdata/Java&amp;#34;
{
    &amp;#34;data&amp;#34;: &amp;#34;&amp;#34;,
    &amp;#34;message&amp;#34;: &amp;#34;Java 不存在&amp;#34;,
    &amp;#34;status&amp;#34;: false
}%&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>深入Gin框架内幕1</title>
      <link>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%951/</link>
      <pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E6%B7%B1%E5%85%A5gin%E6%A1%86%E6%9E%B6%E5%86%85%E5%B9%951/</guid>
      
        <description>&lt;h3 id=&#34;gin框架介绍&#34;&gt;Gin框架介绍&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin&#34;&gt;Gin&lt;/a&gt;是一个用 Go (Golang) 编写的 web 框架。它是一个类似于&lt;a href=&#34;https://github.com/go-martini/martini&#34;&gt;martini&lt;/a&gt;但性能更好的API框架，不同于谢大主导的&lt;a href=&#34;https://beego.me/&#34;&gt;Beego&lt;/a&gt;web框架，后者更像是Python语言中的&lt;code&gt;Django&lt;/code&gt;框架，内部包含了开发一个web程序所需的各种组件。&lt;/p&gt;

&lt;p&gt;如果你是性能和高效的追求者，我相信你会像我一样爱上Gin。&lt;/p&gt;

&lt;p&gt;同时，不同于其他Golang语言的API框架，该框架社区十分活跃，并且主程仍然在不断更新和改进，我们知道通常情况下在选择一个开源的软件或者相关库时，社区的活跃度以及项目的更新情况会非常重要(考虑到后期的维护和性能和特性问题)。&lt;/p&gt;

&lt;p&gt;另外一方面，该框架官方提供了很多简单的示例来供我们快速运行一个期望的http服务，这对于一个刚转入Golang进行业务开发的同学来说是一个非常好的开始。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin#api-examples&#34;&gt;Gin官方提供的各种HTTP服务示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当然我在很长一段时间也仅是去看官方示例来快速熟悉并实现自己的业务需求，但当有一些特殊的需求时通常去查看官方的具体实现来满足需求，长期如此，不仅耗时且效率极低，因此我产生了将核心源码探究一番的兴趣，希望能通过源码方式来对Gin框架有个深入的学习。&lt;/p&gt;

&lt;h3 id=&#34;gin框架中的几个核心结构&#34;&gt;Gin框架中的几个核心结构&lt;/h3&gt;

&lt;p&gt;我们都知道开发一个HTTP服务，首先需要启动一个TCP监听，然后需要有一些列的handler来处理具体的业务逻辑，最后在再将具体的业务逻辑通过HTTP协议约定和相关的Method和URL进行绑定，以此来对外提供具体功能的HTTP服务。那么在Gin框架对应的就是如下几个模型，我们将一起学习Gin的实现。&lt;/p&gt;

&lt;p&gt;Gin框架中的几个重要的模型:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Engine: 用来初始化一个&lt;code&gt;gin&lt;/code&gt;对象实例，在该对象实例中主要包含了一些框架的基础功能，比如日志，中间件设置，路由控制(组)，以及handlercontext等相关方法.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L54&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Router: 用来定义各种路由规则和条件，并通过HTTP服务将具体的路由注册到一个由context实现的handler中&lt;/li&gt;
&lt;li&gt;Context: &lt;code&gt;Context&lt;/code&gt;是框架中非常重要的一点，它允许我们在中间件间共享变量，管理整个流程，验证请求的json以及提供一个json的响应体. 通常情况下我们的业务逻辑处理也是在整个Context引用对象中进行实现的.&lt;/li&gt;
&lt;li&gt;Bind: 在Context中我们已经可以获取到请求的详细信息，比如HTTP请求头和请求体，但是我们需要根据不同的HTTP协议参数来获取相应的格式化数据来处理底层的业务逻辑，就需要使用&lt;code&gt;Bind&lt;/code&gt;相关的结构方法来解析context中的HTTP数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;1-gin框架中的engine结构体&#34;&gt;1.Gin框架中的Engine结构体&lt;/h4&gt;

&lt;p&gt;当我们在使用框架&lt;code&gt;[Gin](https://github.com/gin-gonic/gin)&lt;/code&gt;来创建一个HTTP服务时，首先我们需要初始化一个实例，在&lt;code&gt;Engine&lt;/code&gt;结构体中就包含了实例的一些基本属性和实例化的一些方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Engine结构体&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;type Engine struct {
    // 路由组，在实际开发过程中我们通常会使用路由组来组织和管理一些列的路由. 比如: /apis/,/v1/等分组路由
    RouterGroup
    // 开启自动重定向。如果当前路由没有匹配到，但是存在不带/开头的handler就会重定向. 比如: 用户输入/foo/但是存在一个/foo 就会自动重定向到该handler，并且会向客户端返回301或者307状态码(区别在于GET方法和其他方法)
    RedirectTrailingSlash bool
    // 如果开启该参数，没有handler注册时，路由会尝试自己去修复当前的请求地址. 
    // 修复流程:
    // 1.首位多余元素会被删除(../ or //); 2.然后路由会对新的路径进行不区分大小写的查找;3.如果能正常找到对应的handler，路由就会重定向到正确的handler上并返回301或者307.(比如: 用户访问/FOO 和 /..//Foo可能会被重定向到/foo这个路由上)
    RedirectFixedPath bool
    // 如果开启该参数，当当前请求不能被路由时，路由会自己去检查其他方法是否被允许.在这种情况下会响应&amp;#34;Method Not Allowed&amp;#34;，并返回状态码405; 如果没有其他方法被允许，将会委托给NotFound的handler
    HandleMethodNotAllowed bool
    // 是否转发客户端ip
    ForwardedByClientIP    bool
    // 如果开启将会在请求中增加一个以&amp;#34;X-AppEngine...&amp;#34;开头的header
    AppEngine bool
    // 如果开启将会使用url.RawPath去查找参数(默认:false)
    UseRawPath bool
    // 如果开启，请求路径将不会被转义. 如果UseRawPath为false，该参数实际上就为true(因为使用的是url.Path)
    UnescapePathValues bool
    // maxMemory参数的值(http.Request的ParseMultipartForm调用时的参数)
    MaxMultipartMemory int64
    // 是否删除额外的反斜线(开始时可解析有额外斜线的请求)
    RemoveExtraSlash bool
    // 分隔符(render.Delims表示使用HTML渲染的一组左右分隔符,具体可见html/template库)
    delims           render.Delims
    // 设置在Context.SecureJSON中国的json前缀
    secureJsonPrefix string
    // 返回一个HTMLRender接口(用于渲染HTMLProduction和HTMLDebug两个结构体类型的模板)
    HTMLRender       render.HTMLRender
    // html/template包中的FuncMap map[string]interface{} ,用来定义从名称到函数的映射
    FuncMap          template.FuncMap
    // 以下是gin框架内部定义的一些属性 
    // HandlersChain 是一个HandlerFunc 的数组(HandlerFunc其实就是一个Context的指针,Context会在下一节讲解)
    allNoRoute       HandlersChain
    allNoMethod      HandlersChain
    noRoute          HandlersChain
    noMethod         HandlersChain
    // 这里定义了一个可以临时存取对象的集合(sync.Pool是线程安全的，主要用来缓存为使用的item以减少GC压力，使得创建高效且线程安全的空闲队列)
    pool             sync.Pool
    // methodTrees是methodTree的切片(methodTree是一个包含请求方法和node指针的结构体,node是一个管理path的节点树)
    trees            methodTrees
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;HandlerFunc定义&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// 定义了一个可以被中间件使用的handler
type HandlerFunc func(*Context)&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;初始化Engine的方式&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;New()&lt;/code&gt;: 该函数返回一个默认的Engine引用实例(开启了自动重定向,转发客户端ip和禁止请求路径转义)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Default()&lt;/code&gt;: 内部调用&lt;code&gt;New()&lt;/code&gt;函数，但是增加了Logger和Recovery两个中间件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;Engine对外常用的方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Delims(left, right string) *Engine&lt;/code&gt;: 给创建好的gin实例指定模板引擎的左右分割符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SecureJsonPrefix(prefix string) *Engine&lt;/code&gt;: 给创建好的gin实例设置secureJsonPrefixi&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetHTMLTemplate(templ *template.Template)&lt;/code&gt;: 该方法会gin实实例绑定一个模板引擎(内部其实是设置了engine的HTMLRender属性)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadHTMLGlob(pattern string)&lt;/code&gt;: 该方法用来加载glob模式(类似于shell中的正则)的html模板文件，然后将结果和HTML模板引擎关联(内部调用&lt;code&gt;SetHTMLTemplate&lt;/code&gt;方法将全部匹配到模板注册进去)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LoadHTMLFiles(files ...string)&lt;/code&gt;: 该方法用上，需要指定一组模板文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetFuncMap(funcMap template.FuncMap)&lt;/code&gt;: 该方法会设置一个FuncMap给template.FuncMap使用(内部其实设置了engine的FuncMap)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoRoute(handlers ...HandlerFunc)&lt;/code&gt;: 该方法为NoRoute增加一些handler，它默认会返回404(通常在企业里，404我们会处理的比较优雅一些，比如给一些企业的静态页啥的)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NoMethod(handlers ...HandlerFunc)&lt;/code&gt;: 同上，该方法用于给NoMethod增加handler，默认返回405&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Use(middleware ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法用于绑定一个全局的中间件给router. 通过该方法注册的中间件将包含在每个请求的handler chain中(比如可以在这里使用一些logger或者error相关的中间件). 在上面初始化实例的&lt;code&gt;Default()&lt;/code&gt;函数中其实内部使用了&lt;code&gt;engine.Use(Logger(), Recovery())&lt;/code&gt;来加载logger和recovery中间件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Routes() (routes RoutesInfo)&lt;/code&gt;: 该方法用来返回一个路由列表信息&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L50&#34;&gt;RoutesInfo&lt;/a&gt;(一个路由信息RouteInfo中包含Method,Path,Handler,HandlerFunc)，该方法底层调用engine的trees来获取一些router必要的信息.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Run(addr ...string) (err error)&lt;/code&gt;: 该方法会绑定router到http.Server中并开启一个http监听来接收http请求. 该方法其实是&lt;code&gt;http.ListenAndServe(addr, engine)&lt;/code&gt;的简单实现. 注意:该方法除非出现错误，否则会无期限阻塞调用goroutine来接收请求(engine内部只要实现了http.ServeHTTP方法即可)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunTLS(addr, certFile, keyFile string) (err error)&lt;/code&gt;: 同上，以https方式运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunUnix(file string) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;方法，通过指定的unix socket文件运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunFd(fd int) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;方法，通过指定的文件描述符(fd)来运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RunListener(listener net.Listener) (err error)&lt;/code&gt;: 同&lt;code&gt;Run(addr)&lt;/code&gt;，通过制定的&lt;code&gt;net.Listener&lt;/code&gt;来运行服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/code&gt;: 该方法遵循了&lt;code&gt;http.Handler&lt;/code&gt;的接口规范，可使gin内部调用&lt;code&gt;http.ListenAndServe&lt;/code&gt;来启动一个http服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HandleContext(c *Context)&lt;/code&gt;: 该方法会重新确认一个被重写的context(可以通过c.Request.URL.Path来实现). 需要注意的是该方法可能造成context的循环使用(会绕死你,谨慎使用)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-gin框架中的router&#34;&gt;2.Gin框架中的Router&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;Engine&lt;/code&gt;结构体中提供的相关方法，我们就可以快速的启动一个HTTP服务了，但是如何对外暴露一个URL来简单实现一个HTTP的数据传输呢，这个时候就需要使用Router中的方法了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Gin框架中Router相关的结构体&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouterGroup&lt;/code&gt;: 该结构体被用来在Gin内部配置一个路由，一个RouterGroup被用来关联URL前缀和一组具体的handler业务逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IRoutes&lt;/code&gt;: IRoutes是一个定了了所有路由处理的接口(包含一些常用的HTTP方法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IRouter&lt;/code&gt;: IRouter则是一个包含单个路由和路由组的所有路由处理的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;RouterGroup相关结构定义&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// RouterGroup 结构体
type RouterGroup struct {
	Handlers HandlersChain
	basePath string
	engine   *Engine
	root     bool
}

// IRoutes 接口
type IRoutes interface {
	Use(...HandlerFunc) IRoutes

	Handle(string, string, ...HandlerFunc) IRoutes
	Any(string, ...HandlerFunc) IRoutes
	GET(string, ...HandlerFunc) IRoutes
	POST(string, ...HandlerFunc) IRoutes
	DELETE(string, ...HandlerFunc) IRoutes
	PATCH(string, ...HandlerFunc) IRoutes
	PUT(string, ...HandlerFunc) IRoutes
	OPTIONS(string, ...HandlerFunc) IRoutes
	HEAD(string, ...HandlerFunc) IRoutes

	StaticFile(string, string) IRoutes
	Static(string, string) IRoutes
	StaticFS(string, http.FileSystem) IRoutes
}

// IRouter接口
type IRouter interface {
	IRoutes
	Group(string, ...HandlerFunc) *RouterGroup
}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;还记得在上一节中我们的&lt;code&gt;Engine&lt;/code&gt;结构体中有一个&lt;code&gt;RouterGroup&lt;/code&gt;字段吗，该字段会在我们创建一个&lt;code&gt;Engine&lt;/code&gt;的gin实例后帮助我们初始化一个默认的&lt;code&gt;RouterGroup&lt;/code&gt;实例。&lt;/p&gt;

&lt;p&gt;比如在&lt;code&gt;Engine&lt;/code&gt;结构体的中的&lt;code&gt;New()&lt;/code&gt;函数，会初始化一个带有如下&lt;code&gt;RouterGroup&lt;/code&gt;的gin实例，并将gin实例注册到RouterGroup的&lt;code&gt;engine&lt;/code&gt;字段.&lt;a href=&#34;https://github.com/gin-gonic/gin/blob/master/gin.go#L126&#34;&gt;源码文件&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;// https://github.com/gin-gonic/gin/blob/master/gin.go#L129
		RouterGroup: RouterGroup{
			Handlers: nil,
			basePath: &amp;#34;/&amp;#34;,
			root:     true,
		},&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code&gt;RouterGroup结构体对外暴露的常用方法&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Use(middleware ...HandlerFunc) IRoutes&lt;/code&gt;: 注册一个中间件并返回Iroutes接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Group(relativePath string, handlers ...HandlerFunc) *RouterGroup&lt;/code&gt;: Group方法会创建一个新的路由组。通常我们会创建一个公共的中间件或者是具有相同前缀的路由，来归并到一个路由组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BasePath() string&lt;/code&gt;: 该方法用来返回一个路由组初始路径(比如 v := router.Group(&amp;ldquo;/rest/n/v1/api&amp;rdquo;)，则v.BasePath()就是&amp;rdquo;/rest/n/v1/api&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法会使用给定的HTTP方法和URL来注册一个新的handler。(最后一个handler应该是真正的处理程序，其他的应该是在不同的路由之间共享的中间件)。&lt;code&gt;注意:内部调用了一个handle(httpMethod, relativePath string, handlers HandlersChain)的私有方法来处理核心逻辑&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;POST(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 该方法是&lt;code&gt;router.Handle(&amp;quot;POST&amp;quot;, path, handle)&lt;/code&gt;的快速实现，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GET(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DELETE(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PATCH(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PUT(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTIONS(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any(relativePath string, handlers ...HandlerFunc) IRoutes&lt;/code&gt;: 同上，会将HTTP的所有方法都注册上去&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StaticFile(relativePath, filepath string) IRoutes&lt;/code&gt;: 该方法用来注册一台路由来服务本地文件系统的单个文件，比如:&lt;code&gt;router.StaticFile(&amp;quot;favicon.ico&amp;quot;, &amp;quot;./resources/favicon.ico&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Static(relativePath, root string) IRoutes&lt;/code&gt;: 该方法用来提供一个指定文件系统根路径的的路由，内部调用&lt;code&gt;group.StaticFS(path,Dir(root,false))&lt;/code&gt;来提供服务&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StaticFS(relativePath string, fs http.FileSystem) IRoutes&lt;/code&gt;: 指定文件系统(http.FileSystem)来创建一个服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-gin实例示例&#34;&gt;3.Gin实例示例&lt;/h4&gt;

&lt;p&gt;有了上面两个核心模型&lt;code&gt;Engine&lt;/code&gt;和&lt;code&gt;RouteGroup&lt;/code&gt;的了解，此时我们就可以通过Gin框架快速来创建一个简单HTTP服务了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.默认路由&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;测试示例&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cat&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;case1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;

    &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/gin-gonic/gin&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 使用Default()函数来初始化一个gin实例(engine结构体的引用对象)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// Default函数内部调用New()函数来初始化一个gin实例，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 同时使用Use(middleware ...HandlerFunc) IRoutes 方法注册了Logger和Recovery两个中间件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 在New()初始化gin实例的过程中还默认初始化了一个bathPath为&amp;#34;/&amp;#34;的RouterGroup，其实就是一个router实例
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;ginObj&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 由于RouterGroup在engine结构体中是一个匿名对象，因此实例化的engine引用对象就可以直接操作RouterGroup结构体里对外暴露的所有方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 这里我们尝试注册一个包含所有HTTP方法的路由
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// https://github.com/gin-gonic/gin/blob/master/routergroup.go#L133
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 而在RouterGroup的各种对外暴露的方法中，底层调用了 Handle(httpMethod, relativePath string, handlers ...HandlerFunc) IRoutes方法，后面可以传入多个handler来处理具体的业务逻辑，当handler有多个时最后一个处理实际的业务请求，前面的handler来处理中间件和共享的组件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 而HandlerFunc 其实就是一个func(*Context)的匿名函数.Context会在下一节具体分析
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;ginObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Any&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// context结构体相关的方法下一节会具体分析，这里是一个简单的示例
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusOK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Hello BGBiao.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;


    &lt;span class=&#34;c1&#34;&gt;// 当所有的路由注册之后，我们可以使用gin的结构体方法(engine结构体的引用对象)来实际运行HTTP服务，以接收用户的http请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 我们前面说过该方法除非出现错误，否则会无期限阻塞调用goroutine来接收请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;ginObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;localhost:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;




&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;运行实例&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;run&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;case1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WARNING&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Creating&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;an&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Engine&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Logger&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Recovery&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;middleware&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;already&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;attached&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WARNING&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Running&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;debug&amp;#34;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Switch&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;release&amp;#34;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;production&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GIN_MODE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;release&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;using&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ReleaseMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;GET&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;POST&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PUT&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PATCH&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HEAD&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OPTIONS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DELETE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CONNECT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TRACE&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;                    &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;func1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GIN&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Listening&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;serving&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HTTP&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;on&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;localhost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;模拟请求&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;因为我们注册了全部的HTTP方法的路由&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curl&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;localhost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;BGBiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;                                                                                        
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;POST&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;localhost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;BGBiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;                                                                                        
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DELETE&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;localhost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;BGBiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;                                                                                        
&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;curl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;X&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TRACE&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;localhost&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hello&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;Hello&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;BGBiao&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>关于如何挣钱的35条建议</title>
      <link>https://bgbiao.top/post/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8C%A3%E9%92%B1%E7%9A%8435%E6%9D%A1%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Thu, 09 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E5%85%B3%E4%BA%8E%E5%A6%82%E4%BD%95%E6%8C%A3%E9%92%B1%E7%9A%8435%E6%9D%A1%E5%BB%BA%E8%AE%AE/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;这篇《关于如何挣钱的35条建议》，是波波从《How to Get Rich : Every Episode》[附录1]这篇长文(超过3.6万英文单词)翻译整理而来。波波非常认同原文作者Naval关于挣钱和财富的理念，有种强烈的得道恨晚的感觉～要是早十年就懂这些道理就好了，所以专门花时间翻译整理，并且放在自己的公众号里头。期望以后可以经常回顾，加深理解，并最终深入自己的mindset.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;注:&lt;/code&gt;本篇文章转自公众号&amp;rdquo;程序新视界&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.追寻财富，而不是金钱和地位(Seek Wealth, Not Money or Status)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth is assets that earn while you sleep.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;财富是你睡觉时都能挣钱的资产。诸如工厂，机器人，计算机软件，作家的著作，被租赁的房产，被投资进入其它领域的钱等等&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth buys your freedom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;财富的目标就是换取自由，你不必在不喜欢的地方呆着，不必在不喜欢的工作上消磨人生，仅此而已。它并不是让你能够买高级外套，或者开法拉利，或者开游艇，或者周游世界。这些物质享受会让你很快产生厌倦和愚蠢感。财富只是让你成为你自己的主宰。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Money is how we transfer wealth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;金钱是可以转换成资产财富的媒介。金钱是一种社会信用，它代表可以使用他人时间的一种能力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Status is your rank in the social hierarchy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;社会中有两大游戏，几乎每个人都参与其中。一个是金钱游戏，另外一个是身份地位游戏。在地位和财富之间始终上演着一种微妙的竞争，玩身份地位的人，经常会攻击或利用创造财富的人。
创造财富是一种正和游戏(positive-sum)，你拥有一个房子，不会妨碍我也拥有一个房子。身份地位则是一种零和游戏(zero-sum)，老三要爬到老二的位置，那么老二的位子就必须让出来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.挣钱和运气无关(Making Money Isn&amp;rsquo;t About Luck)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Making money isn&amp;rsquo;t about luck. It&amp;rsquo;s about becoming the kind of person who makes moeny.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;挣钱和运气无关，它是关于如何让自己变成注定挣钱的人。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Four kinds of luck: 1). Blind Luck, 2). Luck from hustling, 3). Luck from preparation, 4). Luck from your unique character&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;运气的四种分类：
- &lt;code&gt;撞大运&lt;/code&gt;，纯运气
- &lt;code&gt;奋力争取带来的好运&lt;/code&gt;，俗语：幸运眷顾勇敢的人，也就是积极行动大量做事后获得好运，经常折腾的人也会有好运。
- &lt;code&gt;积极准备带来的好运&lt;/code&gt;，俗语：机会永远只给有准备的人。当你在某个领域积累很深，当大多数对这个领域不熟的人还没有觉察到的时候，你可以提前洞察这个领域的机会。
- &lt;code&gt;独特个性带来的好运&lt;/code&gt;，你塑造了一个独特的个性，独特的品牌，独特的思维模式，然后运气就盯上了你(运气变成确定的事)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In 1,000 parallel universes, you want to be wealthy in 999 of them&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在1000个平行宇宙中，你应该期望在其中的999个都是富有的，而不是只在其中的50个，靠运气才富有。通过追寻第四种运气，你可以消除运气因素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.让运气变成你的命运(Make Luck Your Destiny)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Build your character in a way so luck becomes deterministic.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以特定方式塑造你的个性，让运气成为注定的事&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Build your character so opportunity finds you&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;塑造你的独特个性(专业，可信赖，正直诚实，勇于担责，具有长线思维)，让机会自己来找你&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You have to be a little eccentric to be out on the frontier by yourself.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第四种运气大都源于古怪的行事方式。想要非常收获，你必须要有非常表现。世界是一个高效场所，所有明显的地方都已经被挖掘过，为了找到新奇的尚未发现的事物，你必须要以非常规方式行事，你要有强烈意愿和兴趣，要比别人挖得更深，深到让人感觉非理性的地步。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Extreme people get extreme results ~ Sam Altman&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;极端的人获得极端的结果&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t be normal and expect abnormal returns ~ Jeffrey Pfeffer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你不可能表现平凡，但却期望不平凡的回报&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Play stupid games win stupid prizes&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;玩愚蠢的游戏，只会赢得愚蠢的奖励。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.通过出租时间的方式，你不太可能致富(You Won&amp;rsquo;t Get Rich Renting Out Your Time)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You won&amp;rsquo;t get rich renting out your time, because you can&amp;rsquo;t earn non-linearly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过出租时间(比如打工)的方式，你不太可能致富，因为你的输入(时薪)和输出(工作产出)高度相关，你无法以非线性方式挣钱。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Renting out your time means you&amp;rsquo;re essentially replacable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;出租你的时间意味着你根本上是可以被替代的。大部分输入和输出高度相关的工作，会逐步被机器人或AI所取代。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You must own equity to gain your financial freedom.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你必须拥有资产(生意的一部分，如产品，生意，知识产权，股票期权等)，才可能以非线性方式挣钱，并赢得财务自由。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You want a career where your inputs don&amp;rsquo;t match your outputs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要选择输入和输出不严格相关的，能以非线性方式挣钱的行业。要找高度创新，能够利用工具和杠杆的行业。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.通过量入为出获得自由(Live Below Your Means for Freedom)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People living far below their means enjoy a freedom that people busy upgrading their lifestyles just can&amp;rsquo;t fathom&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;量入为出的人能够体会到的自由，是那些忙于升级生活方式的人所无法理解的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The most dangerous things are heroin and a monthly salary&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最危险的东西是海洛因和月光族。真正的致富之道是甘于朴素的生活+持续不断的努力积累。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ideally, you&amp;rsquo;ll make your money in discret lumps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以逐步增量的方式挣钱(而非暴发户)是最理想的。财富来得太快去得也快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.为社会创造它想要但是还不知道如何获取的东西(Give Society What It Doesn&amp;rsquo;t Know How to Get)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Society will pay you for creating what it wants, but doen&amp;rsquo;t know how to get, and delivering it at scale.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你能够规模化创造和交付社会想要，但是还不知道如何获得的东西，那么社会就会回报你。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Figure out what product you can provide and then figure out how to scale it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;基于你的特质/能力，思考你能够提供什么产品，然后思考如何能够规模化地交付这种产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Entrepreneur&amp;rsquo;s job is to try to bring the high end to the mass market&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;企业家的工作就将高端产品普及大众化。创造新事物 -&amp;gt; 预测社会需要这个新事物 -&amp;gt; 规模化生产 -&amp;gt; 普及到大众 -&amp;gt; 可盈利可持续&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.互联网极大扩展了职业的可能性(The Internet Has Massively Broadened Career Possibilities)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Internet has massively broadened the possible space of careers, by allowing you to scale any niche obsession.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;互联网极大的扩展了可能的职业空间，它让你可以规模化任何你擅长和痴迷的细分市场。每个人都独一无二，互联网连接每一个人，通过它，你可以为你的产品/天赋/技能，找到足够听众，不管距离多么遥远。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Escape competition through authenticity. No one can compete with you on being you.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过真诚避开竞争。不要模仿，不要复制，每个人都不同，每个人都各有所长，做你自己擅长的事，没有人可以和做自己的人竞争。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.和具有长线思维的人玩长线游戏(Play Long-term Games With Long-term People)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pick an industry where you can play long-term games with long-term people. All returns in life come from compound interest over many turns of the game.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选择一个你能够和具有长线思维的人玩长线游戏的行业。生命中所有的回报(关系/挣钱/学习)都来自于反复游戏后产生的复利效应。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When you switch industries, you&amp;rsquo;re starting over from scratch&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你频繁换行业，那们你就要每次从零开始。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Long-term players make each other rich. In short-term game, it seems like everybody is making themselves rich.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;长期玩家让彼此都致富，短期玩家只顾自己挣钱。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9.选择聪明，精力充沛和正直的合伙人(Pick Partners With Intelligence, Energy and Integrity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Picking partners with high intelligence, energy and integrity is the three-part checklist that you can&amp;rsquo;t compromise on.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;选择合伙人如下三点是你不能将就的:
- &lt;code&gt;聪明&lt;/code&gt;: 保证做事的方向正确，勤奋的蠢人很多
- &lt;code&gt;精力充沛&lt;/code&gt;: 聪明的懒人也非常多
- &lt;code&gt;正直&lt;/code&gt;: 这点最重要，没有这点上面两点归零&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Motivation has to come intrinsically. If you&amp;rsquo;re trying to keep someone motivated for the long-term, that motivation has to come intrinsically.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;必须是自激励和自驱动的人。如果你想让某人对某事长期处于激励状态，那么这种激励必须是发自内在的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Integrity is what someone does, despite what they say they do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;考察一个人是否正直，主要看他真正做了什么，而不是他说了什么。注意细微的细节(subtle signals)，当他认为周围没人在看的时候，他的所言所行。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People are oddly consistent.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;虽然可以短期隐瞒，但人的本性极具有一致性。如果一个人在餐厅对服务员不礼貌，那么他对你不礼貌只是时间问题。如果一个人有报复敌人倾向，那么他把你从朋友重新定义为敌人只是时间问题，你早晚会感受到&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Status Signalling: If you overtly bid for status, if you overtly talk about being high status, that is a low status move.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你过度看重和强调身份地位，你越可能内心自卑。你越讲自己诚实/可靠/正直，情况越可能相反。已有的实在的东西没必要强调，缺乏的虚的东西才需要强调。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10.和理性乐观者为伍(Partner With Rational Optimists)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t partner with cynics and pessimists. Their beliefs are self-fulfilling.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不要和愤世嫉俗和悲观者为伍，他们的信条是自证预言。自证预言者：如果别人失败了，他会说我早就预言会失败，如果别人成功了，他会说这是撞大运。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Either lead, follow, or get out of the way.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要么领导大家，要么跟随领导，要么让开。愤世嫉俗和悲观者，他们不想领导，不想跟随，也不想让开，他们只是无休止散布悲观言论。所有的成功人士都是行动导向的，判断某事是否可行的最简单方式就是行动。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Partner with rational optimists.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;乐观但是要理性，要清楚知道事物的艰难和不利面，但是依然乐观前行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11.用特长知识武装自己(Arm Yourself With Specific Knowledge)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Arm yourself with specific knowledge. It can&amp;rsquo;t be trained but it can be found by pursuing your genuine curiosity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;用特长知识武装自己。特长知识无法通过培训获得，它只能通过追寻你的单纯的好奇而获得。对特长领域的好奇可能源于先天基因，也可能在儿童时期养成，它构成你后续职业的核心竞争。特长知识几乎无法后天培养，大致20岁以后，个人的特长领域已经初步显现，你需要意识到自己的特长领域，并基于它构建你的职业。很多时候，个人其实并不能清楚认识到自己的特长领域，周围亲近的人反而更清楚。特长知识无法通过培训简单获得，如果社会能够培训你，那么它也能培训其他人，然后取代你&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12.特长知识具有高度创新和技术性(Specific Knowledge Is Highly Creative or Technical)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge tends to be creative or technical. It&amp;rsquo;s on the bleeding edge of technology, art and communication.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特长知识具有高度创新和技术性。它存在于技术/艺术/沟通的前沿。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge can be taught through apprenticeships.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过学徒关系可以获得特长知识。巴菲特(Warren Buffett)和格雷厄姆(Benjamin Graham)是一个典型例子。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Specific knowledge is highly specific to the situation, it’s specific to the individual, it’s specific to the problem, and it can only be built as part of a larger obsession, interest, and time spent in that domain.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;特长知识和情景/个体/问题领域高度相关。它只能通过对某个领域的痴迷/兴趣和大量时间的投入才能获得。简单读一本书，上一门课无法获取特长知识，特长知识也无法被编程为一个算法(无法自动化)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t be too deliberate about assembling specific knowledge. Build specific knowledge where you are a natural。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不要刻意追求特长知识(过于目标导向)，找到你内在真正擅长和喜欢的事(你天生就是干这个的料)，然后基于此构建特长知识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13.学习销售，学习制造(Learn to Sell, Learn to Build)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Learn to sell. Learn to build. If you can do both, you will be unstoppable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;学习销售，学习制造。如果你两样都会，你将不可阻挡。制造范畴：开发，制造，物流，采购，设计和运营服务。销售范畴：售卖，市场，沟通，招聘，筹钱，激励员工，公关&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The Silicon Valley model is a builder and seller&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;硅谷模式=世界级销售+世界级制造。例子，苹果创始人Steve Jobs + Steve Wozniak，微软创始人Gates + Allen，谷歌创始人Larry + Sergey。CEO + CTO组合。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you can do both you will be unstoppable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;两者兼备可创造整个行业。例子埃隆·马斯克(Elon Musk)，史蒂夫·乔布斯(Steve Jobs), 拉里·埃里森(Larry Ellison/Oracle)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;d rather teach an engineer marketing than a marketer engineering&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;制造者容易转行为销售者(前提沟通能力好)，销售者不易转成制造者。职业早期建议从制造者开始(打下基础)，后期可转行为销售者。制造者需要大量聚焦时间的投入，而且新人新产品始终会推陈出新，所以制造技能难以规模化和保持前沿，销售技能则长期更易于规模化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14.从读你喜欢的书开始，一直到你喜欢上阅读(Read What You Love Until You Love to Read)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;培养大量阅读和终身学习习惯。早期要读原创经典(基础+第一性原理)，以后各类学科都要广泛涉猎&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15.基础是数学和逻辑(The Foundations Are Math and Logic)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现代最重要五项基础技能：&lt;code&gt;阅读&lt;/code&gt;，&lt;code&gt;写作&lt;/code&gt;，&lt;code&gt;算术&lt;/code&gt;，&lt;code&gt;沟通(说服力)&lt;/code&gt;，&lt;code&gt;计算机编程&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16.没有所谓“商业&amp;rdquo;技能(There&amp;rsquo;s No Actual Skill Called &amp;ldquo;Business&amp;rdquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过实践锻炼你的做生意能力，而非纯理论学习。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The number of &amp;ldquo;doing&amp;rdquo; iterations drives the learning curve.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;试错迭代才能快速驱动学习曲线，迭代是不断尝试新的方法，而非重复劳动。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you&amp;rsquo;are willing to bleed a little every day, you may win big later&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;普通大众期望每天能挣一点，企业家则相反，他们愿意承受每天出一点血(比如损失金钱)，但最终可能会赢得更多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17.通过勇于承担风险来获得杠杆(Embrace Accountability to Get Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Embrace accountability. Society will reward you with leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;致富需要杠杆(人力/资金等)。只有建立勇于承担责任和风险的信誉，社会才会回报杠杆予你。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People who can fail in public have a lot of power.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;敢于公开承担失败的人其实非常强大。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18.通过勇于承担风险来赢得资产(Take Accountability to Earn Equity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If you have high accountability, you&amp;rsquo;re less replaceable and you can get a piece of the business.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你具有勇于承担风险的信誉，别人才会觉得你不可替代，才会把生意/资产交给你。位置越高，承担风险越大，同样受益也可能越大。船要沉没的时候，船长必须最后一个离开。公司破产的时候，员工最先得到工资补偿，然后是银行，最后才是资产投资人(风险最大，收益也可能越大)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Accountability is reputational skin in the game&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;skin in the game是风险共担意思，来自黑天鹅的作者塔勒布的新书《非对称风险》。回报要和风险承担成正比，敢于压上你的声誉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19.劳动力和资本是老式杠杆(Labor and Capital Are Old Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Wealth requires leverage. Labor and capital are older forms of leverage that everyone is fighting for.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;获得财富需要利用杠杆。劳动力和资本是几乎每个人都在竞争的老式杠杆。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Society overvalues labor leverage&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当前社会过度看重劳动力杠杆。看职位高低，就看带多少人，看公司实力，就看公司有多少人，实际上看的是能用多大的人力杠杆。
&amp;gt; You want the minimum amount of labor that allows you to use the other forms of leverage.&lt;/p&gt;

&lt;p&gt;劳动力杠杆的劣势：管人并不容易，需要很强领导管理技能；劳动力杠杆竞争非常激烈，一不小心会成为政治斗争或政变中的牺牲品(历史上资本和劳动力之间的斗争从未停止)。所以应该尽量减少劳动力杠杆的使用，你只需少量劳动力，能够支持你使用其它形式的杠杆即可。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Capital has been the dominant form of leverage in the last century.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;资本是上个世纪以来的一种主要的杠杆形式，少数人靠它获得巨量财富，大部分甚至还不懂如何利用它。资本是一种很强大的杠杆，可以转换成其它形式的杠杆(比如劳动力)，资本也易于规模化。运用好资本需要好的资本管理能力和分析技能&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You need specific knowledge and accountability to obtain capital&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你需要有特长知识和良好的信誉记录，社会才会放心把资本交到你手，以此作为杠杆，让你帮忙挣取更多资本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20.产品和媒体是新杠杆(Product and Media are New Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product and media are the leverage of new wealth. Create software and media that work for you while you sleep.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;产品和媒体几乎没有边际复制成本，是新财富的杠杆。从印刷出版开始 -&amp;gt; 到广播电视媒体开始加速 -&amp;gt; 互联网+代码大爆发。现在，你甚至可以不靠(或只是少量依靠)人力和资本杠杆，就可以放大你的努力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product leverage is where the new fortunes are made&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上一代财富主要靠资本杠杆，典型例子是巴菲特。新一代的财富主要靠代码和媒体杠杆，典型例子杰夫·贝佐斯(亚马逊创始人)，马克·艾略特·扎克伯格(Facebook创始人)，拉里·佩奇(谷歌创始人)，比尔·盖茨(微软创始人)，斯蒂夫·乔布斯(苹果创始人)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Combining all three forms of leverage is a magic combination&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;1.劳动力杠杆：工程师+设计师+产品开发。&lt;/li&gt;
&lt;li&gt;2.资本杠杆: 市场，广告，规模化&lt;/li&gt;
&lt;li&gt;3.代码+媒体杠杆&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三者结合可以产生巨大杠杆效应&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Product and media leverage are permissionless&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于劳动力杠杆，别人要愿意跟你才行。对于资本杠杆，要有人愿意投资给你才行。编程/写书/录制播客视频/写博客，所有这些都是不需要许可的，所以说它们是最公平的杠杆。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;21.产品杠杆人人平等(Product Leverage is Egalitarian)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Labor and capital are limited to the people who control those resources. But products reach global markets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;劳动力和资本仅限于控制这些资源的人，但是产品可以触达全球市场。产品杠杆是一种正和游戏，如果你在乎要以道德的方式获取财富，你最好使用代码和媒体来创造财富，因为这类产品任何人都可以使用(具有平等属性)，而劳动力和资本则只有少数人能够使用(不平等)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;22.寻找一个能够利用杠杆的生意(Pick a Business Model With Leverage)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ideally, you should pick a business model with network effects, low marginal costs and scale economies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你最好选择一个具有&lt;code&gt;网络效应&lt;/code&gt;的业务，&lt;code&gt;低边际成本&lt;/code&gt;，并且是&lt;code&gt;经济地规模化&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Scale economies: the more you produce, the cheaper it gets&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;规模经济&lt;/code&gt;: 生产越多，越便宜。造第12个产品比造第5个产品便宜，造第10000个产品比造前一个要便宜很多，这种方式易于商品化，并且能够自动给竞争者制造障碍&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Zero marginal cost of reproduction: producing more is free&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;零边际复制成本&lt;/code&gt;: 生产更多是免费的，典型例子是媒体产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Network effects: value grows as the square of the customers. Network effect business are natual monopolies.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;网络效益&lt;/code&gt;: 价值以客户的平方增长。典型例子: Facebook/Uber/Google/Twitter/YouTube。具有网络效应的业务具有天然垄断(natual monopolies)和赢者通吃(winner-take-all)特性。语言具有网络效应，未来世界可能只有英语和中文两种语言。货币也具有网络效应，未来世界可能只有一种储备货币(目前是美元)。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Zero marginal cost business can pivot into network effect business.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;零边际成本的产品-&amp;gt;易于规模化-&amp;gt;易于产生网络效益-&amp;gt;每增加一个用户都会增加整个网络的价值。网络效应是终极杠杆，你选择业务模式的时候一定要思考每增加一个客户，客户之间如何彼此增加价值，然后你躺在海滩上旅游的时候，客户都会自动增加价值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;23.从劳工到企业家的案例(Example: From Laborer to Entrepreneur)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The continuum from laborer to real estate tech company goes from low to high specific knowledge, accountability and leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从建筑工人到房地产技术公司的案例，展示特长知识、职责风险承担和杠杆，从低到高的发展历程。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Laborers get paid hourly and have low accountability&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;底层是建筑工人/水电工等，他们按小时计薪，但承担职责风险最小，社会地位低。他们需要掌握的特长知识很少，除了手头工具没有多少杠杆可用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;General contractors get equity, but they&amp;rsquo;re also taking risk.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第二层是总承包商，他们拥有资产，可以利用人力杠杆(承包工队)，可以获得项目收入的大头，但同时承担职责和风险也更多，如果项目失败，他们也要承担大头。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Property developers pocket the profit by applying capital leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;第三层是房地产开发商，他们利用资本杠杆获取利润。经验丰富的承包商可能转型为房地产开发商，他们发展出了地产领域的商业敏锐性（知道哪块地皮会增值，政策经济层面因素等)，然后他们有能力找到资本投资(自己也可投资)。这层需要更多特长知识，风险承担和利用资本杠杆的能力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Architects, large developers and REITs are even higher in the stack.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;建筑师，大开发商由于之前的成功带来的声誉，会让他们更加增值。也有部分转做房地产投资信托，他们同时熟悉房地产和金融/资本市场，他们不用去真正开发房地产，也不用管理很多人，他们可以充分利用资本杠杆。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Real estate tech companies apply the maximum leverage.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最上层是房地产技术公司(类似美国Trulia/RedFin/Zillow这样的公司)，他们可以最大程度利用杠杆。需要同时具备房地产、技术、投资领域的特长知识(一般需要互补团队)，承担职责和风险很高，可以利用的杠杆最大，同时潜在收益也可能最高。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;24.判断就是决断技能(Judgment Is the Decisive Skill)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In an age of infinite leverage, judgment becomes the most important skill。Leverage is a force multipler for your judgment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在杠杆几乎无限的时代，判断力成为最重要的技能。判断力是基础，杠杆则是判断力的倍增器。职业早期你忙于追逐杠杆，一旦获得杠杆，你需要歇一歇，因为这个时候判断力就更加重要了(因为风险也更大了)。巴菲特如此富有主要是因为他的判断力，即便你把他的钱全部拿走，明天投资者仍然会給他1千亿，因为他的判断力还在&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Without experience, judgment is often less than useless.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;光有高智商还不够，判断力源于快速迭代+实战体验。需要切身投入和切肤之痛(skin in the game)才会产生真正的判断力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The people with the best judgment are among the least emotional&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具有最好判断力的人是最不情绪化的。很多最好的投资人/企业家是近乎毫无情绪的机器人。情绪是真正阻碍你看清事物真相的东西。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The more outraged someone is, the worse their judgment.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个人越愤怒，他们的判断就越糟糕。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;25.给自己设定一个超高时薪(Set an Aspirational Hourly Rate)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If outsourcing a task will cost less than your hourly rate, outsource it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果外包某项工作所需费用比你的时薪少，那么就外包。对于大部分要花时间的事情，都要和你的时薪比较，再决定是否自己去做。如果致富你是的首要目标，那么你的主要时间都应该投在这件事情上。花费时间和别人争吵，买错小东西自己亲自去退货，都是浪费时间的蠢事。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You can&amp;rsquo;t penny pinch your way to wealth&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于基本的生活所需，你可以节俭，你也可以始终保持低开销，但是对于致富这件事情，你无法通过吝啬来实现。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;My aspirational rate was $5,000/hr&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我(原文作者)给自己设定的超高时薪是每小时5000美金。如果你给自己设定的超高时薪，看起来还没有到荒谬的程度，那么你设得还不够高。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You should be working on your product and getting product-market fit. And you should be exercising and eating healthy. That&amp;rsquo;s all you have time for while you&amp;rsquo;re on wealth creation mission. ~ Paul Graham(保罗·格雷厄姆)，美国著名程序员、风险投资家、博客和技术作家。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创业者只应该关注和花费时间在：产品，产品和市场契合，锻炼，健康饮食。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;26.奋力工作(Work As hard As You Can)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Work as hard as you can. Even Though what you work on and who you work with are more important.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果致富是你的目标(如果只是朝九晚五的上班则另当别论)，那么你必须奋力工作，同时要清楚意识到，做什么工作，和谁一起工作，比努力本身更重要&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;正确的工作领域&lt;/code&gt;: 最重要，选择职业或者做生意，先要弄清楚做什么，有没有市场，我能够开发出什么产品，能否发挥我的特长知识，我有没有兴趣能否持续投入&lt;/li&gt;
&lt;li&gt;其次是和&lt;code&gt;正确的人(聪明/精力充沛/正直)&lt;/code&gt;, 和优秀的人一起工作，优秀的标准也要超高(now matter how high your bar is, raise your bar)。&lt;/li&gt;
&lt;li&gt;最后才是&lt;code&gt;努力工作&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;Nobody really works 80 hours a week&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有人能真正工作80甚至120小时，这样说的人无非是在身份炫耀。没有人能持续工作80甚至120小时，同时还保持高产出和头脑清醒，你的脑袋会迟钝，灵感缺失。&lt;/p&gt;

&lt;p&gt;在知识领域的高效工作方式是：在灵感和兴趣来的时候，像冲刺一样奋力工作一段时间，然后休息一段更长的时间。这种方式更像猎捕狮子，而不是像马拉松，但长期看，致富的过程是一系列冲刺组成的一个马拉松。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Inspiration is perishable&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;灵感容易腐烂。灵感稍纵即逝，灵感点子来的时候要及时抓住，及时动手去做。比如脑中突然来了写博文的灵感，马上动手去写，如果延迟或迟疑，它可能很快消失。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Impatience with actions, patience with results.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对行动可以没有耐性(积极行动)，但是对结果要有耐心。灵感来的时候，抓住行动，问题来的时候，不睡觉也要解决。但是产品被市场接受需要很长时间，与人合作磨合也需要很长时间，伟大的产品诞生需要不断的打磨，打磨，再打磨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;27.你应该足够忙，没有多少时间去社交(Be Too Busy to &amp;ldquo;Do Coffee&amp;rdquo;)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You should be too busy to &amp;ldquo;do coffee&amp;rdquo;, while still keeping an uncluttered calendar&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你应该足够忙，没有多少时间去社交，同时日程表最好空白，换句话说，你应该专注自己的要事，没有时间社交和开会。&lt;/p&gt;

&lt;p&gt;在职业早期的探索(exploring)阶段，你可以参与一些社交和建立一些关系。在职业的中后期利用(exploiting)阶段，你有更重要的事情要做，你必须无情地将会议从你的生活中剔除。&lt;/p&gt;

&lt;p&gt;如果某人要和你开会，你就问能否用电话代替。如果某人要和你电话沟通，你就问能否用电子邮件代替。如果某人想要发电子邮件给你，你就问能否用短信代替，实际上到这一步，大部分短信都是可以忽略的，除非是真正紧急的事情&lt;/p&gt;

&lt;p&gt;你应该无情地拒绝会议。如果真的要开会，就边走边谈，或站着谈。让会谈保持简短，保持行动导向(actionable)。大部分超过8个人的圆桌会议，不会有任何产出，你基本上浪费至少一个小时。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;People will meet with you when you have proof of work&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你手头真有重要和有价值的产品，可以考虑找合适的人会谈合作。找重量级投资人谈，你必须先有工作证明(proof of work，区块链术语)，也就是你实际开发的产品或者项目进度，而不是ppt，更不是脑袋里的想法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Networking is overrated even early in your career&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即便在职业早期，社交的作用也被夸大了。通过社交手段建立人脉获得机会，表面上看如此，实际这种机会顶多是第一(撞大运)和第二类(奋力争取带来的好运)。你应该把重点放在第三(积极准备带来的好运)和第四类(独特个性带来的好运)，专注建立声誉，开发产品，建立独特视角，善于发掘机会(在别人还没看到时)。&lt;/p&gt;

&lt;p&gt;忙碌的日程表和忙碌的脑瓜，做不了伟大的事情。自由的时间和思考，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;28.不断重新定义你的工作(Keep Redefing What You Do)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Become the best in the world at what you do. Keep redefining what you do until this is true.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在你专注的工作上做到世界最佳，不断重新定义和打磨你的工作，直到世界最佳成真。这个工作必须和你的特长知识/技能/职位/能力/位置/兴趣相匹配(遵循自己的内心，being authentic to yourself)，探索之旅会很漫长，但你始终要意识这点。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Find founder-product-market fit&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;企业家最重要的事：找到有&lt;code&gt;市场&lt;/code&gt;的&lt;code&gt;产品&lt;/code&gt;，而且你天生&lt;code&gt;擅长&lt;/code&gt;干这事，三者缺一不可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;29.通过做自己避开竞争(Escape Competition Through Authenticity)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Competition will trap you in a lesser game&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;受到社会上身份地位游戏的影响，我们容易追逐模仿而迷失自我。如果周围的人都是成功的商务人士，我也要成为商务人士。如果我周围的人都是成功的社会活动家，我也要成为社会活动家。如果我周围的人都是成功的架构师，我也要成为架构师。实际上这种追逐模仿更多是一种零和竞争游戏。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;No one can complete with you on being you&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;没有人能够和做自己的人竞争，做你最擅长的事，基于你的特长知识打造你的核心竞争。同时也要注意产品和市场匹配问题(product-market fit)，如果真实做自己，但是市场不大，你也要注意调整。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In entrepreneurship, the masses are never right&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从企业视角看，大众判断往往不正确。如果大众判断正确，那么大家早就发财致富了。如果大众都在谈论某个领域或产品，那么恰恰说明这个领域的竞争趋于饱和，已经没有多少机会了。相反，如果没人谈论某个领域，则可能这个领域的机会也不大。企业家需要在两者之间找到平衡。大部分人倾向模仿追逐热点，伟大的企业家倾向真实做自己。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Combine your vocation and avocation&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最好将自己的事业和爱好结合起来，这样的人更容易做自己。经过不断尝试，很多人最终会找到自己最擅长的事业。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;30.玩愚蠢的游戏，赢愚蠢的奖励(Play Stupid Games, Win Stupid Prizes)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Competition will blind you to greater games. You&amp;rsquo;re one step away from a better market.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;热衷模仿竞争会蒙蔽你的双眼，陷入零和游戏，让你迷失自我。真实面对自己和客户才能找到更好市场。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;31.最终你会获得你应得的（Eventually You Will Get What You Deserve）&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Apply specific knowledge with leverge and eventually you will get what you deserve.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果满足特长知识，责任心，利用杠杆和真实做自己这些先决条件，那么从足够长的时间范围来看，你最终会获得回报。这个通常需要十年甚至二十年，也有快的三五年的，但是这种是例外。期间你会经历很多失败，但在企业界，有时往往做对一次就够了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;What are you really good at that the market values?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;致富要素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.特长知识的稀缺性&lt;/li&gt;
&lt;li&gt;2.能够利用多大的杠杆&lt;/li&gt;
&lt;li&gt;3.判断力的准确度&lt;/li&gt;
&lt;li&gt;4.责任心强度&lt;/li&gt;
&lt;li&gt;5.所做事情的社会价值多大(product market fit)&lt;/li&gt;
&lt;li&gt;6.持续投入时间+持续学习改进&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;核心:&lt;/code&gt; 你擅长(特长知识)+社会需要(product market fit)，其它自然会来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;32.拒绝大部分建议(Reject Most Advice)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Most advice is people giving you their winning lottery ticket numbers. The best founders listen to everyone but make up their own mind.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你问那些速成人士是如何获得成功的，他们可能只是告诉你他们中奖的彩票号码(也就是说，你得到的建议往往只适用于特定的人和特定上下文环境)，可能完全不适用于你和你的环境。你应该关注系统，而非单一目标，也就是什么的系统或者说环境，才促成了某些人的成功。盲目生搬硬套只会适得其反。&lt;/p&gt;

&lt;p&gt;真正的创始人会聆听所有人的视角和建议，但是在最后做决策时，他会忽略所有人，而是根据自己的系统和上下文做决定。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Advice is maxims you can recall later, when you get your own experience.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓建议可以认为是一种格言，也就是你有了自己体验之后，你能回忆起来并能对上号的格言。本文的35条建议也是35条格言，我(原文作者)碰到问题时也时常会回顾这些格言，作为我的处事指导，比如是否要和某人一起共事，如果我不能和他一起共事10年(长线游戏)，那么我何必要和他共事一天？如果你看过建议以后有体验共鸣，那么对你就要价值；如果你无感，那么请忽略，继续做自己的事就好了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;33.平和的内心，健康的身体和充满爱的家庭(A Calm Mind, a Fit Body, a House Full of Love)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;When you&amp;rsquo;re finally wealthy, you&amp;rsquo;ll realize it wasn&amp;rsquo;t what you were seeking in the first place.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当你某天最终变得富有，你会意识到这其实并不是你最初的追求。钱只能解决你钱的问题(获得一定的物质世界的自由度)，但是内心的平静，健康的身体，和谐有爱的家庭，这些靠钱买不来，这些也要靠你去挣取，不可偏废。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;34.致富没有捷径(There Are No Get Rich Quick Schemes)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Get rich quick schemes are just someone else getting rich off you.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓的致富速成，往往是别人想从你身上挣钱的把戏。世界是一个高效之地，如果有容易挣钱的地方，那么这个地方早就被探索和利用过了。&lt;/p&gt;

&lt;p&gt;另一方面，作为专家或成功人士，可以给其他人一些(高质量和可执行的)致富建议，同时要坦承过程漫长且艰难，否则会毁掉自己的声誉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;35. 将自己产品化(Productize Yourself)&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Figure out what you&amp;rsquo;re uniquely good at and apply as much leverage as possible.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;找到你擅长的事业，并尽可能利用杠杆。Productize Yourself，把独特的你和你的特长知识进行产品化，勇于承担风险，真实面对自己，充分利用杠杆规模化你的产品。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Making money isn&amp;rsquo;t even something you do, it&amp;rsquo;s not a skill. It&amp;rsquo;s who you are.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;做最真实的自己，&lt;code&gt;挣钱并不是关于你做的事情，也不是一种技能，而是你到底是谁的问题。&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Find hobbies that make you rich, fit and creative&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;挣钱是一个函数，输入是你的身份和你的爱好。找到你的三个爱好，一个让你挣钱，一个让你健康，一个让你富有创造力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2019年总结之瞎扯淡</title>
      <link>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E7%9E%8E%E6%89%AF%E6%B7%A1/</link>
      <pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E7%9E%8E%E6%89%AF%E6%B7%A1/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;大胡子&lt;/code&gt;是我特别佩服的一位老师，第一次知道他是17年偶尔一次线上讲座，具体题目忘记了，内容大概是关于&amp;rdquo;技术人如何赚钱&amp;rdquo;，很real，告诉一些晚辈如何赚钱，以及拥有一些赚钱思维，我觉得这个真的很酷。后来才了解到他的&lt;code&gt;疯人院&lt;/code&gt;和星球，所以立马入会，所幸会费不是很高(这要是再高个几百的，当时的我是肯定不会去&amp;rdquo;割韭菜&amp;rdquo;社群)。不过，在这两年里，虽然不曾在社群发表自己的观点，但是通过群里各种大牛、前辈们的探讨，在加上自己的思考，也的确让自己再技术之外成长了很多，所以，在这里我向大家极力推荐大胡子老师，他的公众号是&lt;code&gt;姜胡说&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;年初了，总该总结总结过去一年的成长和收获，也该去梳理梳理新一年的征程如何走下去，这里有一篇胡子老师的文章，觉得很有意思，感兴趣的可以去仔细读读&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzIxMjE4NzM5MA==&amp;amp;mid=2651785933&amp;amp;idx=1&amp;amp;sn=867e1c2e54dc124d60d9ad3c7a759a49&amp;amp;chksm=8cb24b5cbbc5c24a7a3f51f882e2a8c13f05312bdf33d5a5e03e52ea89eb818b32dfad65a43b#rd&#34;&gt;早知道这个，我至少可以少奋斗3年&lt;/a&gt;，虽然有点标题档了，但不妨碍这依然是一篇值得看和值得思考的文章.&lt;/p&gt;

&lt;p&gt;以下摘录几个观点，用于鞭策自己:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Stay hungry,Stay foolish&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Stay hungry,Stay foolish!&lt;/code&gt;是乔布斯老爷子在斯坦福大学大学演讲时结尾的一句话，翻译过来即为&amp;rdquo;求知若饥，虚心若愚&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;记得那个时候我还在上大学，乔老爷子的自传以及演讲都那么激动人心，我还曾经将&lt;code&gt;Stay hungry,Stay foolish!&lt;/code&gt;作为我的微信签名，直到后来我懂得了做的重要性，才将微信签名换成如今的&lt;code&gt;Never try,Never known!&lt;/code&gt;。要说&amp;rdquo;Stay hungry,Stay foolish&amp;rdquo;是内在修养的话，那么&amp;rdquo;Never try,Never known&amp;rdquo;就是外在表现，我们要一直对外保持不断的好奇心，不断尝试，只有不断尝试，我们才会发现我们是多么的无知，而当你长时间处于无知状态时，往往会被别人远远的甩在最后。&lt;/p&gt;

&lt;p&gt;所以，&lt;code&gt;当你对这个世界失去了敬畏和好奇心时，你就一定会落后&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;落后就肯定会挨打，我相信从小到大大家都不愿成为挨打的那个人。&lt;/p&gt;

&lt;p&gt;那该怎么办呢？我在&amp;rdquo;Stay hungry,Stay foolish&amp;rdquo;的后面再加一个&amp;rdquo;Never try,Never known!&amp;ldquo;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Stay hungry: &lt;code&gt;保持对知识的敬畏，保持对这个世界的好奇心&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Stay foolish: &lt;code&gt;接触到新事物时，不要让固有的观念影响自己。真正强大的人，允许自己的大脑里同时存在两种或者两种以上完全相反的声音。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Never try,Never known: &lt;code&gt;不去尝试，永远不知道这个世界本身的运行机制，当你知道再多也不去尝试仍然是不知道&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.技不压身&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;像我们搞运维的，最早之前可能会比较熟悉使用Linux，然后擅长Linux环境下一些常用服务的规划和实施，并且能够尽快排查故障和问题。在我刚开始从业的一段时间，我一度有点茫然，纠其原因是因为运维这个行业，起码像我上面提到的这个定义，其实任何一个有相关技术背景，并且本身还算是一个靠谱的人，及时对运维一点儿也不懂，如果有运维的活儿，那他也一定可以完成，不过就是多花点时间多花点儿精力而已。&lt;/p&gt;

&lt;p&gt;所以，我那个时候在想，作为一个运维从业者，未来将如何破局。这就跟一两年前同行相遇都会问&amp;rdquo;我们搞运维的，要不要去学点开发啊&amp;rdquo;，到目前为止，我想市面上应该再没有不懂开发的运维了吧。至少你写个Python、Shell、Perl脚本是最基本的吧,再有甚者可能还会对运维有Golang或者Java开发的能力的要求。&lt;/p&gt;

&lt;p&gt;那我想说的也是:&lt;code&gt;多了解一些其他技术，对运维，甚至是其他事情都会有莫大的好处&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;这两年我也因此去多学习了一些其他技术，比如&lt;code&gt;Golang、Vue、基于Hadoop体系的大数据处理&lt;/code&gt;，虽然在这几个方面都不是很深入，也不是很资深，但此时作为一个运维从业者来说，或者想要成为一个更加优秀的运维从业者来说，这些技能都是非常有帮助的。&lt;/p&gt;

&lt;p&gt;2020年，我会在巩固常用技术的基础上再去多拓展一些技术，比如&lt;code&gt;Rust&lt;/code&gt;或者&lt;code&gt;JavaScript&lt;/code&gt;之类的，毕竟2020年都要实现全面建设小康社会了，我们自身的技能也应该再全面一些不是么？&lt;/p&gt;

&lt;p&gt;有些人可能就会说了，学那么多技术，也不一定用的上，其实古人有句话就是&amp;rdquo;书到用时，方恨少&amp;rdquo;，很多时候我们在不断学习和了解的过程中并不一定是在未来一定要用它，而是&lt;code&gt;用整个经历来还原他人决策的依据&lt;/code&gt;，让你能够以更贴近他人的角度去理解一件事，更何况万一在未来用上了，不是也不用去求他人了不是。&lt;/p&gt;

&lt;p&gt;这个时候，可能还会有人说了，我想去学习一些先进的技术，但是在国内网站上都无法找到，而且信息杂乱。其实，只要你确定了要去学习一些新技术，那怎么学就不是那么重要了，毕竟&lt;code&gt;做什么比怎么做更重要&lt;/code&gt;，是吧，只要目标明确，就一定能找到对应的途径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.知识获取&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;接着上面说到的，我想学习一门新技术，我该如何去学习呢？&lt;/p&gt;

&lt;p&gt;我的建议其实如同大胡子老师的观点，一定要吸收&lt;code&gt;最原始的知识&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一定要&lt;code&gt;拒绝二手知识。更何况是三手、四手。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前两天，偶然在群里看到有小伙伴说&amp;rdquo;现在就是照着网上的配置抄，然后埋大bug&amp;rdquo;。现实可能的确是这样的，因为大家时间都很宝贵，遇到问题也都着眼于解决眼下&amp;rdquo;问题&amp;rdquo;，所以对于本质问题也少有人会追根溯源了。这就是典型的多手知识，目前网络上充斥着各种良莠不齐的文章，我们可能不了解别人的场景，也不了解问题的上下文，照抄别人的配置，可能是暂时解决问题了，也许也埋下了一个祸根，但终究对于我们个人而言，没有任何成长。&lt;/p&gt;

&lt;p&gt;胡子老师在那篇文章说:
&amp;gt; 读书这种事很美妙。
&amp;gt; 思考也是。
&amp;gt; 不要让他人剥夺走。
&amp;gt; 获取一些有养料的知识。
&amp;gt; 不仅仅是读书。&lt;/p&gt;

&lt;p&gt;我们搞技术的人，大多数场景都在使用开源技术构建产品，所以在成长的路上我们完全可以阅读那些&lt;code&gt;官方文档&lt;/code&gt;，及时那些英文官方文档不那么容易理解，我也依然建议去阅读官方文档，起码在核心问题上，要比那些多手翻译的官方文档要好很多。再者，我们如果有时间和经历，其实是可以针对核心逻辑去阅读源代码来追溯源头。&lt;/p&gt;

&lt;p&gt;到现在为止，我在工作上遇到的任何技术问题，如果是开源组件，我都会第一时间去&lt;code&gt;GitHub&lt;/code&gt;或&lt;code&gt;Google&lt;/code&gt;上查找官方文档，当然我也会借鉴一些多手翻译的官方文档(毕竟英语水平不咋地)。&lt;/p&gt;

&lt;p&gt;当然这里并不是想说是怎么去获取知识的，而是一种思维模式，即&amp;rdquo;对于知识，我们一定要思考要不要去学习，然后找到一手渠道去学习最原始、最纯的知识&amp;rdquo;。知识其实是无处不在的，我们需要的是有鉴别知识的能力.&lt;/p&gt;

&lt;p&gt;然后，&lt;code&gt;基于需求或者人类的社会动机将那些想法进行分类整理&lt;/code&gt;。 这句话也是胡子老师文章中的，很有感触。将我们学到知识进行分门别类，仔细想想，&lt;code&gt;一个不能和人类需求和社会动机联系在一起的知识，它可以用在什么地方呢？&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以尝试思考一下:
&amp;gt; 这条信息主要覆盖哪个团体和人群？
&amp;gt; 这个想法代表了哪些深层的人类需求和行为？
&amp;gt; 这件事有趣的地方在哪里？
&amp;gt; 别人是怎么做的？
&amp;gt; 不同团体之间他们互相是如何做的？&lt;/p&gt;

&lt;p&gt;最后，依然以大胡子老师的话结尾。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;观察生活中既有的生活方式,
和那些新鲜事物做对比。看看发生了什么。
最后&lt;code&gt;把所有的问题全部回归到人类的需求和社会动机上来。&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;人活着都有什么需求，你考虑了，别人没考虑，那，这就是你和别人的差距。&lt;/p&gt;

&lt;p&gt;劳心者制人，劳力者制于人，这才是自然规律。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gai9amj2lcj30vu0b275p.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>2019年总结之财务投资</title>
      <link>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E8%B4%A2%E5%8A%A1%E6%8A%95%E8%B5%84/</link>
      <pubDate>Mon, 30 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/2019%E5%B9%B4%E6%80%BB%E7%BB%93%E4%B9%8B%E8%B4%A2%E5%8A%A1%E6%8A%95%E8%B5%84/</guid>
      
        <description>&lt;p&gt;18年的时候，我在个人公众号&lt;code&gt;BGBiao&lt;/code&gt;上写了一篇关于如何&amp;rdquo;选鸡&amp;rdquo;的文章，大概介绍下了作为一名不了解投资和没有投资经验的人如何选一只性价比较高的基金，感兴趣的同学可以回顾下&lt;a href=&#34;https://mp.weixin.qq.com/s/swAOiIT-tWkpC0wa24C51Q&#34;&gt;门外汉如何选择一只&amp;rdquo;鸡&amp;rdquo;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;作为一个在IT行业工作的人来说，我认为非常有必要提前考虑个人的投资和理财计划，毕竟年轻时的高薪和高强度工作很容易让你在后面很多年感觉到无所适从，因为随着年龄的增大，持续高薪的工作并不好找，而且高强度的工作，也可能没有小伙子们的那种撑劲儿，所以，提前规划自己的理财和投资，我个人觉得还是蛮重要的。&lt;/p&gt;

&lt;p&gt;2019年即将结束，回想一下自己过去一年的&amp;rdquo;选鸡&amp;rdquo;经历，还是想在这里总结一下，并希望和期待今后能够做的更好，同时也希望将自己总结的几个点分享出来。&lt;/p&gt;

&lt;p&gt;先晒一下过去一年入仓的一些&amp;rdquo;鸡&amp;rdquo;以及整体的收益状况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaf2h7cjwyj30cn29cn1y.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.基金投资如何开户&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;购买基金一般可以从基金公司官网、银行、以及第三方基金销售平台购买。&lt;/p&gt;

&lt;p&gt;不过通常情况下，我都会在第三方App上进行投资，比如我会使用&lt;code&gt;支付宝&lt;/code&gt;和&lt;code&gt;天天基金网&lt;/code&gt;来进行基金投资，一个是因为方便和权威，并且基金的种类也特别丰富，另外一个原因是在这些平台上通常都会有较低的费率(通常有1折优惠)。&lt;/p&gt;

&lt;p&gt;有些人可能会问，为什么同时使用两个软件进行基金投资，其实最早是因为刚工作那会，支付宝有余额，想着可以通过一种理财策略来省钱，但是又不甘心余额宝那么低的收益，所以当16年左右，支付宝刚开始推出&amp;rdquo;一天10块钱，轻轻松松做理财&amp;rdquo;时，就买了些基金，并一直观察持有，且不断加仓(搞理财的都知道，频繁换手其实是非常不利的，所以既然认定了一只好鸡，索性就一直将这只鸡重仓在支付宝了).&lt;/p&gt;

&lt;p&gt;&lt;code&gt;天天基金网&lt;/code&gt;是在我开始玩基金一段时间后，向一个在银行从业的朋友那了解到的，当时是想象她请教如何选鸡，如何交易，所以后面更多就使用该软件来进行交易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.投资基金应该如何配置基金&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基金其实分很多种类，在之前的文章中，我好想写过，比如说有纯债基金，混合基金，指数基金，股票型基金等等。&lt;/p&gt;

&lt;p&gt;通常情况下来讲，混合基金，要看基金经理本身的能力，这个需要有一定的经验去挑选基金经理。&lt;/p&gt;

&lt;p&gt;如果想简单操作，搭配纯债基金+指数基金，这个方案也是没问题的。&lt;/p&gt;

&lt;p&gt;不过在我入仓的一些基金里，大部分都是股票型基金，当然了风险也会相对的比较高，因此对于该基金背后的团队，以及基金经理还有所持有的股票都需要有一定的了解，相对于普通人来说会有一定的难度。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.如何入仓&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的建议是通过&amp;rdquo;基金定投&amp;rdquo;来入仓和不断加仓。&lt;/p&gt;

&lt;p&gt;因为使用基金定投从长远角度来考虑可以将整体的风险降低，并且可以不断的累计自己的基金池。&lt;/p&gt;

&lt;p&gt;相反，如果是追涨杀跌，看着基金涨了就想多买点，这会影响定投摊平风险的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.注意事项&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;建议在刚开始玩基金时，不要对收益有太大的幻想，因为任何成长都需要有成本的，不论是资金成本还是时间成本或者知识成本，但是如果选择定投基金，从长远角度是肯定会存储一笔资金的。另外，对于基金的买卖一定要沉住气，切勿&lt;code&gt;追涨杀跌&lt;/code&gt;，在我个人刚开始玩基金时，会频繁根据涨跌情况去调仓，后面会发现其实很多调仓都会出现反涨的情况，再加之费率的问题，其实整体会很不划算。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips: 其实还有另外一个技巧就是，当你看好一只基金时，除了定投之外，也可以定期的去看基金一天的估价，通常情况下，在交易日下午三点前会是一个相对稳定的估价，此时可以做一些类似买跌类的操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先简单分享到这里，业余玩鸡，2020年一起进步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexzwmo1wj30j60pa40b.jpg&#34; alt=&#34;知识星球&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://tva1.sinaimg.cn/large/006tNbRwly1gaexte72s7j31bi0hc418.jpg&#34; alt=&#34;公众号&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>CronJob控制器中的一些绕坑指南</title>
      <link>https://bgbiao.top/post/cronjob%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E5%9D%91%E6%8C%87%E5%8D%97/</link>
      <pubDate>Sun, 29 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/cronjob%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%95%E5%9D%91%E6%8C%87%E5%8D%97/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;背景: 作为企业里唯一熟悉各种云产品的工种，通常需要和各种云产品打交道。当前，我们大部分的云基础设施和云服务都运行在阿里云上，而每个云产品都有独立的管理系统，这使得我们在运维过程中经常无法将相关产品和关联信息有效的组织在一起，来进行快速的问题诊断和信息查询，这对于运维和开发同学来说，在多个系统之间来回跳转查找关联信息是一个低效且极易出错的事务，因此通常来讲，不论是作为运维和开发，我们都希望将企业关联的云资源和服务进行整合关联，以实现效率的最大化。而在这过程中，我们采用Kubernetes集群的CronJob来定期获取阿里云的一些资源，在这过程中，遇到一些问题，根据问题重新细读CronJob官方文档，特记录于此。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;CronJob简单介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个&lt;code&gt;CronJob&lt;/code&gt;对象就像是一个Linux环境的&lt;code&gt;crontab&lt;/code&gt;文件一样，它会在给定的调度周期(crontab格式)内定期的创建一些job.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意:&lt;/code&gt;所有的定时任务的调度周期都依赖于k8s的master节点的时区&lt;/p&gt;

&lt;p&gt;通常情况下，CronJob对于创建定期和重复的任务非常有用，比如定期的备份和邮件发送之类的任务场景。&lt;/p&gt;

&lt;p&gt;当然了，在Kubernetes集群中，Cronjob也有一些局限性和特性，需要详细了解下才能用的比较好。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: Cronjob控制器当前官方仍然是beta版本，也就意味着还是有一些问题存在的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cronjob的局限性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个Cronjob会在它每执行一次调度就&lt;code&gt;大概&lt;/code&gt;会创建一个Jobs对象。&lt;code&gt;大概&lt;/code&gt;是因为有时候可能会有两个job被创建，或者没有任务创建。
官方实现中尝试去解决这种问题，但是目前仍然无法避免。因此在设计过程中，所有的Job都应该是幂等性的(idempotent)&lt;/p&gt;

&lt;p&gt;如果&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数被设置为一个比较大的值，或者没有设置(默认)，并且&lt;code&gt;concurrencyPolicy&lt;/code&gt;设置为&lt;code&gt;Allow&lt;/code&gt;，那么Job总是会运行至少一次。&lt;/p&gt;

&lt;p&gt;对于每一个Cronjob来说，&lt;code&gt;CronJob&lt;/code&gt;控制器会检查从上一次调度时间到现在的持续时间内它错过了多少个调度，如果错过调度100次，它将不再执行调度，并且会有如下相关异常.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;Cannot determine if job needs to be started. Too many missed start time (&amp;gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;值得关注的是，如果设置了&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数(不为空),控制器统计错过的调度次数将不再是从最后一次调度时间，而是
从&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;的值到现在进行统计。比如，如果设置&lt;code&gt;startingDeadlineSeconds:200&lt;/code&gt;,控制器会统计在最后200秒内错
过了的调度次数。&lt;/p&gt;

&lt;p&gt;如果CronJob未能在预定时间创建，则该任务将被视为错过调度。比如，当设置&lt;code&gt;concurrencyPolicy: Forbid&lt;/code&gt;时，当前一个任务还在运
行时CronJob尝试再次被调度，此时会被&lt;code&gt;forbid&lt;/code&gt;掉，因此也会被记录为错过一次调度。&lt;/p&gt;

&lt;p&gt;再比如，我们假设一个定时任务被设置在&lt;code&gt;08:30:00&lt;/code&gt;后每一分钟执行一次，并且&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数没有被设置。如果CronJob控制器在&lt;code&gt;08:29:00&lt;/code&gt;到&lt;code&gt;10:21:00&lt;/code&gt;之间故障了，Job将不会运行，因此错过调度的任务数量将远超过100。&lt;/p&gt;

&lt;p&gt;为了更深层次说明这个问题，假设一个定时任务被设置在&lt;code&gt;08:30:00&lt;/code&gt;开始每一分钟执行一次，并且&lt;code&gt;startingDeadlineSeconds:200&lt;/code&gt;。如果CronJob控制器依然在相同时间段故障了，Job将会在&lt;code&gt;10:22:00&lt;/code&gt;开始继续执行。 因为控制器仅会计算在过去的200秒内，错过调度的
次数有多少，因此仅会错过调度3次，远远小于100次，所有定时任务会在控制器恢复后继续调度，而不会影响正常的任务。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，CronJob仅负责调度和创建匹配的Jobs，而由Jobs真正去管理真正执行任务的Pods。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cronjob的参数详情&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;spec.startingDeadlineSeconds&lt;/code&gt;: 表示统计错过调度次数(100次)的开始时间，默认从最后一次调度时间开始统计错过调度次数(超
过100不再调度)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.concurrencyPolicy&lt;/code&gt;: 并发调度策略，可选值:{&amp;ldquo;Allow&amp;rdquo;:&amp;ldquo;允许并发&amp;rdquo;,&amp;ldquo;Forbid&amp;rdquo;:&amp;ldquo;不允许&amp;rdquo;,&amp;ldquo;Replace&amp;rdquo;:&amp;ldquo;调度覆盖&amp;rdquo;}.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Allow&lt;/code&gt;: &lt;code&gt;注意:&lt;/code&gt;当设置为&lt;code&gt;Allow&lt;/code&gt;时，需要考虑到任务执行时间和调度周期，因为可能上个任务没执行成功，下个任务就到执行时间了，如此下来可能会有很多任务都执行积压，造成资源误使用;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Replace&lt;/code&gt;: 当使用&lt;code&gt;Replace&lt;/code&gt;遇到上述情况，后个任务会将前一个任务替换掉，如此以来所有的任务可能都不会完整执行;&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Forbid&lt;/code&gt;: 则不允许并发调度，也即就调度一次，下一次调度周期再调度，但是可能由于任务执行过长，导致大部分的任务在每一
次调度时间都完美的错过了，此时&lt;code&gt;startingDeadlineSeconds&lt;/code&gt;参数也并没有设置，就可能会出现该任务不会再调度，对应到k8s里的事
件可能是&lt;code&gt;Cannot determine if job needs to be started: too many missed start time (&amp;gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.schedule&lt;/code&gt;: 调度周期，格式为标准的crontab格式[分 时 日 月 周]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.failedJobsHistoryLimit&lt;/code&gt;: 历史失败的任务数限制(通常可以保留1-2个，用于查看失败详情，以调整调度策略)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.successfulJobsHistoryLimit&lt;/code&gt;: 历史成功的任务数限制(可以自己决定保留多少个成功任务)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.jobTemplate&lt;/code&gt;: 标准的pod运行的模板(容器运行时的相关参数)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;spec.suspend&lt;/code&gt;: 可选参数，如果设置为&lt;code&gt;true&lt;/code&gt;,所有后续的任务都会被暂停执行，该参数不适用于已经运行的任务，默认为False&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;CronJob示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre class=&#34;chroma&#34;&gt;# 配置了一个定期去阿里云云解析获取解析详情的数据
$ cat dnsall-cronjob.yaml
apiVersion: batch/v1beta1
kind: CronJob
metadata:
  labels:
    run: dnsall
  name: dnsall
  namespace: myapp
spec:
  # 强烈建议设置并发策略，根据调度周期和任务特性进行设置
  concurrencyPolicy: Forbid
  # 强烈建议设置失败任务数，用于排查任务失败根因，以优化任务
  failedJobsHistoryLimit: 1
  successfulJobsHistoryLimit: 3
  # 强烈建议设置错过调度的计算时间
  startingDeadlineSeconds: 600
  # 调度周期
  schedule: &amp;#39;05,15,25,35,45,55 */1 * * *&amp;#39;
  suspend: false
  jobTemplate:
    metadata:
    spec:
      template:
        metadata:
          labels:
            run: dnsall
        spec:
          imagePullSecrets:
          - name: mydocker
          containers:
          - args:
            - -cmdbtype
            - dns
            image: harbor.bgbiao.top/cron-job:2019-12-04
            imagePullPolicy: Always
            name: dnsall
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
          dnsPolicy: ClusterFirst
          # 强烈建议设置任务的重启策略(任务的失败会触及到Jobs控制器中的Backofflimit参数，导致job失败)
          restartPolicy: OnFailure
          schedulerName: default-scheduler
          securityContext: {}
          terminationGracePeriodSeconds: 30

$ kubectl  get cronjob -n myapp
NAME             SCHEDULE                      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
dnsall           05,15,25,35,45,55 */1 * * *   False     0        8m41s           23h

# cronjob其实定期的创建了job，因此具体的任务pod其实是由job控制器来维护的
# 这里可以看到，我们上面的cronjob保存的三个执行成功的任务
$ kubectl  get jobs -n myapp  | grep dns
dnsall-1577597100           1/1           23s        22m
dnsall-1577597700           1/1           24s        12m
dnsall-1577598300           1/1           24s        2m22s

# 再查看一个job真正管理的pod任务的执行
# 任务已经已完成，所以任务的期望值为1，当前值为0
$ kubectl  get pods -n myapp | grep dnsall-1577598300
dnsall-1577598300-hdl4z           0/1     Completed   0          3m29s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>软件工程师们必须了解的画图工具</title>
      <link>https://bgbiao.top/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%AC%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 16 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bgbiao.top/post/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BB%AC%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E7%94%BB%E5%9B%BE%E5%B7%A5%E5%85%B7/</guid>
      
        <description>&lt;blockquote&gt;
&lt;p&gt;作为一名在IT行业摸爬滚打多年的少年，选择一款适手的画图工具可以说是爽到不行。记得学生时代，鉴于条件的限制，都只能选择Visio进行绘制流程图、类图、UML图等，但是微软家的东西，大家也懂。特别是作为一名长期混迹在开源世界的从业者，我们都喜欢使用一种免费且好用的替代方案来完成日常的工作需求。比如&lt;code&gt;Markdown&lt;/code&gt;就基本上成功替代了&lt;code&gt;Document&lt;/code&gt;去编写文档，然后&lt;code&gt;Xmind&lt;/code&gt;、&lt;code&gt;ProcessOn&lt;/code&gt;、&lt;code&gt;Draw&lt;/code&gt;之类的工具基本上也可以实现对&lt;code&gt;Visio&lt;/code&gt;的替代，当然我这里仅说的是我个人遇到的情况，不能以偏概全，微软家的很多产品也依然是不错的。接下来像大家推荐几个常用的画图工具.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;在线类产品&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.processon.com/&#34;&gt;ProcessOn&lt;/a&gt;: 很好用的产品，但是对于免费用户来说可保存的文件有限&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yuque.com/&#34;&gt;语雀&lt;/a&gt;: 阿里开源的一个在线知识写作平台，个人免费用户基本没什么限制，其中有个实验室功能，可以在线使用&lt;code&gt;PlantUML&lt;/code&gt;语法绘制各种图(流程图，时序图，UML图等)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://online.visual-paradigm.com/cn/&#34;&gt;Visual-paradigm&lt;/a&gt;: 和ProcessOn类似&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://draw.io/&#34;&gt;Draw&lt;/a&gt;: 开源免费的在线绘图(需要使用谷歌账号进行注册登录,不过既然开源是可以私有化部署，支持各种客户端)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;draw相关地址&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_33929309/article/details/91609993&#34;&gt;参考文章&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dl.elkpi.com:8080/draw/&#34;&gt;国内在线draw&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jgraph/drawio&#34;&gt;draw开源地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jgraph/drawio-desktop&#34;&gt;draw客户端&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
